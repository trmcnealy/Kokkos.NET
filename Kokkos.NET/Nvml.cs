
using System.Runtime.InteropServices;

namespace Kokkos
{
    public class Nvml
    {
        public static readonly string LibraryName = "nvml";

        /// <summary>
        /// Enum to represent type of bridge chip
        /// </summary>
        public enum nvmlBridgeChipType_enum : uint
        {
            NVML_BRIDGE_CHIP_PLX = unchecked((uint)0),
            
            NVML_BRIDGE_CHIP_BRO4 = unchecked((uint)1),
        }
        
        /// <summary>
        /// Enum to represent the NvLink utilization counter packet units
        /// </summary>
        public enum nvmlNvLinkUtilizationCountUnits_enum : uint
        {
            NVML_NVLINK_COUNTER_UNIT_CYCLES = unchecked((uint)0),
            
            NVML_NVLINK_COUNTER_UNIT_PACKETS = unchecked((uint)1),
            
            NVML_NVLINK_COUNTER_UNIT_BYTES = unchecked((uint)2),
            
            NVML_NVLINK_COUNTER_UNIT_RESERVED = unchecked((uint)3),
            
            NVML_NVLINK_COUNTER_UNIT_COUNT,
        }
        
        /// <summary>
        /// Enum to represent the NvLink utilization counter packet types to count
        /// ** this is ONLY applicable with the units as packets or bytes
        /// ** as specified in @a nvmlNvLinkUtilizationCountUnits_t ** all packet filter descriptions are target GPU centric
        /// ** these can be "OR'd" together
        /// </summary>
        public enum nvmlNvLinkUtilizationCountPktTypes_enum : uint
        {
            NVML_NVLINK_COUNTER_PKTFILTER_NOP = unchecked((uint)0x1),
            
            NVML_NVLINK_COUNTER_PKTFILTER_READ = unchecked((uint)0x2),
            
            NVML_NVLINK_COUNTER_PKTFILTER_WRITE = unchecked((uint)0x4),
            
            NVML_NVLINK_COUNTER_PKTFILTER_RATOM = unchecked((uint)0x8),
            
            NVML_NVLINK_COUNTER_PKTFILTER_NRATOM = unchecked((uint)0x10),
            
            NVML_NVLINK_COUNTER_PKTFILTER_FLUSH = unchecked((uint)0x20),
            
            NVML_NVLINK_COUNTER_PKTFILTER_RESPDATA = unchecked((uint)0x40),
            
            NVML_NVLINK_COUNTER_PKTFILTER_RESPNODATA = unchecked((uint)0x80),
            
            NVML_NVLINK_COUNTER_PKTFILTER_ALL = unchecked((uint)0xFF),
        }
        
        /// <summary>
        /// Enum to represent NvLink queryable capabilities
        /// </summary>
        public enum nvmlNvLinkCapability_enum : uint
        {
            NVML_NVLINK_CAP_P2P_SUPPORTED = unchecked((uint)0),
            
            NVML_NVLINK_CAP_SYSMEM_ACCESS = unchecked((uint)1),
            
            NVML_NVLINK_CAP_P2P_ATOMICS = unchecked((uint)2),
            
            NVML_NVLINK_CAP_SYSMEM_ATOMICS = unchecked((uint)3),
            
            NVML_NVLINK_CAP_SLI_BRIDGE = unchecked((uint)4),
            
            NVML_NVLINK_CAP_VALID = unchecked((uint)5),
            
            NVML_NVLINK_CAP_COUNT,
        }
        
        /// <summary>
        /// Enum to represent NvLink queryable error counters
        /// </summary>
        public enum nvmlNvLinkErrorCounter_enum : uint
        {
            NVML_NVLINK_ERROR_DL_REPLAY = unchecked((uint)0),
            
            NVML_NVLINK_ERROR_DL_RECOVERY = unchecked((uint)1),
            
            NVML_NVLINK_ERROR_DL_CRC_FLIT = unchecked((uint)2),
            
            NVML_NVLINK_ERROR_DL_CRC_DATA = unchecked((uint)3),
            
            NVML_NVLINK_ERROR_COUNT,
        }
        
        /// <summary>
        /// Represents level relationships within a system between two GPUs
        /// The enums are spaced to allow for future relationships
        /// </summary>
        public enum nvmlGpuLevel_enum : uint
        {
            NVML_TOPOLOGY_INTERNAL = unchecked((uint)0),
            
            NVML_TOPOLOGY_SINGLE = unchecked((uint)10),
            
            NVML_TOPOLOGY_MULTIPLE = unchecked((uint)20),
            
            NVML_TOPOLOGY_HOSTBRIDGE = unchecked((uint)30),
            
            NVML_TOPOLOGY_NODE = unchecked((uint)40),
            
            NVML_TOPOLOGY_SYSTEM = unchecked((uint)50),
        }
        
        public enum nvmlGpuP2PStatus_enum : uint
        {
            NVML_P2P_STATUS_OK = unchecked((uint)0),
            
            NVML_P2P_STATUS_CHIPSET_NOT_SUPPORED,
            
            NVML_P2P_STATUS_GPU_NOT_SUPPORTED,
            
            NVML_P2P_STATUS_IOH_TOPOLOGY_NOT_SUPPORTED,
            
            NVML_P2P_STATUS_DISABLED_BY_REGKEY,
            
            NVML_P2P_STATUS_NOT_SUPPORTED,
            
            NVML_P2P_STATUS_UNKNOWN,
        }
        
        public enum nvmlGpuP2PCapsIndex_enum : uint
        {
            NVML_P2P_CAPS_INDEX_READ = unchecked((uint)0),
            
            NVML_P2P_CAPS_INDEX_WRITE,
            
            NVML_P2P_CAPS_INDEX_NVLINK,
            
            NVML_P2P_CAPS_INDEX_ATOMICS,
            
            NVML_P2P_CAPS_INDEX_PROP,
            
            NVML_P2P_CAPS_INDEX_UNKNOWN,
        }
        
        /// <summary>
        /// Represents Type of Sampling Event
        /// </summary>
        public enum nvmlSamplingType_enum : uint
        {
            /// <summary>
            /// To represent total power drawn by GPU
            /// </summary>
            NVML_TOTAL_POWER_SAMPLES = unchecked((uint)0),
            
            /// <summary>
            /// To represent percent of time during which one or more kernels was executing on the GPU
            /// </summary>
            NVML_GPU_UTILIZATION_SAMPLES = unchecked((uint)1),
            
            /// <summary>
            /// To represent percent of time during which global (device) memory was being read or written
            /// </summary>
            NVML_MEMORY_UTILIZATION_SAMPLES = unchecked((uint)2),
            
            /// <summary>
            /// To represent percent of time during which NVENC remains busy
            /// </summary>
            NVML_ENC_UTILIZATION_SAMPLES = unchecked((uint)3),
            
            /// <summary>
            /// To represent percent of time during which NVDEC remains busy
            /// </summary>
            NVML_DEC_UTILIZATION_SAMPLES = unchecked((uint)4),
            
            /// <summary>
            /// To represent processor clock samples
            /// </summary>
            NVML_PROCESSOR_CLK_SAMPLES = unchecked((uint)5),
            
            /// <summary>
            /// To represent memory clock samples
            /// </summary>
            NVML_MEMORY_CLK_SAMPLES = unchecked((uint)6),
            
            NVML_SAMPLINGTYPE_COUNT,
        }
        
        /// <summary>
        /// Represents the queryable PCIe utilization counters
        /// </summary>
        public enum nvmlPcieUtilCounter_enum : uint
        {
            NVML_PCIE_UTIL_TX_BYTES = unchecked((uint)0),
            
            NVML_PCIE_UTIL_RX_BYTES = unchecked((uint)1),
            
            NVML_PCIE_UTIL_COUNT,
        }
        
        /// <summary>
        /// Represents the type for sample value returned
        /// </summary>
        public enum nvmlValueType_enum : uint
        {
            NVML_VALUE_TYPE_DOUBLE = unchecked((uint)0),
            
            NVML_VALUE_TYPE_UNSIGNED_INT = unchecked((uint)1),
            
            NVML_VALUE_TYPE_UNSIGNED_LONG = unchecked((uint)2),
            
            NVML_VALUE_TYPE_UNSIGNED_LONG_LONG = unchecked((uint)3),
            
            NVML_VALUE_TYPE_SIGNED_LONG_LONG = unchecked((uint)4),
            
            NVML_VALUE_TYPE_COUNT,
        }
        
        /// <summary>
        /// Represents type of perf policy for which violation times can be queried
        /// </summary>
        public enum nvmlPerfPolicyType_enum : uint
        {
            /// <summary>
            /// How long did power violations cause the GPU to be below application clocks
            /// </summary>
            NVML_PERF_POLICY_POWER = unchecked((uint)0),
            
            /// <summary>
            /// How long did thermal violations cause the GPU to be below application clocks
            /// </summary>
            NVML_PERF_POLICY_THERMAL = unchecked((uint)1),
            
            /// <summary>
            /// How long did sync boost cause the GPU to be below application clocks
            /// </summary>
            NVML_PERF_POLICY_SYNC_BOOST = unchecked((uint)2),
            
            /// <summary>
            /// How long did the board limit cause the GPU to be below application clocks
            /// </summary>
            NVML_PERF_POLICY_BOARD_LIMIT = unchecked((uint)3),
            
            /// <summary>
            /// How long did low utilization cause the GPU to be below application clocks
            /// </summary>
            NVML_PERF_POLICY_LOW_UTILIZATION = unchecked((uint)4),
            
            /// <summary>
            /// How long did the board reliability limit cause the GPU to be below application clocks
            /// </summary>
            NVML_PERF_POLICY_RELIABILITY = unchecked((uint)5),
            
            /// <summary>
            /// Total time the GPU was held below application clocks by any limiter (0 - 5 above)
            /// </summary>
            NVML_PERF_POLICY_TOTAL_APP_CLOCKS = unchecked((uint)10),
            
            /// <summary>
            /// Total time the GPU was held below base clocks
            /// </summary>
            NVML_PERF_POLICY_TOTAL_BASE_CLOCKS = unchecked((uint)11),
            
            NVML_PERF_POLICY_COUNT,
        }
        
        /// <summary>
        /// Generic enable/disable enum.
        /// </summary>
        public enum nvmlEnableState_enum : uint
        {
            /// <summary>
            /// Feature disabled
            /// </summary>
            NVML_FEATURE_DISABLED = unchecked((uint)0),
            
            /// <summary>
            /// Feature enabled
            /// </summary>
            NVML_FEATURE_ENABLED = unchecked((uint)1),
        }
        
        /// <summary>
        /// * The Brand of the GPU
        /// </summary>
        public enum nvmlBrandType_enum : uint
        {
            NVML_BRAND_UNKNOWN = unchecked((uint)0),
            
            NVML_BRAND_QUADRO = unchecked((uint)1),
            
            NVML_BRAND_TESLA = unchecked((uint)2),
            
            NVML_BRAND_NVS = unchecked((uint)3),
            
            NVML_BRAND_GRID = unchecked((uint)4),
            
            NVML_BRAND_GEFORCE = unchecked((uint)5),
            
            NVML_BRAND_TITAN = unchecked((uint)6),
            
            NVML_BRAND_COUNT,
        }
        
        /// <summary>
        /// Temperature thresholds.
        /// </summary>
        public enum nvmlTemperatureThresholds_enum : uint
        {
            NVML_TEMPERATURE_THRESHOLD_SHUTDOWN = unchecked((uint)0),
            
            NVML_TEMPERATURE_THRESHOLD_SLOWDOWN = unchecked((uint)1),
            
            NVML_TEMPERATURE_THRESHOLD_MEM_MAX = unchecked((uint)2),
            
            NVML_TEMPERATURE_THRESHOLD_GPU_MAX = unchecked((uint)3),
            
            NVML_TEMPERATURE_THRESHOLD_COUNT,
        }
        
        /// <summary>
        /// Temperature sensors.
        /// </summary>
        public enum nvmlTemperatureSensors_enum : uint
        {
            /// <summary>
            /// Temperature sensor for the GPU die
            /// </summary>
            NVML_TEMPERATURE_GPU = unchecked((uint)0),
            
            NVML_TEMPERATURE_COUNT,
        }
        
        /// <summary>
        /// Compute mode.
        /// </summary>
        /// <remarks>
        /// NVML_COMPUTEMODE_EXCLUSIVE_PROCESS was added in CUDA 4.0.
        /// Earlier CUDA versions supported a single exclusive mode, 
        /// which is equivalent to NVML_COMPUTEMODE_EXCLUSIVE_THREAD in CUDA 4.0 and beyond.
        /// </remarks>
        public enum nvmlComputeMode_enum : uint
        {
            /// <summary>
            /// Default compute mode -- multiple contexts per device
            /// </summary>
            NVML_COMPUTEMODE_DEFAULT = unchecked((uint)0),
            
            /// <summary>
            /// Support Removed
            /// </summary>
            NVML_COMPUTEMODE_EXCLUSIVE_THREAD = unchecked((uint)1),
            
            /// <summary>
            /// Compute-prohibited mode -- no contexts per device
            /// </summary>
            NVML_COMPUTEMODE_PROHIBITED = unchecked((uint)2),
            
            /// <summary>
            /// Compute-exclusive-process mode -- only one context per device, usable from multiple threads at a time
            /// </summary>
            NVML_COMPUTEMODE_EXCLUSIVE_PROCESS = unchecked((uint)3),
            
            NVML_COMPUTEMODE_COUNT,
        }
        
        /// <summary>
        /// Memory error types
        /// </summary>
        public enum nvmlMemoryErrorType_enum : uint
        {
            /// <summary>
            /// A memory error that was corrected
            /// </summary>
            /// <remarks>
            /// For ECC errors, these are single bit errors
            /// For Texture memory, these are errors fixed by resend
            /// </remarks>
            NVML_MEMORY_ERROR_TYPE_CORRECTED = unchecked((uint)0),
            
            /// <summary>
            /// A memory error that was not corrected
            /// </summary>
            /// <remarks>
            /// For ECC errors, these are double bit errors
            /// For Texture memory, these are errors where the resend fails
            /// </remarks>
            NVML_MEMORY_ERROR_TYPE_UNCORRECTED = unchecked((uint)1),
            
            /// <summary>
            /// Count of memory error types
            /// </summary>
            NVML_MEMORY_ERROR_TYPE_COUNT,
        }
        
        /// <summary>
        /// ECC counter types.
        /// </summary>
        /// <remarks>
        /// Note: Volatile counts are reset each time the driver loads. On Windows this is once per boot. On Linux this can be more frequent.
        /// On Linux the driver unloads when no active clients exist. If persistence mode is enabled or there is always a driver 
        /// client active (e.g. X11), then Linux also sees per-boot behavior. If not, volatile counts are reset each time a compute app
        /// is run.
        /// </remarks>
        public enum nvmlEccCounterType_enum : uint
        {
            /// <summary>
            /// Volatile counts are reset each time the driver loads.
            /// </summary>
            NVML_VOLATILE_ECC = unchecked((uint)0),
            
            /// <summary>
            /// Aggregate counts persist across reboots (i.e. for the lifetime of the device)
            /// </summary>
            NVML_AGGREGATE_ECC = unchecked((uint)1),
            
            /// <summary>
            /// Count of memory counter types
            /// </summary>
            NVML_ECC_COUNTER_TYPE_COUNT,
        }
        
        /// <summary>
        /// Clock types.
        /// </summary>
        /// <remarks>
        /// All speeds are in Mhz.
        /// </remarks>
        public enum nvmlClockType_enum : uint
        {
            /// <summary>
            /// Graphics clock domain
            /// </summary>
            NVML_CLOCK_GRAPHICS = unchecked((uint)0),
            
            /// <summary>
            /// SM clock domain
            /// </summary>
            NVML_CLOCK_SM = unchecked((uint)1),
            
            /// <summary>
            /// Memory clock domain
            /// </summary>
            NVML_CLOCK_MEM = unchecked((uint)2),
            
            /// <summary>
            /// Video encoder/decoder clock domain
            /// </summary>
            NVML_CLOCK_VIDEO = unchecked((uint)3),
            
            /// <summary>
            /// Count of clock types
            /// </summary>
            NVML_CLOCK_COUNT,
        }
        
        /// <summary>
        /// Clock Ids.  These are used in combination with nvmlClockType_t
        /// to specify a single clock value.
        /// </summary>
        public enum nvmlClockId_enum : uint
        {
            /// <summary>
            /// Current actual clock value
            /// </summary>
            NVML_CLOCK_ID_CURRENT = unchecked((uint)0),
            
            /// <summary>
            /// Target application clock
            /// </summary>
            NVML_CLOCK_ID_APP_CLOCK_TARGET = unchecked((uint)1),
            
            /// <summary>
            /// Default application clock target
            /// </summary>
            NVML_CLOCK_ID_APP_CLOCK_DEFAULT = unchecked((uint)2),
            
            /// <summary>
            /// OEM-defined maximum clock rate
            /// </summary>
            NVML_CLOCK_ID_CUSTOMER_BOOST_MAX = unchecked((uint)3),
            
            /// <summary>
            /// Count of Clock Ids.
            /// </summary>
            NVML_CLOCK_ID_COUNT,
        }
        
        /// <summary>
        /// Driver models.
        /// </summary>
        /// <remarks>
        /// Windows only.
        /// </remarks>
        public enum nvmlDriverModel_enum : uint
        {
            /// <summary>
            /// WDDM driver model -- GPU treated as a display device
            /// </summary>
            NVML_DRIVER_WDDM = unchecked((uint)0),
            
            /// <summary>
            /// WDM (TCC) model (recommended) -- GPU treated as a generic device
            /// </summary>
            NVML_DRIVER_WDM = unchecked((uint)1),
        }
        
        /// <summary>
        /// Allowed PStates.
        /// </summary>
        public enum nvmlPStates_enum : uint
        {
            /// <summary>
            /// Performance state 0 -- Maximum Performance
            /// </summary>
            NVML_PSTATE_0 = unchecked((uint)0),
            
            /// <summary>
            /// Performance state 1
            /// </summary>
            NVML_PSTATE_1 = unchecked((uint)1),
            
            /// <summary>
            /// Performance state 2
            /// </summary>
            NVML_PSTATE_2 = unchecked((uint)2),
            
            /// <summary>
            /// Performance state 3
            /// </summary>
            NVML_PSTATE_3 = unchecked((uint)3),
            
            /// <summary>
            /// Performance state 4
            /// </summary>
            NVML_PSTATE_4 = unchecked((uint)4),
            
            /// <summary>
            /// Performance state 5
            /// </summary>
            NVML_PSTATE_5 = unchecked((uint)5),
            
            /// <summary>
            /// Performance state 6
            /// </summary>
            NVML_PSTATE_6 = unchecked((uint)6),
            
            /// <summary>
            /// Performance state 7
            /// </summary>
            NVML_PSTATE_7 = unchecked((uint)7),
            
            /// <summary>
            /// Performance state 8
            /// </summary>
            NVML_PSTATE_8 = unchecked((uint)8),
            
            /// <summary>
            /// Performance state 9
            /// </summary>
            NVML_PSTATE_9 = unchecked((uint)9),
            
            /// <summary>
            /// Performance state 10
            /// </summary>
            NVML_PSTATE_10 = unchecked((uint)10),
            
            /// <summary>
            /// Performance state 11
            /// </summary>
            NVML_PSTATE_11 = unchecked((uint)11),
            
            /// <summary>
            /// Performance state 12
            /// </summary>
            NVML_PSTATE_12 = unchecked((uint)12),
            
            /// <summary>
            /// Performance state 13
            /// </summary>
            NVML_PSTATE_13 = unchecked((uint)13),
            
            /// <summary>
            /// Performance state 14
            /// </summary>
            NVML_PSTATE_14 = unchecked((uint)14),
            
            /// <summary>
            /// Performance state 15 -- Minimum Performance
            /// </summary>
            NVML_PSTATE_15 = unchecked((uint)15),
            
            /// <summary>
            /// Unknown performance state
            /// </summary>
            NVML_PSTATE_UNKNOWN = unchecked((uint)32),
        }
        
        /// <summary>
        /// GPU Operation Mode
        /// </summary>
        /// <remarks>
        /// GOM allows to reduce power usage and optimize GPU throughput by disabling GPU features.Each GOM is designed to meet specific user needs.
        /// </remarks>
        public enum nvmlGom_enum : uint
        {
            /// <summary>
            /// Everything is enabled and running at full speed
            /// </summary>
            NVML_GOM_ALL_ON = unchecked((uint)0),
            
            /// <summary>
            /// Designed for running only compute tasks. Graphics operations
            /// are not allowed
            /// </summary>
            NVML_GOM_COMPUTE = unchecked((uint)1),
            
            /// <summary>
            /// Designed for running graphics applications that don't require
            /// high bandwidth double precision
            /// </summary>
            NVML_GOM_LOW_DP = unchecked((uint)2),
        }
        
        /// <summary>
        /// Available infoROM objects.
        /// </summary>
        public enum nvmlInforomObject_enum : uint
        {
            /// <summary>
            /// An object defined by OEM
            /// </summary>
            NVML_INFOROM_OEM = unchecked((uint)0),
            
            /// <summary>
            /// The ECC object determining the level of ECC support
            /// </summary>
            NVML_INFOROM_ECC = unchecked((uint)1),
            
            /// <summary>
            /// The power management object
            /// </summary>
            NVML_INFOROM_POWER = unchecked((uint)2),
            
            /// <summary>
            /// This counts the number of infoROM objects the driver knows about
            /// </summary>
            NVML_INFOROM_COUNT,
        }
        
        /// <summary>
        /// Return values for NVML API calls.
        /// </summary>
        public enum nvmlReturn_enum : uint
        {
            /// <summary>
            /// The operation was successful
            /// </summary>
            NVML_SUCCESS = unchecked((uint)0),
            
            /// <summary>
            /// NVML was not first initialized with nvmlInit()
            /// </summary>
            NVML_ERROR_UNINITIALIZED = unchecked((uint)1),
            
            /// <summary>
            /// A supplied argument is invalid
            /// </summary>
            NVML_ERROR_INVALID_ARGUMENT = unchecked((uint)2),
            
            /// <summary>
            /// The requested operation is not available on target device
            /// </summary>
            NVML_ERROR_NOT_SUPPORTED = unchecked((uint)3),
            
            /// <summary>
            /// The current user does not have permission for operation
            /// </summary>
            NVML_ERROR_NO_PERMISSION = unchecked((uint)4),
            
            /// <summary>
            /// Deprecated: Multiple initializations are now allowed through ref counting
            /// </summary>
            NVML_ERROR_ALREADY_INITIALIZED = unchecked((uint)5),
            
            /// <summary>
            /// A query to find an object was unsuccessful
            /// </summary>
            NVML_ERROR_NOT_FOUND = unchecked((uint)6),
            
            /// <summary>
            /// An input argument is not large enough
            /// </summary>
            NVML_ERROR_INSUFFICIENT_SIZE = unchecked((uint)7),
            
            /// <summary>
            /// A device's external power cables are not properly attached
            /// </summary>
            NVML_ERROR_INSUFFICIENT_POWER = unchecked((uint)8),
            
            /// <summary>
            /// NVIDIA driver is not loaded
            /// </summary>
            NVML_ERROR_DRIVER_NOT_LOADED = unchecked((uint)9),
            
            /// <summary>
            /// User provided timeout passed
            /// </summary>
            NVML_ERROR_TIMEOUT = unchecked((uint)10),
            
            /// <summary>
            /// NVIDIA Kernel detected an interrupt issue with a GPU
            /// </summary>
            NVML_ERROR_IRQ_ISSUE = unchecked((uint)11),
            
            /// <summary>
            /// NVML Shared Library couldn't be found or loaded
            /// </summary>
            NVML_ERROR_LIBRARY_NOT_FOUND = unchecked((uint)12),
            
            /// <summary>
            /// Local version of NVML doesn't implement this function
            /// </summary>
            NVML_ERROR_FUNCTION_NOT_FOUND = unchecked((uint)13),
            
            /// <summary>
            /// infoROM is corrupted
            /// </summary>
            NVML_ERROR_CORRUPTED_INFOROM = unchecked((uint)14),
            
            /// <summary>
            /// The GPU has fallen off the bus or has otherwise become inaccessible
            /// </summary>
            NVML_ERROR_GPU_IS_LOST = unchecked((uint)15),
            
            /// <summary>
            /// The GPU requires a reset before it can be used again
            /// </summary>
            NVML_ERROR_RESET_REQUIRED = unchecked((uint)16),
            
            /// <summary>
            /// The GPU control device has been blocked by the operating system/cgroups
            /// </summary>
            NVML_ERROR_OPERATING_SYSTEM = unchecked((uint)17),
            
            /// <summary>
            /// RM detects a driver/library version mismatch
            /// </summary>
            NVML_ERROR_LIB_RM_VERSION_MISMATCH = unchecked((uint)18),
            
            /// <summary>
            /// An operation cannot be performed because the GPU is currently in use
            /// </summary>
            NVML_ERROR_IN_USE = unchecked((uint)19),
            
            /// <summary>
            /// Insufficient memory
            /// </summary>
            NVML_ERROR_MEMORY = unchecked((uint)20),
            
            /// <summary>
            /// No data
            /// </summary>
            NVML_ERROR_NO_DATA = unchecked((uint)21),
            
            /// <summary>
            /// The requested vgpu operation is not available on target device, becasue ECC is enabled
            /// </summary>
            NVML_ERROR_VGPU_ECC_NOT_SUPPORTED = unchecked((uint)22),
            
            /// <summary>
            /// An internal driver error occurred
            /// </summary>
            NVML_ERROR_UNKNOWN = unchecked((uint)999),
        }
        
        /// <summary>
        /// See
        /// </summary>
        /// <remarks>
        ///  nvmlDeviceGetMemoryErrorCounter
        /// </remarks>
        public enum nvmlMemoryLocation_enum : uint
        {
            /// <summary>
            /// GPU L1 Cache
            /// </summary>
            NVML_MEMORY_LOCATION_L1_CACHE = unchecked((uint)0),
            
            /// <summary>
            /// GPU L2 Cache
            /// </summary>
            NVML_MEMORY_LOCATION_L2_CACHE = unchecked((uint)1),
            
            /// <summary>
            /// Turing+ DRAM
            /// </summary>
            NVML_MEMORY_LOCATION_DRAM = unchecked((uint)2),
            
            /// <summary>
            /// GPU Device Memory
            /// </summary>
            NVML_MEMORY_LOCATION_DEVICE_MEMORY = unchecked((uint)2),
            
            /// <summary>
            /// GPU Register File
            /// </summary>
            NVML_MEMORY_LOCATION_REGISTER_FILE = unchecked((uint)3),
            
            /// <summary>
            /// GPU Texture Memory
            /// </summary>
            NVML_MEMORY_LOCATION_TEXTURE_MEMORY = unchecked((uint)4),
            
            /// <summary>
            /// Shared memory
            /// </summary>
            NVML_MEMORY_LOCATION_TEXTURE_SHM = unchecked((uint)5),
            
            /// <summary>
            /// CBU
            /// </summary>
            NVML_MEMORY_LOCATION_CBU = unchecked((uint)6),
            
            /// <summary>
            /// Turing+ SRAM
            /// </summary>
            NVML_MEMORY_LOCATION_SRAM = unchecked((uint)7),
            
            /// <summary>
            /// This counts the number of memory locations the driver knows about
            /// </summary>
            NVML_MEMORY_LOCATION_COUNT,
        }
        
        /// <summary>
        /// Causes for page retirement
        /// </summary>
        public enum nvmlPageRetirementCause_enum : uint
        {
            /// <summary>
            /// Page was retired due to multiple single bit ECC error
            /// </summary>
            NVML_PAGE_RETIREMENT_CAUSE_MULTIPLE_SINGLE_BIT_ECC_ERRORS = unchecked((uint)0),
            
            /// <summary>
            /// Page was retired due to double bit ECC error
            /// </summary>
            NVML_PAGE_RETIREMENT_CAUSE_DOUBLE_BIT_ECC_ERROR = unchecked((uint)1),
            
            NVML_PAGE_RETIREMENT_CAUSE_COUNT,
        }
        
        /// <summary>
        /// API types that allow changes to default permission restrictions
        /// </summary>
        public enum nvmlRestrictedAPI_enum : uint
        {
            /// <summary>
            /// APIs that change application clocks, see nvmlDeviceSetApplicationsClocks 
            /// and see nvmlDeviceResetApplicationsClocks
            /// </summary>
            NVML_RESTRICTED_API_SET_APPLICATION_CLOCKS = unchecked((uint)0),
            
            /// <summary>
            /// APIs that enable/disable Auto Boosted clocks
            /// see nvmlDeviceSetAutoBoostedClocksEnabled
            /// </summary>
            NVML_RESTRICTED_API_SET_AUTO_BOOSTED_CLOCKS = unchecked((uint)1),
            
            NVML_RESTRICTED_API_COUNT,
        }
        
        /// <summary>
        /// GPU virtualization mode types.
        /// </summary>
        public enum nvmlGpuVirtualizationMode : uint
        {
            /// <summary>
            /// Represents Bare Metal GPU
            /// </summary>
            NVML_GPU_VIRTUALIZATION_MODE_NONE = unchecked((uint)0),
            
            /// <summary>
            /// Device is associated with GPU-Passthorugh
            /// </summary>
            NVML_GPU_VIRTUALIZATION_MODE_PASSTHROUGH = unchecked((uint)1),
            
            /// <summary>
            /// Device is associated with vGPU inside virtual machine.
            /// </summary>
            NVML_GPU_VIRTUALIZATION_MODE_VGPU = unchecked((uint)2),
            
            /// <summary>
            /// Device is associated with VGX hypervisor in vGPU mode
            /// </summary>
            NVML_GPU_VIRTUALIZATION_MODE_HOST_VGPU = unchecked((uint)3),
            
            /// <summary>
            /// Device is associated with VGX hypervisor in vSGA mode
            /// </summary>
            NVML_GPU_VIRTUALIZATION_MODE_HOST_VSGA = unchecked((uint)4),
        }
        
        /// <summary>
        /// Fan state enum.
        /// </summary>
        public enum nvmlFanState_enum : uint
        {
            /// <summary>
            /// Fan is working properly
            /// </summary>
            NVML_FAN_NORMAL = unchecked((uint)0),
            
            /// <summary>
            /// Fan has failed
            /// </summary>
            NVML_FAN_FAILED = unchecked((uint)1),
        }
        
        /// <summary>
        /// Led color enum.
        /// </summary>
        public enum nvmlLedColor_enum : uint
        {
            /// <summary>
            /// GREEN, indicates good health
            /// </summary>
            NVML_LED_COLOR_GREEN = unchecked((uint)0),
            
            /// <summary>
            /// AMBER, indicates problem
            /// </summary>
            NVML_LED_COLOR_AMBER = unchecked((uint)1),
        }
        
        /// <summary>
        /// Types of VM identifiers
        /// </summary>
        public enum nvmlVgpuVmIdType : uint
        {
            /// <summary>
            /// VM ID represents DOMAIN ID
            /// </summary>
            NVML_VGPU_VM_ID_DOMAIN_ID = unchecked((uint)0),
            
            /// <summary>
            /// VM ID represents UUID
            /// </summary>
            NVML_VGPU_VM_ID_UUID = unchecked((uint)1),
        }
        
        /// <summary>
        /// vGPU GUEST info state.
        /// </summary>
        public enum nvmlVgpuGuestInfoState_enum : uint
        {
            /// <summary>
            /// Guest-dependent fields uninitialized
            /// </summary>
            NVML_VGPU_INSTANCE_GUEST_INFO_STATE_UNINITIALIZED = unchecked((uint)0),
            
            /// <summary>
            /// Guest-dependent fields initialized
            /// </summary>
            NVML_VGPU_INSTANCE_GUEST_INFO_STATE_INITIALIZED = unchecked((uint)1),
        }
        
        /// <summary>
        /// GRID license feature code
        /// </summary>
        public enum nvmlGridLicenseFeatureCode_t : uint
        {
            /// <summary>
            /// Virtual GPU
            /// </summary>
            NVML_GRID_LICENSE_FEATURE_CODE_VGPU = unchecked((uint)1),
            
            /// <summary>
            /// Virtual Workstation
            /// </summary>
            NVML_GRID_LICENSE_FEATURE_CODE_VWORKSTATION = unchecked((uint)2),
        }
        
        /// <summary>
        /// Represents type of encoder for capacity can be queried
        /// </summary>
        public enum nvmlEncoderQueryType_enum : uint
        {
            /// <summary>
            /// H264 encoder
            /// </summary>
            NVML_ENCODER_QUERY_H264 = unchecked((uint)0),
            
            /// <summary>
            /// HEVC encoder
            /// </summary>
            NVML_ENCODER_QUERY_HEVC = unchecked((uint)1),
        }
        
        /// <summary>
        /// Represents frame buffer capture session type
        /// </summary>
        public enum nvmlFBCSessionType_enum : uint
        {
            /// <summary>
            /// Unknwon
            /// </summary>
            NVML_FBC_SESSION_TYPE_UNKNOWN = unchecked((uint)0),
            
            /// <summary>
            /// ToSys
            /// </summary>
            NVML_FBC_SESSION_TYPE_TOSYS,
            
            /// <summary>
            /// Cuda
            /// </summary>
            NVML_FBC_SESSION_TYPE_CUDA,
            
            /// <summary>
            /// Vid
            /// </summary>
            NVML_FBC_SESSION_TYPE_VID,
            
            /// <summary>
            /// HEnc
            /// </summary>
            NVML_FBC_SESSION_TYPE_HWENC,
        }
        
        /// <summary>
        /// Is the GPU device to be removed from the kernel by nvmlDeviceRemoveGpu()
        /// </summary>
        public enum nvmlDetachGpuState_enum : uint
        {
            NVML_DETACH_GPU_KEEP = unchecked((uint)0),
            
            NVML_DETACH_GPU_REMOVE,
        }
        
        /// <summary>
        /// Parent bridge PCIe link state requested by nvmlDeviceRemoveGpu()
        /// </summary>
        public enum nvmlPcieLinkState_enum : uint
        {
            NVML_PCIE_LINK_KEEP = unchecked((uint)0),
            
            NVML_PCIE_LINK_SHUT_DOWN,
        }
        
        /// <summary>
        /// vGPU VM compatibility codes
        /// </summary>
        public enum nvmlVgpuVmCompatibility_enum : uint
        {
            /// <summary>
            /// vGPU is not runnable
            /// </summary>
            NVML_VGPU_VM_COMPATIBILITY_NONE = unchecked((uint)0x0),
            
            /// <summary>
            /// vGPU is runnable from a cold / powered-off state (ACPI S5)
            /// </summary>
            NVML_VGPU_VM_COMPATIBILITY_COLD = unchecked((uint)0x1),
            
            /// <summary>
            /// vGPU is runnable from a hibernated state (ACPI S4)
            /// </summary>
            NVML_VGPU_VM_COMPATIBILITY_HIBERNATE = unchecked((uint)0x2),
            
            /// <summary>
            /// vGPU is runnable from a sleeped state (ACPI S3)
            /// </summary>
            NVML_VGPU_VM_COMPATIBILITY_SLEEP = unchecked((uint)0x4),
            
            /// <summary>
            /// vGPU is runnable from a live/paused (ACPI S0)
            /// </summary>
            NVML_VGPU_VM_COMPATIBILITY_LIVE = unchecked((uint)0x8),
        }
        
        /// <summary>
        /// vGPU-pGPU compatibility limit codes
        /// </summary>
        public enum nvmlVgpuPgpuCompatibilityLimitCode_enum : uint
        {
            /// <summary>
            /// Compatibility is not limited.
            /// </summary>
            NVML_VGPU_COMPATIBILITY_LIMIT_NONE = unchecked((uint)0x0),
            
            /// <summary>
            /// ompatibility is limited by host driver version.
            /// </summary>
            NVML_VGPU_COMPATIBILITY_LIMIT_HOST_DRIVER = unchecked((uint)0x1),
            
            /// <summary>
            /// Compatibility is limited by guest driver version.
            /// </summary>
            NVML_VGPU_COMPATIBILITY_LIMIT_GUEST_DRIVER = unchecked((uint)0x2),
            
            /// <summary>
            /// Compatibility is limited by GPU hardware.
            /// </summary>
            NVML_VGPU_COMPATIBILITY_LIMIT_GPU = unchecked((uint)0x4),
            
            /// <summary>
            /// Compatibility is limited by an undefined factor.
            /// </summary>
            NVML_VGPU_COMPATIBILITY_LIMIT_OTHER = unchecked((uint)0x80000000),
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct nvmlDevice_st : IEquatable<nvmlDevice_st>
        {
            private readonly IntPtr _handle;
            
            public nvmlDevice_st(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(nvmlDevice_st other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is nvmlDevice_st other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(nvmlDevice_st left, nvmlDevice_st right) => left.Equals(right);
            
            public static bool operator !=(nvmlDevice_st left, nvmlDevice_st right) => !left.Equals(right);
        }
        
        /// <summary>
        /// PCI information about a GPU device.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct nvmlPciInfo_st
        {
            /// <summary>
            /// The legacy tuple domain:bus:device.function PCI identifier (
            /// &amp;
            /// NULL terminator)
            /// </summary>
            [MarshalAs(UnmanagedType.LPArray, SizeConst = 16)]
            public unsupported_type /* char */[] busIdLegacy;
            
            /// <summary>
            /// The PCI domain on which the device's bus resides, 0 to 0xffffffff
            /// </summary>
            public uint domain;
            
            /// <summary>
            /// The bus on which the device resides, 0 to 0xff
            /// </summary>
            public uint bus;
            
            /// <summary>
            /// The device's id on the bus, 0 to 31
            /// </summary>
            public uint device;
            
            /// <summary>
            /// The combined 16-bit device id and 16-bit vendor id
            /// </summary>
            public uint pciDeviceId;
            
            /// <summary>
            /// The 32-bit Sub System Device ID
            /// </summary>
            public uint pciSubSystemId;
            
            /// <summary>
            /// The tuple domain:bus:device.function PCI identifier (
            /// &amp;
            /// NULL terminator)
            /// </summary>
            [MarshalAs(UnmanagedType.LPArray, SizeConst = 32)]
            public unsupported_type /* char */[] busId;
        }
        
        /// <summary>
        /// Detailed ECC error counts for a device.
        /// </summary>
        /// <remarks>
        /// @deprecated Different GPU families can have different memory error counters
        /// See nvmlDeviceGetMemoryErrorCounter
        /// </remarks>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct nvmlEccErrorCounts_st
        {
            /// <summary>
            /// L1 cache errors
            /// </summary>
            public ulong l1Cache;
            
            /// <summary>
            /// L2 cache errors
            /// </summary>
            public ulong l2Cache;
            
            /// <summary>
            /// Device memory errors
            /// </summary>
            public ulong deviceMemory;
            
            /// <summary>
            /// Register file errors
            /// </summary>
            public ulong registerFile;
        }
        
        /// <summary>
        /// Utilization information for a device.
        /// Each sample period may be between 1 second and 1/6 second, depending on the product being queried.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct nvmlUtilization_st
        {
            /// <summary>
            /// Percent of time over the past sample period during which one or more kernels was executing on the GPU
            /// </summary>
            public uint gpu;
            
            /// <summary>
            /// Percent of time over the past sample period during which global (device) memory was being read or written
            /// </summary>
            public uint memory;
        }
        
        /// <summary>
        /// Memory allocation information for a device.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct nvmlMemory_st
        {
            /// <summary>
            /// Total installed FB memory (in bytes)
            /// </summary>
            public ulong total;
            
            /// <summary>
            /// Unallocated FB memory (in bytes)
            /// </summary>
            public ulong free;
            
            /// <summary>
            /// Allocated FB memory (in bytes). Note that the driver/GPU always sets aside a small amount of memory for bookkeeping
            /// </summary>
            public ulong used;
        }
        
        /// <summary>
        /// BAR1 Memory allocation Information for a device
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct nvmlBAR1Memory_st
        {
            /// <summary>
            /// Total BAR1 Memory (in bytes)
            /// </summary>
            public ulong bar1Total;
            
            /// <summary>
            /// Unallocated BAR1 Memory (in bytes)
            /// </summary>
            public ulong bar1Free;
            
            /// <summary>
            /// Allocated Used Memory (in bytes)
            /// </summary>
            public ulong bar1Used;
        }
        
        /// <summary>
        /// Information about running compute processes on the GPU
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct nvmlProcessInfo_st
        {
            /// <summary>
            /// Process ID
            /// </summary>
            public uint pid;
            
            /// <summary>
            /// Amount of used GPU memory in bytes.
            /// </summary>
            public ulong usedGpuMemory;
        }
        
        /// <summary>
        /// Struct to define the NVLINK counter controls
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct nvmlNvLinkUtilizationControl_st
        {
            public nvmlNvLinkUtilizationCountUnits_enum units;
            
            public nvmlNvLinkUtilizationCountPktTypes_enum pktfilter;
        }
        
        /// <summary>
        /// Information about the Bridge Chip Firmware
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct nvmlBridgeChipInfo_st
        {
            /// <summary>
            /// Type of Bridge Chip
            /// </summary>
            public nvmlBridgeChipType_enum type;
            
            /// <summary>
            /// Firmware Version. 0=Version is unavailable
            /// </summary>
            public uint fwVersion;
        }
        
        /// <summary>
        /// This structure stores the complete Hierarchy of the Bridge Chip within the board. The immediate 
        /// bridge is stored at index 0 of bridgeInfoList, parent to immediate bridge is at index 1 and so forth.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct nvmlBridgeChipHierarchy_st
        {
            /// <summary>
            /// Number of Bridge Chips on the Board
            /// </summary>
            public byte bridgeCount;
            
            /// <summary>
            /// Hierarchy of Bridge Chips on the board
            /// </summary>
            [MarshalAs(UnmanagedType.LPArray, SizeConst = 128)]
            public nvmlBridgeChipInfo_st[] bridgeChipInfo;
        }
        
        /// <summary>
        /// Union to represent different types of Value
        /// </summary>
        [StructLayout(LayoutKind.Explicit, CharSet = CharSet.Ansi)]
        public partial struct nvmlValue_st
        {
            /// <summary>
            /// If the value is double
            /// </summary>
            [FieldOffset(0)]
            public double dVal;
            
            /// <summary>
            /// If the value is unsigned int
            /// </summary>
            [FieldOffset(0)]
            public uint uiVal;
            
            /// <summary>
            /// If the value is unsigned long
            /// </summary>
            [FieldOffset(0)]
            public uint ulVal;
            
            /// <summary>
            /// If the value is unsigned long long
            /// </summary>
            [FieldOffset(0)]
            public ulong ullVal;
            
            /// <summary>
            /// If the value is signed long long
            /// </summary>
            [FieldOffset(0)]
            public long sllVal;
        }
        
        /// <summary>
        /// Information for Sample
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct nvmlSample_st
        {
            /// <summary>
            /// CPU Timestamp in microseconds
            /// </summary>
            public ulong timeStamp;
            
            /// <summary>
            /// Sample Value
            /// </summary>
            public nvmlValue_st sampleValue;
        }
        
        /// <summary>
        /// Struct to hold perf policy violation status data
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct nvmlViolationTime_st
        {
            /// <summary>
            /// referenceTime represents CPU timestamp in microseconds
            /// </summary>
            public ulong referenceTime;
            
            /// <summary>
            /// violationTime in Nanoseconds
            /// </summary>
            public ulong violationTime;
        }
        
        /// <summary>
        /// Information for a Field Value Sample
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct nvmlFieldValue_st
        {
            /// <summary>
            /// ID of the NVML field to retrieve. This must be set before any call that uses this struct. See the constants starting with NVML_FI_ above.
            /// </summary>
            public uint fieldId;
            
            /// <summary>
            /// Currently unused. This should be initialized to 0 by the caller before any API call
            /// </summary>
            public uint unused;
            
            /// <summary>
            /// CPU Timestamp of this value in microseconds since 1970
            /// </summary>
            public long timestamp;
            
            /// <summary>
            /// How long this field value took to update (in usec) within NVML. This may be averaged across several fields that are serviced by the same driver call.
            /// </summary>
            public long latencyUsec;
            
            /// <summary>
            /// Type of the value stored in value
            /// </summary>
            public nvmlValueType_enum valueType;
            
            /// <summary>
            /// Return code for retrieving this value. This must be checked before looking at value, as value is undefined if nvmlReturn != NVML_SUCCESS
            /// </summary>
            public nvmlReturn_enum nvmlReturn;
            
            /// <summary>
            /// Value for this field. This is only valid if nvmlReturn == NVML_SUCCESS
            /// </summary>
            public nvmlValue_st value;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct nvmlUnit_st : IEquatable<nvmlUnit_st>
        {
            private readonly IntPtr _handle;
            
            public nvmlUnit_st(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(nvmlUnit_st other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is nvmlUnit_st other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(nvmlUnit_st left, nvmlUnit_st right) => left.Equals(right);
            
            public static bool operator !=(nvmlUnit_st left, nvmlUnit_st right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Description of HWBC entry
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct nvmlHwbcEntry_st
        {
            public uint hwbcId;
            
            [MarshalAs(UnmanagedType.LPArray, SizeConst = 32)]
            public unsupported_type /* char */[] firmwareVersion;
        }
        
        /// <summary>
        /// LED states for an S-class unit.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct nvmlLedState_st
        {
            /// <summary>
            /// If amber, a text description of the cause
            /// </summary>
            [MarshalAs(UnmanagedType.LPArray, SizeConst = 256)]
            public unsupported_type /* char */[] cause;
            
            /// <summary>
            /// GREEN or AMBER
            /// </summary>
            public nvmlLedColor_enum color;
        }
        
        /// <summary>
        /// Static S-class unit info.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct nvmlUnitInfo_st
        {
            /// <summary>
            /// Product name
            /// </summary>
            [MarshalAs(UnmanagedType.LPArray, SizeConst = 96)]
            public unsupported_type /* char */[] name;
            
            /// <summary>
            /// Product identifier
            /// </summary>
            [MarshalAs(UnmanagedType.LPArray, SizeConst = 96)]
            public unsupported_type /* char */[] id;
            
            /// <summary>
            /// Product serial number
            /// </summary>
            [MarshalAs(UnmanagedType.LPArray, SizeConst = 96)]
            public unsupported_type /* char */[] serial;
            
            /// <summary>
            /// Firmware version
            /// </summary>
            [MarshalAs(UnmanagedType.LPArray, SizeConst = 96)]
            public unsupported_type /* char */[] firmwareVersion;
        }
        
        /// <summary>
        /// Power usage information for an S-class unit.
        /// The power supply state is a human readable string that equals "Normal" or contains
        /// a combination of "Abnormal" plus one or more of the following:
        /// </summary>
        /// <remarks>
        /// - High voltage
        /// - Fan failure
        /// - Heatsink temperature
        /// - Current limit
        /// - Voltage below UV alarm threshold
        /// - Low-voltage
        /// - SI2C remote off command
        /// - MOD_DISABLE input
        /// - Short pin transition
        /// </remarks>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct nvmlPSUInfo_st
        {
            /// <summary>
            /// The power supply state
            /// </summary>
            [MarshalAs(UnmanagedType.LPArray, SizeConst = 256)]
            public unsupported_type /* char */[] state;
            
            /// <summary>
            /// PSU current (A)
            /// </summary>
            public uint current;
            
            /// <summary>
            /// PSU voltage (V)
            /// </summary>
            public uint voltage;
            
            /// <summary>
            /// PSU power draw (W)
            /// </summary>
            public uint power;
        }
        
        /// <summary>
        /// Fan speed reading for a single fan in an S-class unit.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct nvmlUnitFanInfo_st
        {
            /// <summary>
            /// Fan speed (RPM)
            /// </summary>
            public uint speed;
            
            /// <summary>
            /// Flag that indicates whether fan is working properly
            /// </summary>
            public nvmlFanState_enum state;
        }
        
        /// <summary>
        /// Fan speed readings for an entire S-class unit.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct nvmlUnitFanSpeeds_st
        {
            /// <summary>
            /// Fan speed data for each fan
            /// </summary>
            [MarshalAs(UnmanagedType.LPArray, SizeConst = 24)]
            public nvmlUnitFanInfo_st[] fans;
            
            /// <summary>
            /// Number of fans in unit
            /// </summary>
            public uint count;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly partial struct nvmlEventSet_st : IEquatable<nvmlEventSet_st>
        {
            private readonly IntPtr _handle;
            
            public nvmlEventSet_st(IntPtr handle) => _handle = handle;
            
            public IntPtr Handle => _handle;
            
            public bool Equals(nvmlEventSet_st other) => _handle.Equals(other._handle);
            
            public override bool Equals(object obj) => obj is nvmlEventSet_st other && Equals(other);
            
            public override int GetHashCode() => _handle.GetHashCode();
            
            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));
            
            public static bool operator ==(nvmlEventSet_st left, nvmlEventSet_st right) => left.Equals(right);
            
            public static bool operator !=(nvmlEventSet_st left, nvmlEventSet_st right) => !left.Equals(right);
        }
        
        /// <summary>
        /// Information about occurred event
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct nvmlEventData_st
        {
            /// <summary>
            /// Specific device where the event occurred
            /// </summary>
            public nvmlDevice_st device;
            
            /// <summary>
            /// Information about what specific event occurred
            /// </summary>
            public ulong eventType;
            
            /// <summary>
            /// Stores last XID error for the device in the event of nvmlEventTypeXidCriticalError,
            /// </summary>
            public ulong eventData;
        }
        
        /// <summary>
        /// Describes accounting statistics of a process.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public unsafe partial struct nvmlAccountingStats_st
        {
            /// <summary>
            /// Percent of time over the process's lifetime during which one or more kernels was executing on the GPU.
            /// </summary>
            public uint gpuUtilization;
            
            /// <summary>
            /// Percent of time over the process's lifetime during which global (device) memory was being read or written.
            /// </summary>
            public uint memoryUtilization;
            
            /// <summary>
            /// Maximum total memory in bytes that was ever allocated by the process.
            /// </summary>
            public ulong maxMemoryUsage;
            
            /// <summary>
            /// Amount of time in ms during which the compute context was active. The time is reported as 0 if 
            /// the process is not terminated
            /// </summary>
            public ulong time;
            
            /// <summary>
            /// CPU Timestamp in usec representing start time for the process
            /// </summary>
            public ulong startTime;
            
            /// <summary>
            /// Flag to represent if the process is running (1 for running, 0 for terminated)
            /// </summary>
            public uint isRunning;
            
            /// <summary>
            /// Reserved for future use
            /// </summary>
            public fixed uint reserved[5];
        }
        
        /// <summary>
        /// Structure to store Utilization Value and vgpuInstance
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct nvmlVgpuInstanceUtilizationSample_st
        {
            /// <summary>
            /// vGPU Instance
            /// </summary>
            public uint vgpuInstance;
            
            /// <summary>
            /// CPU Timestamp in microseconds
            /// </summary>
            public ulong timeStamp;
            
            /// <summary>
            /// SM (3D/Compute) Util Value
            /// </summary>
            public nvmlValue_st smUtil;
            
            /// <summary>
            /// Frame Buffer Memory Util Value
            /// </summary>
            public nvmlValue_st memUtil;
            
            /// <summary>
            /// Encoder Util Value
            /// </summary>
            public nvmlValue_st encUtil;
            
            /// <summary>
            /// Decoder Util Value
            /// </summary>
            public nvmlValue_st decUtil;
        }
        
        /// <summary>
        /// Structure to store Utilization Value, vgpuInstance and subprocess information
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct nvmlVgpuProcessUtilizationSample_st
        {
            /// <summary>
            /// vGPU Instance
            /// </summary>
            public uint vgpuInstance;
            
            /// <summary>
            /// PID of process running within the vGPU VM
            /// </summary>
            public uint pid;
            
            /// <summary>
            /// Name of process running within the vGPU VM
            /// </summary>
            [MarshalAs(UnmanagedType.LPArray, SizeConst = 64)]
            public unsupported_type /* char */[] processName;
            
            /// <summary>
            /// CPU Timestamp in microseconds
            /// </summary>
            public ulong timeStamp;
            
            /// <summary>
            /// SM (3D/Compute) Util Value
            /// </summary>
            public uint smUtil;
            
            /// <summary>
            /// Frame Buffer Memory Util Value
            /// </summary>
            public uint memUtil;
            
            /// <summary>
            /// Encoder Util Value
            /// </summary>
            public uint encUtil;
            
            /// <summary>
            /// Decoder Util Value
            /// </summary>
            public uint decUtil;
        }
        
        /// <summary>
        /// Structure to store utilization value and process Id
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct nvmlProcessUtilizationSample_st
        {
            /// <summary>
            /// PID of process
            /// </summary>
            public uint pid;
            
            /// <summary>
            /// CPU Timestamp in microseconds
            /// </summary>
            public ulong timeStamp;
            
            /// <summary>
            /// SM (3D/Compute) Util Value
            /// </summary>
            public uint smUtil;
            
            /// <summary>
            /// Frame Buffer Memory Util Value
            /// </summary>
            public uint memUtil;
            
            /// <summary>
            /// Encoder Util Value
            /// </summary>
            public uint encUtil;
            
            /// <summary>
            /// Decoder Util Value
            /// </summary>
            public uint decUtil;
        }
        
        /// <summary>
        /// Structure containing GRID licensable feature information
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct nvmlGridLicensableFeature_st
        {
            /// <summary>
            /// Licensed feature code
            /// </summary>
            public nvmlGridLicenseFeatureCode_t featureCode;
            
            /// <summary>
            /// Non-zero if feature is currently licensed, otherwise zero
            /// </summary>
            public uint featureState;
            
            [MarshalAs(UnmanagedType.LPArray, SizeConst = 128)]
            public unsupported_type /* char */[] licenseInfo;
            
            [MarshalAs(UnmanagedType.LPArray, SizeConst = 128)]
            public unsupported_type /* char */[] productName;
        }
        
        /// <summary>
        /// Structure to store GRID licensable features
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct nvmlGridLicensableFeatures_st
        {
            /// <summary>
            /// Non-zero if GRID Software Licensing is supported on the system, otherwise zero
            /// </summary>
            public int isGridLicenseSupported;
            
            /// <summary>
            /// Entries returned in @a gridLicensableFeatures array
            /// </summary>
            public uint licensableFeaturesCount;
            
            /// <summary>
            /// Array of GRID licensable features.
            /// </summary>
            [MarshalAs(UnmanagedType.LPArray, SizeConst = 3)]
            public nvmlGridLicensableFeature_st[] gridLicensableFeatures;
        }
        
        /// <summary>
        /// Structure to hold encoder session data
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct nvmlEncoderSessionInfo_st
        {
            /// <summary>
            /// Unique session ID
            /// </summary>
            public uint sessionId;
            
            /// <summary>
            /// Owning process ID
            /// </summary>
            public uint pid;
            
            /// <summary>
            /// Owning vGPU instance ID (only valid on vGPU hosts, otherwise zero)
            /// </summary>
            public uint vgpuInstance;
            
            /// <summary>
            /// Video encoder type
            /// </summary>
            public nvmlEncoderQueryType_enum codecType;
            
            /// <summary>
            /// Current encode horizontal resolution
            /// </summary>
            public uint hResolution;
            
            /// <summary>
            /// Current encode vertical resolution
            /// </summary>
            public uint vResolution;
            
            /// <summary>
            /// Moving average encode frames per second
            /// </summary>
            public uint averageFps;
            
            /// <summary>
            /// Moving average encode latency in microseconds
            /// </summary>
            public uint averageLatency;
        }
        
        /// <summary>
        /// Structure to hold frame buffer capture sessions stats
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct nvmlFBCStats_st
        {
            /// <summary>
            /// Total no of sessions
            /// </summary>
            public uint sessionsCount;
            
            /// <summary>
            /// Moving average new frames captured per second
            /// </summary>
            public uint averageFPS;
            
            /// <summary>
            /// Moving average new frame capture latency in microseconds
            /// </summary>
            public uint averageLatency;
        }
        
        /// <summary>
        /// Structure to hold FBC session data
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct nvmlFBCSessionInfo_st
        {
            /// <summary>
            /// Unique session ID
            /// </summary>
            public uint sessionId;
            
            /// <summary>
            /// Owning process ID
            /// </summary>
            public uint pid;
            
            /// <summary>
            /// Owning vGPU instance ID (only valid on vGPU hosts, otherwise zero)
            /// </summary>
            public uint vgpuInstance;
            
            /// <summary>
            /// Display identifier
            /// </summary>
            public uint displayOrdinal;
            
            /// <summary>
            /// Type of frame buffer capture session
            /// </summary>
            public nvmlFBCSessionType_enum sessionType;
            
            /// <summary>
            /// Session flags (one or more of NVML_NVFBC_SESSION_FLAG_XXX).
            /// </summary>
            public uint sessionFlags;
            
            /// <summary>
            /// Max horizontal resolution supported by the capture session
            /// </summary>
            public uint hMaxResolution;
            
            /// <summary>
            /// Max vertical resolution supported by the capture session
            /// </summary>
            public uint vMaxResolution;
            
            /// <summary>
            /// Horizontal resolution requested by caller in capture call
            /// </summary>
            public uint hResolution;
            
            /// <summary>
            /// Vertical resolution requested by caller in capture call
            /// </summary>
            public uint vResolution;
            
            /// <summary>
            /// Moving average new frames captured per second
            /// </summary>
            public uint averageFPS;
            
            /// <summary>
            /// Moving average new frame capture latency in microseconds
            /// </summary>
            public uint averageLatency;
        }
        
        /// <summary>
        /// Structure representing range of vGPU versions.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct nvmlVgpuVersion_st
        {
            /// <summary>
            /// Minimum vGPU version.
            /// </summary>
            public uint minVersion;
            
            /// <summary>
            /// Maximum vGPU version.
            /// </summary>
            public uint maxVersion;
        }
        
        /// <summary>
        /// vGPU metadata structure.
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public unsafe partial struct nvmlVgpuMetadata_st
        {
            /// <summary>
            /// Current version of the structure
            /// </summary>
            public uint version;
            
            /// <summary>
            /// Current revision of the structure
            /// </summary>
            public uint revision;
            
            /// <summary>
            /// Current state of Guest-dependent fields
            /// </summary>
            public nvmlVgpuGuestInfoState_enum guestInfoState;
            
            /// <summary>
            /// Version of driver installed in guest
            /// </summary>
            [MarshalAs(UnmanagedType.LPArray, SizeConst = 80)]
            public unsupported_type /* char */[] guestDriverVersion;
            
            /// <summary>
            /// Version of driver installed in host
            /// </summary>
            [MarshalAs(UnmanagedType.LPArray, SizeConst = 80)]
            public unsupported_type /* char */[] hostDriverVersion;
            
            /// <summary>
            /// Reserved for internal use
            /// </summary>
            public fixed uint reserved[7];
            
            /// <summary>
            /// vGPU version of guest driver
            /// </summary>
            public uint guestVgpuVersion;
            
            /// <summary>
            /// Size of opaque data field in bytes
            /// </summary>
            public uint opaqueDataSize;
            
            /// <summary>
            /// Opaque data
            /// </summary>
            [MarshalAs(UnmanagedType.LPArray, SizeConst = 4)]
            public unsupported_type /* char */[] opaqueData;
        }
        
        /// <summary>
        /// Physical GPU metadata structure
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public unsafe partial struct nvmlVgpuPgpuMetadata_st
        {
            /// <summary>
            /// Current version of the structure
            /// </summary>
            public uint version;
            
            /// <summary>
            /// Current revision of the structure
            /// </summary>
            public uint revision;
            
            /// <summary>
            /// Host driver version
            /// </summary>
            [MarshalAs(UnmanagedType.LPArray, SizeConst = 80)]
            public unsupported_type /* char */[] hostDriverVersion;
            
            /// <summary>
            /// Pgpu virtualizaion capabilities bitfileld
            /// </summary>
            public uint pgpuVirtualizationCaps;
            
            /// <summary>
            /// Reserved for internal use
            /// </summary>
            public fixed uint reserved[5];
            
            /// <summary>
            /// vGPU version range supported by host driver
            /// </summary>
            public nvmlVgpuVersion_st hostSupportedVgpuRange;
            
            /// <summary>
            /// Size of opaque data field in bytes
            /// </summary>
            public uint opaqueDataSize;
            
            /// <summary>
            /// Opaque data
            /// </summary>
            [MarshalAs(UnmanagedType.LPArray, SizeConst = 4)]
            public unsupported_type /* char */[] opaqueData;
        }
        
        /// <summary>
        /// vGPU-pGPU compatibility structure
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct nvmlVgpuPgpuCompatibility_st
        {
            /// <summary>
            /// Compatibility of vGPU VM. See
            /// </summary>
            /// <remarks>
            ///  nvmlVgpuVmCompatibility_t
            /// </remarks>
            public nvmlVgpuVmCompatibility_enum vgpuVmCompatibility;
            
            /// <summary>
            /// Limiting factor for vGPU-pGPU compatibility. See
            /// </summary>
            /// <remarks>
            ///  nvmlVgpuPgpuCompatibilityLimitCode_t
            /// </remarks>
            public nvmlVgpuPgpuCompatibilityLimitCode_enum compatibilityLimitCode;
        }
        
        /// <summary>
        /// Blacklist GPU device information
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public partial struct nvmlBlacklistDeviceInfo_st
        {
            /// <summary>
            /// The PCI information for the blacklisted GPU
            /// </summary>
            public nvmlPciInfo_st pciInfo;
            
            /// <summary>
            /// The ASCII string UUID for the blacklisted GPU
            /// </summary>
            [MarshalAs(UnmanagedType.LPArray, SizeConst = 80)]
            public unsupported_type /* char */[] uuid;
        }
        
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlInit_v2();
        
        /// <summary>
        /// nvmlInitWithFlags is a variant of nvmlInit(), that allows passing a set of boolean values
        /// modifying the behaviour of nvmlInit().
        /// Other than the "flags" parameter it is completely similar to
        /// </summary>
        /// <param name="flags">behaviour modifier flags</param>
        /// <returns>-</returns>
        /// <remarks>
        ///  nvmlInit.For all products. NVML_SUCCESS                   if NVML has been properly initialized- NVML_ERROR_DRIVER_NOT_LOADED   if NVIDIA driver is not running- NVML_ERROR_NO_PERMISSION       if NVML does not have permission to talk to the driver- NVML_ERROR_UNKNOWN             on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlInitWithFlags(uint flags);
        
        /// <summary>
        /// Shut down NVML by releasing all GPU resources previously allocated with
        /// </summary>
        /// <returns>-</returns>
        /// <remarks>
        ///  nvmlInit().For all products.This method should be called after NVML work is done, once for each call to nvmlInit()A reference count of the number of initializations is maintained.  Shutdown only occurs
        /// when the reference count reaches zero.  For backwards compatibility, no error is reported if
        /// nvmlShutdown() is called more times than nvmlInit(). NVML_SUCCESS                 if NVML has been properly shut down- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlShutdown();
        
        /// <summary>
        /// Helper method for converting NVML error codes into readable strings.
        /// </summary>
        /// <param name="result">NVML error code to convert</param>
        /// <returns>String representation of the error.</returns>
        /// <remarks>
        /// For all products.
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern IntPtr nvmlErrorString(nvmlReturn_enum result);
        
        /// <summary>
        /// Retrieves the version of the system's graphics driver.
        /// </summary>
        /// <param name="version">Reference in which to return the version identifier</param>
        /// <param name="length">The maximum allowed length of the string returned in @a version</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For all products.The version identifier is an alphanumeric string.  It will not exceed 80 characters in length
        /// (including the NULL terminator).  See nvmlConstants::NVML_SYSTEM_DRIVER_VERSION_BUFFER_SIZE. NVML_SUCCESS                 if \a version has been set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a version is NULL- NVML_ERROR_INSUFFICIENT_SIZE if \a length is too small
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlSystemGetDriverVersion(IntPtr version, uint length);
        
        /// <summary>
        /// Retrieves the version of the NVML library.
        /// </summary>
        /// <param name="version">Reference in which to return the version identifier</param>
        /// <param name="length">The maximum allowed length of the string returned in @a version</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For all products.The version identifier is an alphanumeric string.  It will not exceed 80 characters in length
        /// (including the NULL terminator).  See nvmlConstants::NVML_SYSTEM_NVML_VERSION_BUFFER_SIZE. NVML_SUCCESS                 if \a version has been set- NVML_ERROR_INVALID_ARGUMENT  if \a version is NULL- NVML_ERROR_INSUFFICIENT_SIZE if \a length is too small
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlSystemGetNVMLVersion(IntPtr version, uint length);
        
        /// <summary>
        /// Retrieves the version of the CUDA driver.
        /// </summary>
        /// <param name="cudaDriverVersion">Reference in which to return the version identifier</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For all products.The CUDA driver version returned will be retreived from the currently installed version of CUDA.
        /// If the cuda library is not found, this function will return a known supported version number. NVML_SUCCESS                 if \a cudaDriverVersion has been set- NVML_ERROR_INVALID_ARGUMENT  if \a cudaDriverVersion is NULL
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlSystemGetCudaDriverVersion(ref int cudaDriverVersion);
        
        /// <summary>
        /// Retrieves the version of the CUDA driver from the shared library.
        /// </summary>
        /// <param name="cudaDriverVersion">Reference in which to return the version identifier</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For all products.The returned CUDA driver version by calling cuDriverGetVersion() NVML_SUCCESS                  if \a cudaDriverVersion has been set- NVML_ERROR_INVALID_ARGUMENT   if \a cudaDriverVersion is NULL- NVML_ERROR_LIBRARY_NOT_FOUND  if \a libcuda.so.1 or libcuda.dll is not found- NVML_ERROR_FUNCTION_NOT_FOUND if \a cuDriverGetVersion() is not found in the shared library
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlSystemGetCudaDriverVersion_v2(ref int cudaDriverVersion);
        
        /// <summary>
        /// Gets name of the process with provided process id
        /// </summary>
        /// <param name="pid">The identifier of the process</param>
        /// <param name="name">Reference in which to return the process name</param>
        /// <param name="length">The maximum allowed length of the string returned in @a name</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For all products.Returned process name is cropped to provided length.
        /// name string is encoded in ANSI. NVML_SUCCESS                 if \a name has been set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a name is NULL or \a length is 0.- NVML_ERROR_NOT_FOUND         if process doesn't exists- NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlSystemGetProcessName(uint pid, IntPtr name, uint length);
        
        /// <summary>
        /// Retrieves the number of units in the system.
        /// </summary>
        /// <param name="unitCount">Reference in which to return the number of units</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For S-class products. NVML_SUCCESS                 if \a unitCount has been set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a unitCount is NULL- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlUnitGetCount(ref uint unitCount);
        
        /// <summary>
        /// Acquire the handle for a particular unit, based on its index.
        /// </summary>
        /// <param name="index">The index of the target unit, &gt;= 0 and 
        /// &lt;
        /// @a unitCount</param>
        /// <param name="unit">Reference in which to return the unit handle</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For S-class products.Valid indices are derived from the @a unitCount returned by nvmlUnitGetCount().For example, if @a unitCount is 2 the valid indices are 0 and 1, corresponding to UNIT 0 and UNIT 1.The order in which NVML enumerates units has no guarantees of consistency between reboots. NVML_SUCCESS                 if \a unit has been set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a index is invalid or \a unit is NULL- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlUnitGetHandleByIndex(uint index, ref nvmlUnit_st unit);
        
        /// <summary>
        /// Retrieves the static information associated with a unit.
        /// </summary>
        /// <param name="unit">The identifier of the target unit</param>
        /// <param name="info">Reference in which to return the unit information</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For S-class products.See nvmlUnitInfo_t for details on available unit info. NVML_SUCCESS                 if \a info has been populated- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a unit is invalid or \a info is NULL
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlUnitGetUnitInfo(nvmlUnit_st unit, ref nvmlUnitInfo_st info);
        
        /// <summary>
        /// Retrieves the LED state associated with this unit.
        /// </summary>
        /// <param name="unit">The identifier of the target unit</param>
        /// <param name="state">Reference in which to return the current LED state</param>
        /// <returns>-</returns>
        /// <seealso cref="nvmlUnitSetLedState()"/>
        /// 
        /// <remarks>
        /// For S-class products.See nvmlLedState_t for details on allowed states. NVML_SUCCESS                 if \a state has been set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a unit is invalid or \a state is NULL- NVML_ERROR_NOT_SUPPORTED     if this is not an S-class product- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlUnitGetLedState(nvmlUnit_st unit, ref nvmlLedState_st state);
        
        /// <summary>
        /// Retrieves the PSU stats for the unit.
        /// </summary>
        /// <param name="unit">The identifier of the target unit</param>
        /// <param name="psu">Reference in which to return the PSU information</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For S-class products.See nvmlPSUInfo_t for details on available PSU info. NVML_SUCCESS                 if \a psu has been populated- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a unit is invalid or \a psu is NULL- NVML_ERROR_NOT_SUPPORTED     if this is not an S-class product- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlUnitGetPsuInfo(nvmlUnit_st unit, ref nvmlPSUInfo_st psu);
        
        /// <summary>
        /// Retrieves the temperature readings for the unit, in degrees C.
        /// </summary>
        /// <param name="unit">The identifier of the target unit</param>
        /// <param name="type">The type of reading to take</param>
        /// <param name="temp">Reference in which to return the intake temperature</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For S-class products.Depending on the product, readings may be available for intake (type=0), 
        /// exhaust (type=1) and board (type=2). NVML_SUCCESS                 if \a temp has been populated- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a unit or \a type is invalid or \a temp is NULL- NVML_ERROR_NOT_SUPPORTED     if this is not an S-class product- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlUnitGetTemperature(nvmlUnit_st unit, uint type, ref uint temp);
        
        /// <summary>
        /// Retrieves the fan speed readings for the unit.
        /// </summary>
        /// <param name="unit">The identifier of the target unit</param>
        /// <param name="fanSpeeds">Reference in which to return the fan speed information</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For S-class products.See nvmlUnitFanSpeeds_t for details on available fan speed info. NVML_SUCCESS                 if \a fanSpeeds has been populated- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a unit is invalid or \a fanSpeeds is NULL- NVML_ERROR_NOT_SUPPORTED     if this is not an S-class product- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlUnitGetFanSpeedInfo(nvmlUnit_st unit, ref nvmlUnitFanSpeeds_st fanSpeeds);
        
        /// <summary>
        /// Retrieves the set of GPU devices that are attached to the specified unit.
        /// </summary>
        /// <param name="unit">The identifier of the target unit</param>
        /// <param name="deviceCount">Reference in which to provide the @a devices array size, and
        /// to return the number of attached GPU devices</param>
        /// <param name="devices">Reference in which to return the references to the attached GPU devices</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For S-class products.The @a deviceCount argument is expected to be set to the size of the input @a devices array. NVML_SUCCESS                 if \a deviceCount and \a devices have been populated- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INSUFFICIENT_SIZE if \a deviceCount indicates that the \a devices array is too small- NVML_ERROR_INVALID_ARGUMENT  if \a unit is invalid, either of \a deviceCount or \a devices is NULL- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlUnitGetDevices(nvmlUnit_st unit, ref uint deviceCount, ref nvmlDevice_st devices);
        
        /// <summary>
        /// Retrieves the IDs and firmware versions for any Host Interface Cards (HICs) in the system.
        /// </summary>
        /// <param name="hwbcCount">Size of hwbcEntries array</param>
        /// <param name="hwbcEntries">Array holding information about hwbc</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For S-class products.The @a hwbcCount argument is expected to be set to the size of the input @a hwbcEntries array.
        /// The HIC must be connected to an S-class system for it to be reported by this function. NVML_SUCCESS                 if \a hwbcCount and \a hwbcEntries have been populated- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if either \a hwbcCount or \a hwbcEntries is NULL- NVML_ERROR_INSUFFICIENT_SIZE if \a hwbcCount indicates that the \a hwbcEntries array is too small
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlSystemGetHicVersion(ref uint hwbcCount, ref nvmlHwbcEntry_st hwbcEntries);
        
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetCount_v2(ref uint deviceCount);
        
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetHandleByIndex_v2(uint index, ref nvmlDevice_st device);
        
        /// <summary>
        /// Acquire the handle for a particular device, based on its board serial number.
        /// </summary>
        /// <param name="serial">The board serial number of the target GPU</param>
        /// <param name="device">Reference in which to return the device handle</param>
        /// <returns>-</returns>
        /// <seealso cref="nvmlDeviceGetSerial"/>
        /// 
        /// <seealso cref="nvmlDeviceGetHandleByUUID"/>
        /// 
        /// <remarks>
        /// For Fermi 
        /// &amp;tm;
        /// or newer fully supported devices.This number corresponds to the value printed directly on the board, and to the value returned by nvmlDeviceGetSerial().@deprecated Since more than one GPU can exist on a single board this function is deprecated in favor 
        /// of nvmlDeviceGetHandleByUUID.For dual GPU boards this function will return NVML_ERROR_INVALID_ARGUMENT.Starting from NVML 5, this API causes NVML to initialize the target GPU
        /// NVML may initialize additional GPUs as it searches for the target GPU NVML_SUCCESS                  if \a device has been set- NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT   if \a serial is invalid, \a device is NULL or more than onedevice has the same serial (dual GPU boards)
        /// - NVML_ERROR_NOT_FOUND          if \a serial does not match a valid device on the system- NVML_ERROR_INSUFFICIENT_POWER if any attached devices have improperly attached external power cables- NVML_ERROR_IRQ_ISSUE          if NVIDIA kernel detected an interrupt issue with the attached GPUs- NVML_ERROR_GPU_IS_LOST        if any GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN            on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetHandleBySerial(IntPtr serial, ref nvmlDevice_st device);
        
        /// <summary>
        /// Acquire the handle for a particular device, based on its globally unique immutable UUID associated with each device.
        /// </summary>
        /// <param name="uuid">The UUID of the target GPU</param>
        /// <param name="device">Reference in which to return the device handle</param>
        /// <returns>-</returns>
        /// <seealso cref="nvmlDeviceGetUUID"/>
        /// 
        /// <remarks>
        /// For all products.Starting from NVML 5, this API causes NVML to initialize the target GPU
        /// NVML may initialize additional GPUs as it searches for the target GPU NVML_SUCCESS                  if \a device has been set- NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT   if \a uuid is invalid or \a device is null- NVML_ERROR_NOT_FOUND          if \a uuid does not match a valid device on the system- NVML_ERROR_INSUFFICIENT_POWER if any attached devices have improperly attached external power cables- NVML_ERROR_IRQ_ISSUE          if NVIDIA kernel detected an interrupt issue with the attached GPUs- NVML_ERROR_GPU_IS_LOST        if any GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN            on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetHandleByUUID(IntPtr uuid, ref nvmlDevice_st device);
        
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetHandleByPciBusId_v2(IntPtr pciBusId, ref nvmlDevice_st device);
        
        /// <summary>
        /// Retrieves the name of this device.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="name">Reference in which to return the product name</param>
        /// <param name="length">The maximum allowed length of the string returned in @a name</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For all products.The name is an alphanumeric string that denotes a particular product, e.g. Tesla 
        /// &amp;tm;
        /// C2070. It will not
        /// exceed 64 characters in length (including the NULL terminator).  See
        ///  * nvmlConstants::NVML_DEVICE_NAME_BUFFER_SIZE.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param name                                 Reference in which to return the product name
        ///  * @param length                               The maximum allowed length of the string returned in \a name
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a name has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, or \a name is NULL
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE if \a length is too small
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetName(nvmlDevice_t device, char *name, unsigned int length);
        /// 
        /// /**
        ///  * Retrieves the brand of this device.
        ///  *
        ///  * For all products.
        ///  *
        ///  * The type is a member of \ref nvmlBrandType_t defined above.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param type                                 Reference in which to return the product brand type
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if \a name has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, or \a type is NULL
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetBrand(nvmlDevice_t device, nvmlBrandType_t *type);
        /// 
        /// /**
        ///  * Retrieves the NVML index of this device.
        ///  *
        ///  * For all products.
        ///  * 
        ///  * Valid indices are derived from the \a accessibleDevices count returned by 
        ///  *   \ref nvmlDeviceGetCount(). For example, if \a accessibleDevices is 2 the valid indices  
        ///  *   are 0 and 1, corresponding to GPU 0 and GPU 1.
        ///  *
        ///  * The order in which NVML enumerates devices has no guarantees of consistency between reboots. For that reason it
        ///  *   is recommended that devices be looked up by their PCI ids or GPU UUID. See 
        ///  *   \ref nvmlDeviceGetHandleByPciBusId() and \ref nvmlDeviceGetHandleByUUID().
        ///  *
        ///  * Note: The NVML index may not correlate with other APIs, such as the CUDA device index.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param index                                Reference in which to return the NVML index of the device
        ///  *
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a index has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, or \a index is NULL
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  *
        ///  * @see nvmlDeviceGetHandleByIndex()
        ///  * @see nvmlDeviceGetCount()
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetIndex(nvmlDevice_t device, unsigned int *index);
        /// 
        /// /**
        ///  * Retrieves the globally unique board serial number associated with this device's board.
        ///  *
        ///  * For all products with an inforom.
        ///  *
        ///  * The serial number is an alphanumeric string that will not exceed 30 characters (including the NULL terminator).
        ///  * This number matches the serial number tag that is physically attached to the board.  See \ref
        ///  * nvmlConstants::NVML_DEVICE_SERIAL_BUFFER_SIZE.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param serial                               Reference in which to return the board/module serial number
        ///  * @param length                               The maximum allowed length of the string returned in \a serial
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a serial has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, or \a serial is NULL
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE if \a length is too small
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetSerial(nvmlDevice_t device, char *serial, unsigned int length);
        /// 
        /// /**
        ///  * Retrieves an array of unsigned ints (sized to cpuSetSize) of bitmasks with the ideal CPU affinity for the device
        ///  * For example, if processors 0, 1, 32, and 33 are ideal for the device and cpuSetSize == 2,
        ///  *     result[0] = 0x3, result[1] = 0x3
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  * Supported on Linux only.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param cpuSetSize                           The size of the cpuSet array that is safe to access
        ///  * @param cpuSet                               Array reference in which to return a bitmask of CPUs, 64 CPUs per 
        ///  *                                                 unsigned long on 64-bit machines, 32 on 32-bit machines
        ///  *
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a cpuAffinity has been filled
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, cpuSetSize == 0, or cpuSet is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetCpuAffinity(nvmlDevice_t device, unsigned int cpuSetSize, unsigned long *cpuSet);
        /// 
        /// /**
        ///  * Sets the ideal affinity for the calling thread and device using the guidelines 
        ///  * given in nvmlDeviceGetCpuAffinity().  Note, this is a change as of version 8.0.  
        ///  * Older versions set the affinity for a calling process and all children.
        ///  * Currently supports up to 64 processors.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  * Supported on Linux only.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  *
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if the calling process has been successfully bound
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceSetCpuAffinity(nvmlDevice_t device);
        /// 
        /// /**
        ///  * Clear all affinity bindings for the calling thread.  Note, this is a change as of version
        ///  * 8.0 as older versions cleared the affinity for a calling process and all children.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  * Supported on Linux only.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  *
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if the calling process has been successfully unbound
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceClearCpuAffinity(nvmlDevice_t device);
        /// 
        /// /**
        ///  * Retrieve the common ancestor for two devices
        ///  * For all products.
        ///  * Supported on Linux only.
        ///  *
        ///  * @param device1                              The identifier of the first device
        ///  * @param device2                              The identifier of the second device
        ///  * @param pathInfo                             A \ref nvmlGpuTopologyLevel_t that gives the path type
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if \a pathInfo has been set
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device1, or \a device2 is invalid, or \a pathInfo is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device or OS does not support this feature
        ///  *         - \ref NVML_ERROR_UNKNOWN           an error has occurred in underlying topology discovery
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetTopologyCommonAncestor(nvmlDevice_t device1, nvmlDevice_t device2, nvmlGpuTopologyLevel_t *pathInfo);
        /// 
        /// /**
        ///  * Retrieve the set of GPUs that are nearest to a given device at a specific interconnectivity level
        ///  * For all products.
        ///  * Supported on Linux only.
        ///  *
        ///  * @param device                               The identifier of the first device
        ///  * @param level                                The \ref nvmlGpuTopologyLevel_t level to search for other GPUs
        ///  * @param count                                When zero, is set to the number of matching GPUs such that \a deviceArray 
        ///  *                                             can be malloc'd.  When non-zero, \a deviceArray will be filled with \a count
        ///  *                                             number of device handles.
        ///  * @param deviceArray                          An array of device handles for GPUs found at \a level
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if \a deviceArray or \a count (if initially zero) has been set
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device, \a level, or \a count is invalid, or \a deviceArray is NULL with a non-zero \a count
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device or OS does not support this feature
        ///  *         - \ref NVML_ERROR_UNKNOWN           an error has occurred in underlying topology discovery
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetTopologyNearestGpus(nvmlDevice_t device, nvmlGpuTopologyLevel_t level, unsigned int *count, nvmlDevice_t *deviceArray);
        /// 
        /// /**
        ///  * Retrieve the set of GPUs that have a CPU affinity with the given CPU number
        ///  * For all products.
        ///  * Supported on Linux only.
        ///  *
        ///  * @param cpuNumber                            The CPU number
        ///  * @param count                                When zero, is set to the number of matching GPUs such that \a deviceArray 
        ///  *                                             can be malloc'd.  When non-zero, \a deviceArray will be filled with \a count
        ///  *                                             number of device handles.
        ///  * @param deviceArray                          An array of device handles for GPUs found with affinity to \a cpuNumber
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if \a deviceArray or \a count (if initially zero) has been set
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a cpuNumber, or \a count is invalid, or \a deviceArray is NULL with a non-zero \a count
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device or OS does not support this feature
        ///  *         - \ref NVML_ERROR_UNKNOWN           an error has occurred in underlying topology discovery
        ///  */
        /// nvmlReturn_t DECLDIR nvmlSystemGetTopologyGpuSet(unsigned int cpuNumber, unsigned int *count, nvmlDevice_t *deviceArray);
        /// 
        /// /**
        ///  * Retrieve the status for a given p2p capability index between a given pair of GPU 
        ///  * 
        ///  * @param device1                              The first device 
        ///  * @param device2                              The second device
        ///  * @param p2pIndex                             p2p Capability Index being looked for between \a device1 and \a device2
        ///  * @param p2pStatus                            Reference in which to return the status of the \a p2pIndex
        ///  *                                             between \a device1 and \a device2
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS         if \a p2pStatus has been populated
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT     if \a device1 or \a device2 or \a p2pIndex is invalid or \a p2pStatus is NULL
        ///  *         - \ref NVML_ERROR_UNKNOWN              on any unexpected error
        ///  */ 
        /// nvmlReturn_t DECLDIR nvmlDeviceGetP2PStatus(nvmlDevice_t device1, nvmlDevice_t device2, nvmlGpuP2PCapsIndex_t p2pIndex,nvmlGpuP2PStatus_t *p2pStatus);
        /// 
        /// /**
        ///  * Retrieves the globally unique immutable UUID associated with this device, as a 5 part hexadecimal string,
        ///  * that augments the immutable, board serial identifier.
        ///  *
        ///  * For all products.
        ///  *
        ///  * The UUID is a globally unique identifier. It is the only available identifier for pre-Fermi-architecture products.
        ///  * It does NOT correspond to any identifier printed on the board.  It will not exceed 80 characters in length
        ///  * (including the NULL terminator).  See \ref nvmlConstants::NVML_DEVICE_UUID_BUFFER_SIZE.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param uuid                                 Reference in which to return the GPU UUID
        ///  * @param length                               The maximum allowed length of the string returned in \a uuid
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a uuid has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, or \a uuid is NULL
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE if \a length is too small 
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetUUID(nvmlDevice_t device, char *uuid, unsigned int length);
        /// 
        /// /**
        ///  * Retrieves minor number for the device. The minor number for the device is such that the Nvidia device node file for 
        ///  * each GPU will have the form /dev/nvidia[minor number].
        ///  *
        ///  * For all products.
        ///  * Supported only for Linux
        ///  *
        ///  * @param device                                The identifier of the target device
        ///  * @param minorNumber                           Reference in which to return the minor number for the device
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if the minor number is successfully retrieved
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a minorNumber is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if this query is not supported by the device
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetMinorNumber(nvmlDevice_t device, unsigned int *minorNumber);
        /// 
        /// /**
        ///  * Retrieves the the device board part number which is programmed into the board's InfoROM
        ///  *
        ///  * For all products.
        ///  *
        ///  * @param device                                Identifier of the target device
        ///  * @param partNumber                            Reference to the buffer to return
        ///  * @param length                                Length of the buffer reference
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                  if \a partNumber has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED      if the needed VBIOS fields have not been filled
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT   if \a device is invalid or \a serial is NULL
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST        if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN            on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetBoardPartNumber(nvmlDevice_t device, char* partNumber, unsigned int length);
        /// 
        /// /**
        ///  * Retrieves the version information for the device's infoROM object.
        ///  *
        ///  * For all products with an inforom.
        ///  *
        ///  * Fermi and higher parts have non-volatile on-board memory for persisting device info, such as aggregate 
        ///  * ECC counts. The version of the data structures in this memory may change from time to time. It will not
        ///  * exceed 16 characters in length (including the NULL terminator).
        ///  * See \ref nvmlConstants::NVML_DEVICE_INFOROM_VERSION_BUFFER_SIZE.
        ///  *
        ///  * See \ref nvmlInforomObject_t for details on the available infoROM objects.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param object                               The target infoROM object
        ///  * @param version                              Reference in which to return the infoROM version
        ///  * @param length                               The maximum allowed length of the string returned in \a version
        ///  *
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a version has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a version is NULL
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE if \a length is too small 
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not have an infoROM
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  *
        ///  * @see nvmlDeviceGetInforomImageVersion
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetInforomVersion(nvmlDevice_t device, nvmlInforomObject_t object, char *version, unsigned int length);
        /// 
        /// /**
        ///  * Retrieves the global infoROM image version
        ///  *
        ///  * For all products with an inforom.
        ///  *
        ///  * Image version just like VBIOS version uniquely describes the exact version of the infoROM flashed on the board 
        ///  * in contrast to infoROM object version which is only an indicator of supported features.
        ///  * Version string will not exceed 16 characters in length (including the NULL terminator).
        ///  * See \ref nvmlConstants::NVML_DEVICE_INFOROM_VERSION_BUFFER_SIZE.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param version                              Reference in which to return the infoROM image version
        ///  * @param length                               The maximum allowed length of the string returned in \a version
        ///  *
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a version has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a version is NULL
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE if \a length is too small 
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not have an infoROM
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  *
        ///  * @see nvmlDeviceGetInforomVersion
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetInforomImageVersion(nvmlDevice_t device, char *version, unsigned int length);
        /// 
        /// /**
        ///  * Retrieves the checksum of the configuration stored in the device's infoROM.
        ///  *
        ///  * For all products with an inforom.
        ///  *
        ///  * Can be used to make sure that two GPUs have the exact same configuration.
        ///  * Current checksum takes into account configuration stored in PWR and ECC infoROM objects.
        ///  * Checksum can change between driver releases or when user changes configuration (e.g. disable/enable ECC)
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param checksum                             Reference in which to return the infoROM configuration checksum
        ///  *
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a checksum has been set
        ///  *         - \ref NVML_ERROR_CORRUPTED_INFOROM if the device's checksum couldn't be retrieved due to infoROM corruption
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a checksum is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error 
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetInforomConfigurationChecksum(nvmlDevice_t device, unsigned int *checksum);
        /// 
        /// /**
        ///  * Reads the infoROM from the flash and verifies the checksums.
        ///  *
        ///  * For all products with an inforom.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  *
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if infoROM is not corrupted
        ///  *         - \ref NVML_ERROR_CORRUPTED_INFOROM if the device's infoROM is corrupted
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error 
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceValidateInforom(nvmlDevice_t device);
        /// 
        /// /**
        ///  * Retrieves the display mode for the device.
        ///  *
        ///  * For all products.
        ///  *
        ///  * This method indicates whether a physical display (e.g. monitor) is currently connected to
        ///  * any of the device's connectors.
        ///  *
        ///  * See \ref nvmlEnableState_t for details on allowed modes.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param display                              Reference in which to return the display mode
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a display has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a display is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetDisplayMode(nvmlDevice_t device, nvmlEnableState_t *display);
        /// 
        /// /**
        ///  * Retrieves the display active state for the device.
        ///  *
        ///  * For all products.
        ///  *
        ///  * This method indicates whether a display is initialized on the device.
        ///  * For example whether X Server is attached to this device and has allocated memory for the screen.
        ///  *
        ///  * Display can be active even when no monitor is physically attached.
        ///  *
        ///  * See \ref nvmlEnableState_t for details on allowed modes.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param isActive                             Reference in which to return the display active state
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a isActive has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a isActive is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetDisplayActive(nvmlDevice_t device, nvmlEnableState_t *isActive);
        /// 
        /// /**
        ///  * Retrieves the persistence mode associated with this device.
        ///  *
        ///  * For all products.
        ///  * For Linux only.
        ///  *
        ///  * When driver persistence mode is enabled the driver software state is not torn down when the last 
        ///  * client disconnects. By default this feature is disabled. 
        ///  *
        ///  * See \ref nvmlEnableState_t for details on allowed modes.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param mode                                 Reference in which to return the current driver persistence mode
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a mode has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a mode is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  *
        ///  * @see nvmlDeviceSetPersistenceMode()
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetPersistenceMode(nvmlDevice_t device, nvmlEnableState_t *mode);
        /// 
        /// /**
        ///  * Retrieves the PCI attributes of this device.
        ///  * 
        ///  * For all products.
        ///  *
        ///  * See \ref nvmlPciInfo_t for details on the available PCI info.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param pci                                  Reference in which to return the PCI info
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a pci has been populated
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a pci is NULL
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetPciInfo(nvmlDevice_t device, nvmlPciInfo_t *pci);
        /// 
        /// /**
        ///  * Retrieves the maximum PCIe link generation possible with this device and system
        ///  *
        ///  * I.E. for a generation 2 PCIe device attached to a generation 1 PCIe bus the max link generation this function will
        ///  * report is generation 1.
        ///  * 
        ///  * For Fermi &amp;tm; or newer fully supported devices.
        ///  * 
        ///  * @param device                               The identifier of the target device
        ///  * @param maxLinkGen                           Reference in which to return the max PCIe link generation
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a maxLinkGen has been populated
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a maxLinkGen is null
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if PCIe link information is not available
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetMaxPcieLinkGeneration(nvmlDevice_t device, unsigned int *maxLinkGen);
        /// 
        /// /**
        ///  * Retrieves the maximum PCIe link width possible with this device and system
        ///  *
        ///  * I.E. for a device with a 16x PCIe bus width attached to a 8x PCIe system bus this function will report
        ///  * a max link width of 8.
        ///  * 
        ///  * For Fermi &amp;tm; or newer fully supported devices.
        ///  * 
        ///  * @param device                               The identifier of the target device
        ///  * @param maxLinkWidth                         Reference in which to return the max PCIe link generation
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a maxLinkWidth has been populated
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a maxLinkWidth is null
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if PCIe link information is not available
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetMaxPcieLinkWidth(nvmlDevice_t device, unsigned int *maxLinkWidth);
        /// 
        /// /**
        ///  * Retrieves the current PCIe link generation
        ///  * 
        ///  * For Fermi &amp;tm; or newer fully supported devices.
        ///  * 
        ///  * @param device                               The identifier of the target device
        ///  * @param currLinkGen                          Reference in which to return the current PCIe link generation
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a currLinkGen has been populated
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a currLinkGen is null
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if PCIe link information is not available
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetCurrPcieLinkGeneration(nvmlDevice_t device, unsigned int *currLinkGen);
        /// 
        /// /**
        ///  * Retrieves the current PCIe link width
        ///  * 
        ///  * For Fermi &amp;tm; or newer fully supported devices.
        ///  * 
        ///  * @param device                               The identifier of the target device
        ///  * @param currLinkWidth                        Reference in which to return the current PCIe link generation
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a currLinkWidth has been populated
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a currLinkWidth is null
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if PCIe link information is not available
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetCurrPcieLinkWidth(nvmlDevice_t device, unsigned int *currLinkWidth);
        /// 
        /// /**
        ///  * Retrieve PCIe utilization information.
        ///  * This function is querying a byte counter over a 20ms interval and thus is the 
        ///  *   PCIe throughput over that interval.
        ///  *
        ///  * For Maxwell &amp;tm; or newer fully supported devices.
        ///  *
        ///  * This method is not supported in virtual machines running virtual GPU (vGPU).
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param counter                              The specific counter that should be queried \ref nvmlPcieUtilCounter_t
        ///  * @param value                                Reference in which to return throughput in KB/s
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if \a value has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device or \a counter is invalid, or \a value is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetPcieThroughput(nvmlDevice_t device, nvmlPcieUtilCounter_t counter, unsigned int *value);
        /// 
        /// /**  
        ///  * Retrieve the PCIe replay counter.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param value                                Reference in which to return the counter's value
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if \a value has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, or \a value is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetPcieReplayCounter(nvmlDevice_t device, unsigned int *value);
        /// 
        /// /**
        ///  * Retrieves the current clock speeds for the device.
        ///  *
        ///  * For Fermi &amp;tm; or newer fully supported devices.
        ///  *
        ///  * See \ref nvmlClockType_t for details on available clock information.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param type                                 Identify which clock domain to query
        ///  * @param clock                                Reference in which to return the clock speed in MHz
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a clock has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a clock is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device cannot report the specified clock
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetClockInfo(nvmlDevice_t device, nvmlClockType_t type, unsigned int *clock);
        /// 
        /// /**
        ///  * Retrieves the maximum clock speeds for the device.
        ///  *
        ///  * For Fermi &amp;tm; or newer fully supported devices.
        ///  *
        ///  * See \ref nvmlClockType_t for details on available clock information.
        ///  *
        ///  * \note On GPUs from Fermi family current P0 clocks (reported by \ref nvmlDeviceGetClockInfo) can differ from max clocks
        ///  *       by few MHz.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param type                                 Identify which clock domain to query
        ///  * @param clock                                Reference in which to return the clock speed in MHz
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a clock has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a clock is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device cannot report the specified clock
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetMaxClockInfo(nvmlDevice_t device, nvmlClockType_t type, unsigned int *clock);
        /// 
        /// /**
        ///  * Retrieves the current setting of a clock that applications will use unless an overspec situation occurs.
        ///  * Can be changed using \ref nvmlDeviceSetApplicationsClocks.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param clockType                            Identify which clock domain to query
        ///  * @param clockMHz                             Reference in which to return the clock in MHz
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a clockMHz has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a clockMHz is NULL or \a clockType is invalid
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetApplicationsClock(nvmlDevice_t device, nvmlClockType_t clockType, unsigned int *clockMHz);
        /// 
        /// /**
        ///  * Retrieves the default applications clock that GPU boots with or 
        ///  * defaults to after \ref nvmlDeviceResetApplicationsClocks call.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param clockType                            Identify which clock domain to query
        ///  * @param clockMHz                             Reference in which to return the default clock in MHz
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a clockMHz has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a clockMHz is NULL or \a clockType is invalid
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  *
        ///  * \see nvmlDeviceGetApplicationsClock
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetDefaultApplicationsClock(nvmlDevice_t device, nvmlClockType_t clockType, unsigned int *clockMHz);
        /// 
        /// /**
        ///  * Resets the application clock to the default value
        ///  *
        ///  * This is the applications clock that will be used after system reboot or driver reload.
        ///  * Default value is constant, but the current value an be changed using \ref nvmlDeviceSetApplicationsClocks.
        ///  *
        ///  * On Pascal and newer hardware, if clocks were previously locked with \ref nvmlDeviceSetApplicationsClocks,
        ///  * this call will unlock clocks. This returns clocks their default behavior ofautomatically boosting above
        ///  * base clocks as thermal limits allow.
        ///  *
        ///  * @see nvmlDeviceGetApplicationsClock
        ///  * @see nvmlDeviceSetApplicationsClocks
        ///  *
        ///  * For Fermi &amp;tm; or newer non-GeForce fully supported devices and Maxwell or newer GeForce devices.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if new settings were successfully set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceResetApplicationsClocks(nvmlDevice_t device);
        /// 
        /// /**
        ///  * Retrieves the clock speed for the clock specified by the clock type and clock ID.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param clockType                            Identify which clock domain to query
        ///  * @param clockId                              Identify which clock in the domain to query
        ///  * @param clockMHz                             Reference in which to return the clock in MHz
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if \a clockMHz has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a clockMHz is NULL or \a clockType is invalid
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetClock(nvmlDevice_t device, nvmlClockType_t clockType, nvmlClockId_t clockId, unsigned int *clockMHz);
        /// 
        /// /**
        ///  * Retrieves the customer defined maximum boost clock speed specified by the given clock type.
        ///  *
        ///  * For Pascal &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param clockType                            Identify which clock domain to query
        ///  * @param clockMHz                             Reference in which to return the clock in MHz
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if \a clockMHz has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a clockMHz is NULL or \a clockType is invalid
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device or the \a clockType on this device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetMaxCustomerBoostClock(nvmlDevice_t device, nvmlClockType_t clockType, unsigned int *clockMHz);
        /// 
        /// /**
        ///  * Retrieves the list of possible memory clocks that can be used as an argument for \ref nvmlDeviceSetApplicationsClocks.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param count                                Reference in which to provide the \a clocksMHz array size, and
        ///  *                                             to return the number of elements
        ///  * @param clocksMHz                            Reference in which to return the clock in MHz
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a count and \a clocksMHz have been populated 
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a count is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE if \a count is too small (\a count is set to the number of
        ///  *                                                required elements)
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  *
        ///  * @see nvmlDeviceSetApplicationsClocks
        ///  * @see nvmlDeviceGetSupportedGraphicsClocks
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetSupportedMemoryClocks(nvmlDevice_t device, unsigned int *count, unsigned int *clocksMHz);
        /// 
        /// /**
        ///  * Retrieves the list of possible graphics clocks that can be used as an argument for \ref nvmlDeviceSetApplicationsClocks.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param memoryClockMHz                       Memory clock for which to return possible graphics clocks
        ///  * @param count                                Reference in which to provide the \a clocksMHz array size, and
        ///  *                                             to return the number of elements
        ///  * @param clocksMHz                            Reference in which to return the clocks in MHz
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a count and \a clocksMHz have been populated 
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_NOT_FOUND         if the specified \a memoryClockMHz is not a supported frequency
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a clock is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE if \a count is too small 
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  *
        ///  * @see nvmlDeviceSetApplicationsClocks
        ///  * @see nvmlDeviceGetSupportedMemoryClocks
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetSupportedGraphicsClocks(nvmlDevice_t device, unsigned int memoryClockMHz, unsigned int *count, unsigned int *clocksMHz);
        /// 
        /// /**
        ///  * Retrieve the current state of Auto Boosted clocks on a device and store it in \a isEnabled
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * Auto Boosted clocks are enabled by default on some hardware, allowing the GPU to run at higher clock rates
        ///  * to maximize performance as thermal limits allow.
        ///  *
        ///  * On Pascal and newer hardware, Auto Aoosted clocks are controlled through application clocks.
        ///  * Use \ref nvmlDeviceSetApplicationsClocks and \ref nvmlDeviceResetApplicationsClocks to control Auto Boost
        ///  * behavior.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param isEnabled                            Where to store the current state of Auto Boosted clocks of the target device
        ///  * @param defaultIsEnabled                     Where to store the default Auto Boosted clocks behavior of the target device that the device will
        ///  *                                                 revert to when no applications are using the GPU
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 If \a isEnabled has been been set with the Auto Boosted clocks state of \a device
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a isEnabled is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support Auto Boosted clocks
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  *
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetAutoBoostedClocksEnabled(nvmlDevice_t device, nvmlEnableState_t *isEnabled, nvmlEnableState_t *defaultIsEnabled);
        /// 
        /// /**
        ///  * Try to set the current state of Auto Boosted clocks on a device.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * Auto Boosted clocks are enabled by default on some hardware, allowing the GPU to run at higher clock rates
        ///  * to maximize performance as thermal limits allow. Auto Boosted clocks should be disabled if fixed clock
        ///  * rates are desired.
        ///  *
        ///  * Non-root users may use this API by default but can be restricted by root from using this API by calling
        ///  * \ref nvmlDeviceSetAPIRestriction with apiType=NVML_RESTRICTED_API_SET_AUTO_BOOSTED_CLOCKS.
        ///  * Note: Persistence Mode is required to modify current Auto Boost settings, therefore, it must be enabled.
        ///  *
        ///  * On Pascal and newer hardware, Auto Boosted clocks are controlled through application clocks.
        ///  * Use \ref nvmlDeviceSetApplicationsClocks and \ref nvmlDeviceResetApplicationsClocks to control Auto Boost
        ///  * behavior.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param enabled                              What state to try to set Auto Boosted clocks of the target device to
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 If the Auto Boosted clocks were successfully set to the state specified by \a enabled
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support Auto Boosted clocks
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  *
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceSetAutoBoostedClocksEnabled(nvmlDevice_t device, nvmlEnableState_t enabled);
        /// 
        /// /**
        ///  * Try to set the default state of Auto Boosted clocks on a device. This is the default state that Auto Boosted clocks will
        ///  * return to when no compute running processes (e.g. CUDA application which have an active context) are running
        ///  *
        ///  * For Kepler &amp;tm; or newer non-GeForce fully supported devices and Maxwell or newer GeForce devices.
        ///  * Requires root/admin permissions.
        ///  *
        ///  * Auto Boosted clocks are enabled by default on some hardware, allowing the GPU to run at higher clock rates
        ///  * to maximize performance as thermal limits allow. Auto Boosted clocks should be disabled if fixed clock
        ///  * rates are desired.
        ///  *
        ///  * On Pascal and newer hardware, Auto Boosted clocks are controlled through application clocks.
        ///  * Use \ref nvmlDeviceSetApplicationsClocks and \ref nvmlDeviceResetApplicationsClocks to control Auto Boost
        ///  * behavior.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param enabled                              What state to try to set default Auto Boosted clocks of the target device to
        ///  * @param flags                                Flags that change the default behavior. Currently Unused.
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 If the Auto Boosted clock's default state was successfully set to the state specified by \a enabled
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_NO_PERMISSION     If the calling user does not have permission to change Auto Boosted clock's default state.
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support Auto Boosted clocks
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  *
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceSetDefaultAutoBoostedClocksEnabled(nvmlDevice_t device, nvmlEnableState_t enabled, unsigned int flags);
        /// 
        /// 
        /// /**
        ///  * Retrieves the intended operating speed of the device's fan.
        ///  *
        ///  * Note: The reported speed is the intended fan speed.  If the fan is physically blocked and unable to spin, the
        ///  * output will not match the actual fan speed.
        ///  * 
        ///  * For all discrete products with dedicated fans.
        ///  *
        ///  * The fan speed is expressed as a percent of the maximum, i.e. full speed is 100%.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param speed                                Reference in which to return the fan speed percentage
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a speed has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a speed is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not have a fan
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetFanSpeed(nvmlDevice_t device, unsigned int *speed);
        /// 
        /// 
        /// /**
        ///  * Retrieves the intended operating speed of the device's specified fan.
        ///  *
        ///  * Note: The reported speed is the intended fan speed. If the fan is physically blocked and unable to spin, the
        ///  * output will not match the actual fan speed.
        ///  *
        ///  * For all discrete products with dedicated fans.
        ///  *
        ///  * The fan speed is expressed as a percentage of the maximum, i.e. full speed is 100%
        ///  *
        ///  * @param device                                The identifier of the target device
        ///  * @param fan                                   The index of the target fan, zero indexed.
        ///  * @param speed                                 Reference in which to return the fan speed percentage
        ///  *
        ///  * @return
        ///  *        - \ref NVML_SUCCESS                   if \a speed has been set
        ///  *        - \ref NVML_ERROR_UNINITIALIZED       if the library has not been successfully initialized
        ///  *        - \ref NVML_ERROR_INVALID_ARGUMENT    if \a device is invalid, \a fan is not an acceptable index, or \a speed is NULL
        ///  *        - \ref NVML_ERROR_NOT_SUPPORTED       if the device does not have a fan or is newer than Maxwell
        ///  *        - \ref NVML_ERROR_GPU_IS_LOST         if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *        - \ref NVML_ERROR_UNKNOWN             on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetFanSpeed_v2(nvmlDevice_t device, unsigned int fan, unsigned int * speed);
        /// 
        /// 
        /// /**
        ///  * Retrieves the current temperature readings for the device, in degrees C. 
        ///  * 
        ///  * For all products.
        ///  *
        ///  * See \ref nvmlTemperatureSensors_t for details on available temperature sensors.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param sensorType                           Flag that indicates which sensor reading to retrieve
        ///  * @param temp                                 Reference in which to return the temperature reading
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a temp has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, \a sensorType is invalid or \a temp is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not have the specified sensor
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetTemperature(nvmlDevice_t device, nvmlTemperatureSensors_t sensorType, unsigned int *temp);
        /// 
        /// /**
        ///  * Retrieves the temperature threshold for the GPU with the specified threshold type in degrees C.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * See \ref nvmlTemperatureThresholds_t for details on available temperature thresholds.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param thresholdType                        The type of threshold value queried
        ///  * @param temp                                 Reference in which to return the temperature reading
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if \a temp has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, \a thresholdType is invalid or \a temp is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not have a temperature sensor or is unsupported
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetTemperatureThreshold(nvmlDevice_t device, nvmlTemperatureThresholds_t thresholdType, unsigned int *temp);
        /// 
        /// /**
        ///  * Retrieves the current performance state for the device. 
        ///  *
        ///  * For Fermi &amp;tm; or newer fully supported devices.
        ///  *
        ///  * See \ref nvmlPstates_t for details on allowed performance states.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param pState                               Reference in which to return the performance state reading
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a pState has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a pState is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetPerformanceState(nvmlDevice_t device, nvmlPstates_t *pState);
        /// 
        /// /**
        ///  * Retrieves current clocks throttling reasons.
        ///  *
        ///  * For all fully supported products.
        ///  *
        ///  * \note More than one bit can be enabled at the same time. Multiple reasons can be affecting clocks at once.
        ///  *
        ///  * @param device                                The identifier of the target device
        ///  * @param clocksThrottleReasons                 Reference in which to return bitmask of active clocks throttle
        ///  *                                                  reasons
        ///  *
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a clocksThrottleReasons has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a clocksThrottleReasons is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  *
        ///  * @see nvmlClocksThrottleReasons
        ///  * @see nvmlDeviceGetSupportedClocksThrottleReasons
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetCurrentClocksThrottleReasons(nvmlDevice_t device, unsigned long long *clocksThrottleReasons);
        /// 
        /// /**
        ///  * Retrieves bitmask of supported clocks throttle reasons that can be returned by 
        ///  * \ref nvmlDeviceGetCurrentClocksThrottleReasons
        ///  *
        ///  * For all fully supported products.
        ///  *
        ///  * This method is not supported in virtual machines running virtual GPU (vGPU).
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param supportedClocksThrottleReasons       Reference in which to return bitmask of supported
        ///  *                                              clocks throttle reasons
        ///  *
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a supportedClocksThrottleReasons has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a supportedClocksThrottleReasons is NULL
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  *
        ///  * @see nvmlClocksThrottleReasons
        ///  * @see nvmlDeviceGetCurrentClocksThrottleReasons
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetSupportedClocksThrottleReasons(nvmlDevice_t device, unsigned long long *supportedClocksThrottleReasons);
        /// 
        /// /**
        ///  * Deprecated: Use \ref nvmlDeviceGetPerformanceState. This function exposes an incorrect generalization.
        ///  *
        ///  * Retrieve the current performance state for the device. 
        ///  *
        ///  * For Fermi &amp;tm; or newer fully supported devices.
        ///  *
        ///  * See \ref nvmlPstates_t for details on allowed performance states.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param pState                               Reference in which to return the performance state reading
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a pState has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a pState is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetPowerState(nvmlDevice_t device, nvmlPstates_t *pState);
        /// 
        /// /**
        ///  * This API has been deprecated.
        ///  *
        ///  * Retrieves the power management mode associated with this device.
        ///  *
        ///  * For products from the Fermi family.
        ///  *     - Requires \a NVML_INFOROM_POWER version 3.0 or higher.
        ///  *
        ///  * For from the Kepler or newer families.
        ///  *     - Does not require \a NVML_INFOROM_POWER object.
        ///  *
        ///  * This flag indicates whether any power management algorithm is currently active on the device. An 
        ///  * enabled state does not necessarily mean the device is being actively throttled -- only that 
        ///  * that the driver will do so if the appropriate conditions are met.
        ///  *
        ///  * See \ref nvmlEnableState_t for details on allowed modes.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param mode                                 Reference in which to return the current power management mode
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a mode has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a mode is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetPowerManagementMode(nvmlDevice_t device, nvmlEnableState_t *mode);
        /// 
        /// /**
        ///  * Retrieves the power management limit associated with this device.
        ///  *
        ///  * For Fermi &amp;tm; or newer fully supported devices.
        ///  *
        ///  * The power limit defines the upper boundary for the card's power draw. If
        ///  * the card's total power draw reaches this limit the power management algorithm kicks in.
        ///  *
        ///  * This reading is only available if power management mode is supported. 
        ///  * See \ref nvmlDeviceGetPowerManagementMode.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param limit                                Reference in which to return the power management limit in milliwatts
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a limit has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a limit is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetPowerManagementLimit(nvmlDevice_t device, unsigned int *limit);
        /// 
        /// /**
        ///  * Retrieves information about possible values of power management limits on this device.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param minLimit                             Reference in which to return the minimum power management limit in milliwatts
        ///  * @param maxLimit                             Reference in which to return the maximum power management limit in milliwatts
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a minLimit and \a maxLimit have been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a minLimit or \a maxLimit is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  *
        ///  * @see nvmlDeviceSetPowerManagementLimit
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetPowerManagementLimitConstraints(nvmlDevice_t device, unsigned int *minLimit, unsigned int *maxLimit);
        /// 
        /// /**
        ///  * Retrieves default power management limit on this device, in milliwatts.
        ///  * Default power management limit is a power management limit that the device boots with.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param defaultLimit                         Reference in which to return the default power management limit in milliwatts
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a defaultLimit has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a defaultLimit is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetPowerManagementDefaultLimit(nvmlDevice_t device, unsigned int *defaultLimit);
        /// 
        /// /**
        ///  * Retrieves power usage for this GPU in milliwatts and its associated circuitry (e.g. memory)
        ///  *
        ///  * For Fermi &amp;tm; or newer fully supported devices.
        ///  *
        ///  * On Fermi and Kepler GPUs the reading is accurate to within +/- 5% of current power draw.
        ///  *
        ///  * It is only available if power management mode is supported. See \ref nvmlDeviceGetPowerManagementMode.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param power                                Reference in which to return the power usage information
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a power has been populated
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a power is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support power readings
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetPowerUsage(nvmlDevice_t device, unsigned int *power);
        /// 
        /// /**
        ///  * Retrieves total energy consumption for this GPU in millijoules (mJ) since the driver was last reloaded
        ///  *
        ///  * For newer than Pascal &amp;tm; fully supported devices.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param energy                               Reference in which to return the energy consumption information
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if \a energy has been populated
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a energy is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support energy readings
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetTotalEnergyConsumption(nvmlDevice_t device, unsigned long long *energy);
        /// 
        /// /**
        ///  * Get the effective power limit that the driver enforces after taking into account all limiters
        ///  *
        ///  * Note: This can be different from the \ref nvmlDeviceGetPowerManagementLimit if other limits are set elsewhere
        ///  * This includes the out of band power limit interface
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                           The device to communicate with
        ///  * @param limit                            Reference in which to return the power management limit in milliwatts
        ///  *
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a limit has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a limit is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetEnforcedPowerLimit(nvmlDevice_t device, unsigned int *limit);
        /// 
        /// /**
        ///  * Retrieves the current GOM and pending GOM (the one that GPU will switch to after reboot).
        ///  *
        ///  * For GK110 M-class and X-class Tesla &amp;tm; products from the Kepler family.
        ///  * Modes \ref NVML_GOM_LOW_DP and \ref NVML_GOM_ALL_ON are supported on fully supported GeForce products.
        ///  * Not supported on Quadro &amp;reg; and Tesla &amp;tm; C-class products.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param current                              Reference in which to return the current GOM
        ///  * @param pending                              Reference in which to return the pending GOM
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a mode has been populated
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a current or \a pending is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  *
        ///  * @see nvmlGpuOperationMode_t
        ///  * @see nvmlDeviceSetGpuOperationMode
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetGpuOperationMode(nvmlDevice_t device, nvmlGpuOperationMode_t *current, nvmlGpuOperationMode_t *pending);
        /// 
        /// /**
        ///  * Retrieves the amount of used, free and total memory available on the device, in bytes.
        ///  * 
        ///  * For all products.
        ///  *
        ///  * Enabling ECC reduces the amount of total available memory, due to the extra required parity bits.
        ///  * Under WDDM most device memory is allocated and managed on startup by Windows.
        ///  *
        ///  * Under Linux and Windows TCC, the reported amount of used memory is equal to the sum of memory allocated 
        ///  * by all active channels on the device.
        ///  *
        ///  * See \ref nvmlMemory_t for details on available memory info.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param memory                               Reference in which to return the memory information
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a memory has been populated
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a memory is NULL
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetMemoryInfo(nvmlDevice_t device, nvmlMemory_t *memory);
        /// 
        /// /**
        ///  * Retrieves the current compute mode for the device.
        ///  *
        ///  * For all products.
        ///  *
        ///  * See \ref nvmlComputeMode_t for details on allowed compute modes.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param mode                                 Reference in which to return the current compute mode
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a mode has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a mode is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  *
        ///  * @see nvmlDeviceSetComputeMode()
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetComputeMode(nvmlDevice_t device, nvmlComputeMode_t *mode);
        /// 
        /// /**
        ///  * Retrieves the CUDA compute capability of the device.
        ///  *
        ///  * For all products.
        ///  *
        ///  * Returns the major and minor compute capability version numbers of the
        ///  * device.  The major and minor versions are equivalent to the
        ///  * CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MINOR and
        ///  * CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MAJOR attributes that would be
        ///  * returned by CUDA's cuDeviceGetAttribute().
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param major                                Reference in which to return the major CUDA compute capability
        ///  * @param minor                                Reference in which to return the minor CUDA compute capability
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if \a major and \a minor have been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a major or \a minor are NULL
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetCudaComputeCapability(nvmlDevice_t device, int *major, int *minor);
        /// 
        /// /**
        ///  * Retrieves the current and pending ECC modes for the device.
        ///  *
        ///  * For Fermi &amp;tm; or newer fully supported devices.
        ///  * Only applicable to devices with ECC.
        ///  * Requires \a NVML_INFOROM_ECC version 1.0 or higher.
        ///  *
        ///  * Changing ECC modes requires a reboot. The "pending" ECC mode refers to the target mode following
        ///  * the next reboot.
        ///  *
        ///  * See \ref nvmlEnableState_t for details on allowed modes.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param current                              Reference in which to return the current ECC mode
        ///  * @param pending                              Reference in which to return the pending ECC mode
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a current and \a pending have been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or either \a current or \a pending is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  *
        ///  * @see nvmlDeviceSetEccMode()
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetEccMode(nvmlDevice_t device, nvmlEnableState_t *current, nvmlEnableState_t *pending);
        /// 
        /// /**
        ///  * Retrieves the device boardId from 0-N.
        ///  * Devices with the same boardId indicate GPUs connected to the same PLX.  Use in conjunction with 
        ///  *  \ref nvmlDeviceGetMultiGpuBoard() to decide if they are on the same board as well.
        ///  *  The boardId returned is a unique ID for the current configuration.  Uniqueness and ordering across 
        ///  *  reboots and system configurations is not guaranteed (i.e. if a Tesla K40c returns 0x100 and
        ///  *  the two GPUs on a Tesla K10 in the same system returns 0x200 it is not guaranteed they will 
        ///  *  always return those values but they will always be different from each other).
        ///  *  
        ///  *
        ///  * For Fermi &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param boardId                              Reference in which to return the device's board ID
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if \a boardId has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a boardId is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetBoardId(nvmlDevice_t device, unsigned int *boardId);
        /// 
        /// /**
        ///  * Retrieves whether the device is on a Multi-GPU Board
        ///  * Devices that are on multi-GPU boards will set \a multiGpuBool to a non-zero value.
        ///  *
        ///  * For Fermi &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param multiGpuBool                         Reference in which to return a zero or non-zero value
        ///  *                                                 to indicate whether the device is on a multi GPU board
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if \a multiGpuBool has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a multiGpuBool is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetMultiGpuBoard(nvmlDevice_t device, unsigned int *multiGpuBool);
        /// 
        /// /**
        ///  * Retrieves the total ECC error counts for the device.
        ///  *
        ///  * For Fermi &amp;tm; or newer fully supported devices.
        ///  * Only applicable to devices with ECC.
        ///  * Requires \a NVML_INFOROM_ECC version 1.0 or higher.
        ///  * Requires ECC Mode to be enabled.
        ///  *
        ///  * The total error count is the sum of errors across each of the separate memory systems, i.e. the total set of 
        ///  * errors across the entire device.
        ///  *
        ///  * See \ref nvmlMemoryErrorType_t for a description of available error types.\n
        ///  * See \ref nvmlEccCounterType_t for a description of available counter types.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param errorType                            Flag that specifies the type of the errors. 
        ///  * @param counterType                          Flag that specifies the counter-type of the errors. 
        ///  * @param eccCounts                            Reference in which to return the specified ECC errors
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a eccCounts has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device, \a errorType or \a counterType is invalid, or \a eccCounts is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  *
        ///  * @see nvmlDeviceClearEccErrorCounts()
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetTotalEccErrors(nvmlDevice_t device, nvmlMemoryErrorType_t errorType, nvmlEccCounterType_t counterType, unsigned long long *eccCounts);
        /// 
        /// /**
        ///  * Retrieves the detailed ECC error counts for the device.
        ///  *
        ///  * @deprecated   This API supports only a fixed set of ECC error locations
        ///  *               On different GPU architectures different locations are supported
        ///  *               See \ref nvmlDeviceGetMemoryErrorCounter
        ///  *
        ///  * For Fermi &amp;tm; or newer fully supported devices.
        ///  * Only applicable to devices with ECC.
        ///  * Requires \a NVML_INFOROM_ECC version 2.0 or higher to report aggregate location-based ECC counts.
        ///  * Requires \a NVML_INFOROM_ECC version 1.0 or higher to report all other ECC counts.
        ///  * Requires ECC Mode to be enabled.
        ///  *
        ///  * Detailed errors provide separate ECC counts for specific parts of the memory system.
        ///  *
        ///  * Reports zero for unsupported ECC error counters when a subset of ECC error counters are supported.
        ///  *
        ///  * See \ref nvmlMemoryErrorType_t for a description of available bit types.\n
        ///  * See \ref nvmlEccCounterType_t for a description of available counter types.\n
        ///  * See \ref nvmlEccErrorCounts_t for a description of provided detailed ECC counts.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param errorType                            Flag that specifies the type of the errors. 
        ///  * @param counterType                          Flag that specifies the counter-type of the errors. 
        ///  * @param eccCounts                            Reference in which to return the specified ECC errors
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a eccCounts has been populated
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device, \a errorType or \a counterType is invalid, or \a eccCounts is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  *
        ///  * @see nvmlDeviceClearEccErrorCounts()
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetDetailedEccErrors(nvmlDevice_t device, nvmlMemoryErrorType_t errorType, nvmlEccCounterType_t counterType, nvmlEccErrorCounts_t *eccCounts);
        /// 
        /// /**
        ///  * Retrieves the requested memory error counter for the device.
        ///  *
        ///  * For Fermi &amp;tm; or newer fully supported devices.
        ///  * Requires \a NVML_INFOROM_ECC version 2.0 or higher to report aggregate location-based memory error counts.
        ///  * Requires \a NVML_INFOROM_ECC version 1.0 or higher to report all other memory error counts.
        ///  *
        ///  * Only applicable to devices with ECC.
        ///  *
        ///  * Requires ECC Mode to be enabled.
        ///  *
        ///  * See \ref nvmlMemoryErrorType_t for a description of available memory error types.\n
        ///  * See \ref nvmlEccCounterType_t for a description of available counter types.\n
        ///  * See \ref nvmlMemoryLocation_t for a description of available counter locations.\n
        ///  * 
        ///  * @param device                               The identifier of the target device
        ///  * @param errorType                            Flag that specifies the type of error.
        ///  * @param counterType                          Flag that specifies the counter-type of the errors. 
        ///  * @param locationType                         Specifies the location of the counter. 
        ///  * @param count                                Reference in which to return the ECC counter
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a count has been populated
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device, \a bitTyp,e \a counterType or \a locationType is
        ///  *                                             invalid, or \a count is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support ECC error reporting in the specified memory
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetMemoryErrorCounter(nvmlDevice_t device, nvmlMemoryErrorType_t errorType,
        ///                                                    nvmlEccCounterType_t counterType,
        ///                                                    nvmlMemoryLocation_t locationType, unsigned long long *count);
        /// 
        /// /**
        ///  * Retrieves the current utilization rates for the device's major subsystems.
        ///  *
        ///  * For Fermi &amp;tm; or newer fully supported devices.
        ///  *
        ///  * See \ref nvmlUtilization_t for details on available utilization rates.
        ///  *
        ///  * \note During driver initialization when ECC is enabled one can see high GPU and Memory Utilization readings.
        ///  *       This is caused by ECC Memory Scrubbing mechanism that is performed during driver initialization.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param utilization                          Reference in which to return the utilization information
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a utilization has been populated
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a utilization is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetUtilizationRates(nvmlDevice_t device, nvmlUtilization_t *utilization);
        /// 
        /// /**
        ///  * Retrieves the current utilization and sampling size in microseconds for the Encoder
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param utilization                          Reference to an unsigned int for encoder utilization info
        ///  * @param samplingPeriodUs                     Reference to an unsigned int for the sampling period in US
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if \a utilization has been populated
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, \a utilization is NULL, or \a samplingPeriodUs is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetEncoderUtilization(nvmlDevice_t device, unsigned int *utilization, unsigned int *samplingPeriodUs);
        /// 
        /// /**
        ///  * Retrieves the current capacity of the device's encoder, as a percentage of maximum encoder capacity with valid values in the range 0-100.
        ///  *
        ///  * For Maxwell &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                            The identifier of the target device
        ///  * @param encoderQueryType                  Type of encoder to query
        ///  * @param encoderCapacity                   Reference to an unsigned int for the encoder capacity
        ///  * 
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                  if \a encoderCapacity is fetched
        ///  *         - \ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT   if \a encoderCapacity is NULL, or \a device or \a encoderQueryType
        ///  *                                              are invalid
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED      if device does not support the encoder specified in \a encodeQueryType
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST        if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN            on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetEncoderCapacity (nvmlDevice_t device, nvmlEncoderType_t encoderQueryType, unsigned int *encoderCapacity);
        /// 
        /// /**
        ///  * Retrieves the current encoder statistics for a given device.
        ///  *
        ///  * For Maxwell &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                            The identifier of the target device
        ///  * @param sessionCount                      Reference to an unsigned int for count of active encoder sessions
        ///  * @param averageFps                        Reference to an unsigned int for trailing average FPS of all active sessions
        ///  * @param averageLatency                    Reference to an unsigned int for encode latency in microseconds
        ///  * 
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                  if \a sessionCount, \a averageFps and \a averageLatency is fetched
        ///  *         - \ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT   if \a sessionCount, or \a device or \a averageFps,
        ///  *                                              or \a averageLatency is NULL
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST        if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN            on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetEncoderStats (nvmlDevice_t device, unsigned int *sessionCount,
        ///                                                 unsigned int *averageFps, unsigned int *averageLatency);
        /// 
        /// /**
        ///  * Retrieves information about active encoder sessions on a target device.
        ///  *
        ///  * An array of active encoder sessions is returned in the caller-supplied buffer pointed at by \a sessionInfos. The
        ///  * array elememt count is passed in \a sessionCount, and \a sessionCount is used to return the number of sessions
        ///  * written to the buffer.
        ///  *
        ///  * If the supplied buffer is not large enough to accomodate the active session array, the function returns
        ///  * NVML_ERROR_INSUFFICIENT_SIZE, with the element count of nvmlEncoderSessionInfo_t array required in \a sessionCount.
        ///  * To query the number of active encoder sessions, call this function with *sessionCount = 0.  The code will return
        ///  * NVML_SUCCESS with number of active encoder sessions updated in *sessionCount.
        ///  *
        ///  * For Maxwell &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                            The identifier of the target device
        ///  * @param sessionCount                      Reference to caller supplied array size, and returns the number of sessions.
        ///  * @param sessionInfos                      Reference in which to return the session information
        ///  * 
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                  if \a sessionInfos is fetched
        ///  *         - \ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE  if \a sessionCount is too small, array element count is returned in \a sessionCount
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT   if \a sessionCount is NULL.
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST        if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN            on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetEncoderSessions(nvmlDevice_t device, unsigned int *sessionCount, nvmlEncoderSessionInfo_t *sessionInfos);
        /// 
        /// /**
        ///  * Retrieves the current utilization and sampling size in microseconds for the Decoder
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param utilization                          Reference to an unsigned int for decoder utilization info
        ///  * @param samplingPeriodUs                     Reference to an unsigned int for the sampling period in US
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if \a utilization has been populated
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, \a utilization is NULL, or \a samplingPeriodUs is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetDecoderUtilization(nvmlDevice_t device, unsigned int *utilization, unsigned int *samplingPeriodUs);
        /// 
        /// /**
        /// * Retrieves the active frame buffer capture sessions statistics for a given device.
        /// *
        /// * For Maxwell &amp;tm; or newer fully supported devices.
        /// *
        /// * @param device                            The identifier of the target device
        /// * @param fbcStats                          Reference to nvmlFBCStats_t structure contianing NvFBC stats
        /// *
        /// * @return
        /// *         - \ref NVML_SUCCESS                  if \a fbcStats is fetched
        /// *         - \ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized
        /// *         - \ref NVML_ERROR_INVALID_ARGUMENT   if \a fbcStats is NULL
        /// *         - \ref NVML_ERROR_GPU_IS_LOST        if the target GPU has fallen off the bus or is otherwise inaccessible
        /// *         - \ref NVML_ERROR_UNKNOWN            on any unexpected error
        /// */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetFBCStats(nvmlDevice_t device, nvmlFBCStats_t *fbcStats);
        /// 
        /// /**
        /// * Retrieves information about active frame buffer capture sessions on a target device.
        /// *
        /// * An array of active FBC sessions is returned in the caller-supplied buffer pointed at by \a sessionInfo. The
        /// * array element count is passed in \a sessionCount, and \a sessionCount is used to return the number of sessions
        /// * written to the buffer.
        /// *
        /// * If the supplied buffer is not large enough to accomodate the active session array, the function returns
        /// * NVML_ERROR_INSUFFICIENT_SIZE, with the element count of nvmlFBCSessionInfo_t array required in \a sessionCount.
        /// * To query the number of active FBC sessions, call this function with *sessionCount = 0.  The code will return
        /// * NVML_SUCCESS with number of active FBC sessions updated in *sessionCount.
        /// *
        /// * For Maxwell &amp;tm; or newer fully supported devices.
        /// *
        /// * @note hResolution, vResolution, averageFPS and averageLatency data for a FBC session returned in \a sessionInfo may
        /// *       be zero if there are no new frames captured since the session started.
        /// *
        /// * @param device                            The identifier of the target device
        /// * @param sessionCount                      Reference to caller supplied array size, and returns the number of sessions.
        /// * @param sessionInfo                       Reference in which to return the session information
        /// *
        /// * @return
        /// *         - \ref NVML_SUCCESS                  if \a sessionInfo is fetched
        /// *         - \ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized
        /// *         - \ref NVML_ERROR_INSUFFICIENT_SIZE  if \a sessionCount is too small, array element count is returned in \a sessionCount
        /// *         - \ref NVML_ERROR_INVALID_ARGUMENT   if \a sessionCount is NULL.
        /// *         - \ref NVML_ERROR_GPU_IS_LOST        if the target GPU has fallen off the bus or is otherwise inaccessible
        /// *         - \ref NVML_ERROR_UNKNOWN            on any unexpected error
        /// */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetFBCSessions(nvmlDevice_t device, unsigned int *sessionCount, nvmlFBCSessionInfo_t *sessionInfo);
        /// 
        /// /**
        ///  * Retrieves the current and pending driver model for the device.
        ///  *
        ///  * For Fermi &amp;tm; or newer fully supported devices.
        ///  * For windows only.
        ///  *
        ///  * On Windows platforms the device driver can run in either WDDM or WDM (TCC) mode. If a display is attached
        ///  * to the device it must run in WDDM mode. TCC mode is preferred if a display is not attached.
        ///  *
        ///  * See \ref nvmlDriverModel_t for details on available driver models.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param current                              Reference in which to return the current driver model
        ///  * @param pending                              Reference in which to return the pending driver model
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if either \a current and/or \a pending have been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or both \a current and \a pending are NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the platform is not windows
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  * 
        ///  * @see nvmlDeviceSetDriverModel()
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetDriverModel(nvmlDevice_t device, nvmlDriverModel_t *current, nvmlDriverModel_t *pending);
        /// 
        /// /**
        ///  * Get VBIOS version of the device.
        ///  *
        ///  * For all products.
        ///  *
        ///  * The VBIOS version may change from time to time. It will not exceed 32 characters in length 
        ///  * (including the NULL terminator).  See \ref nvmlConstants::NVML_DEVICE_VBIOS_VERSION_BUFFER_SIZE.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param version                              Reference to which to return the VBIOS version
        ///  * @param length                               The maximum allowed length of the string returned in \a version
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a version has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, or \a version is NULL
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE if \a length is too small 
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetVbiosVersion(nvmlDevice_t device, char *version, unsigned int length);
        /// 
        /// /**
        ///  * Get Bridge Chip Information for all the bridge chips on the board.
        ///  * 
        ///  * For all fully supported products.
        ///  * Only applicable to multi-GPU products.
        ///  * 
        ///  * @param device                                The identifier of the target device
        ///  * @param bridgeHierarchy                       Reference to the returned bridge chip Hierarchy
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if bridge chip exists
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, or \a bridgeInfo is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if bridge chip not supported on the device
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  * 
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetBridgeChipInfo(nvmlDevice_t device, nvmlBridgeChipHierarchy_t *bridgeHierarchy);
        /// 
        /// /**
        ///  * Get information about processes with a compute context on a device
        ///  *
        ///  * For Fermi &amp;tm; or newer fully supported devices.
        ///  *
        ///  * This function returns information only about compute running processes (e.g. CUDA application which have
        ///  * active context). Any graphics applications (e.g. using OpenGL, DirectX) won't be listed by this function.
        ///  *
        ///  * To query the current number of running compute processes, call this function with *infoCount = 0. The
        ///  * return code will be NVML_ERROR_INSUFFICIENT_SIZE, or NVML_SUCCESS if none are running. For this call
        ///  * \a infos is allowed to be NULL.
        ///  *
        ///  * The usedGpuMemory field returned is all of the memory used by the application.
        ///  *
        ///  * Keep in mind that information returned by this call is dynamic and the number of elements might change in
        ///  * time. Allocate more space for \a infos table in case new compute processes are spawned.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param infoCount                            Reference in which to provide the \a infos array size, and
        ///  *                                             to return the number of returned elements
        ///  * @param infos                                Reference in which to return the process information
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a infoCount and \a infos have been populated
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE if \a infoCount indicates that the \a infos array is too small
        ///  *                                             \a infoCount will contain minimal amount of space necessary for
        ///  *                                             the call to complete
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, either of \a infoCount or \a infos is NULL
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  *
        ///  * @see \ref nvmlSystemGetProcessName
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetComputeRunningProcesses(nvmlDevice_t device, unsigned int *infoCount, nvmlProcessInfo_t *infos);
        /// 
        /// /**
        ///  * Get information about processes with a graphics context on a device
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * This function returns information only about graphics based processes 
        ///  * (eg. applications using OpenGL, DirectX)
        ///  *
        ///  * To query the current number of running graphics processes, call this function with *infoCount = 0. The
        ///  * return code will be NVML_ERROR_INSUFFICIENT_SIZE, or NVML_SUCCESS if none are running. For this call
        ///  * \a infos is allowed to be NULL.
        ///  *
        ///  * The usedGpuMemory field returned is all of the memory used by the application.
        ///  *
        ///  * Keep in mind that information returned by this call is dynamic and the number of elements might change in
        ///  * time. Allocate more space for \a infos table in case new graphics processes are spawned.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param infoCount                            Reference in which to provide the \a infos array size, and
        ///  *                                             to return the number of returned elements
        ///  * @param infos                                Reference in which to return the process information
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a infoCount and \a infos have been populated
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE if \a infoCount indicates that the \a infos array is too small
        ///  *                                             \a infoCount will contain minimal amount of space necessary for
        ///  *                                             the call to complete
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, either of \a infoCount or \a infos is NULL
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  *
        ///  * @see \ref nvmlSystemGetProcessName
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetGraphicsRunningProcesses(nvmlDevice_t device, unsigned int *infoCount, nvmlProcessInfo_t *infos);
        /// 
        /// /**
        ///  * Check if the GPU devices are on the same physical board.
        ///  *
        ///  * For all fully supported products.
        ///  *
        ///  * @param device1                               The first GPU device
        ///  * @param device2                               The second GPU device
        ///  * @param onSameBoard                           Reference in which to return the status.
        ///  *                                              Non-zero indicates that the GPUs are on the same board.
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if \a onSameBoard has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a dev1 or \a dev2 are invalid or \a onSameBoard is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if this check is not supported by the device
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the either GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceOnSameBoard(nvmlDevice_t device1, nvmlDevice_t device2, int *onSameBoard);
        /// 
        /// /**
        ///  * Retrieves the root/admin permissions on the target API. See \a nvmlRestrictedAPI_t for the list of supported APIs.
        ///  * If an API is restricted only root users can call that API. See \a nvmlDeviceSetAPIRestriction to change current permissions.
        ///  *
        ///  * For all fully supported products.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param apiType                              Target API type for this operation
        ///  * @param isRestricted                         Reference in which to return the current restriction 
        ///  *                                             NVML_FEATURE_ENABLED indicates that the API is root-only
        ///  *                                             NVML_FEATURE_DISABLED indicates that the API is accessible to all users
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if \a isRestricted has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, \a apiType incorrect or \a isRestricted is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if this query is not supported by the device or the device does not support
        ///  *                                                 the feature that is being queried (E.G. Enabling/disabling Auto Boosted clocks is
        ///  *                                                 not supported by the device)
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  *
        ///  * @see nvmlRestrictedAPI_t
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetAPIRestriction(nvmlDevice_t device, nvmlRestrictedAPI_t apiType, nvmlEnableState_t *isRestricted);
        /// 
        /// /**
        ///  * Gets recent samples for the GPU.
        ///  * 
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  * 
        ///  * Based on type, this method can be used to fetch the power, utilization or clock samples maintained in the buffer by 
        ///  * the driver.
        ///  * 
        ///  * Power, Utilization and Clock samples are returned as type "unsigned int" for the union nvmlValue_t.
        ///  * 
        ///  * To get the size of samples that user needs to allocate, the method is invoked with samples set to NULL. 
        ///  * The returned samplesCount will provide the number of samples that can be queried. The user needs to 
        ///  * allocate the buffer with size as samplesCount * sizeof(nvmlSample_t).
        ///  * 
        ///  * lastSeenTimeStamp represents CPU timestamp in microseconds. Set it to 0 to fetch all the samples maintained by the 
        ///  * underlying buffer. Set lastSeenTimeStamp to one of the timeStamps retrieved from the date of the previous query 
        ///  * to get more recent samples.
        ///  * 
        ///  * This method fetches the number of entries which can be accommodated in the provided samples array, and the 
        ///  * reference samplesCount is updated to indicate how many samples were actually retrieved. The advantage of using this 
        ///  * method for samples in contrast to polling via existing methods is to get get higher frequency data at lower polling cost.
        ///  * 
        ///  * @param device                        The identifier for the target device
        ///  * @param type                          Type of sampling event
        ///  * @param lastSeenTimeStamp             Return only samples with timestamp greater than lastSeenTimeStamp. 
        ///  * @param sampleValType                 Output parameter to represent the type of sample value as described in nvmlSampleVal_t
        ///  * @param sampleCount                   Reference to provide the number of elements which can be queried in samples array
        ///  * @param samples                       Reference in which samples are returned
        ///  
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if samples are successfully retrieved
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, \a samplesCount is NULL or 
        ///  *                                             reference to \a sampleCount is 0 for non null \a samples
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if this query is not supported by the device
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_NOT_FOUND         if sample entries are not found
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetSamples(nvmlDevice_t device, nvmlSamplingType_t type, unsigned long long lastSeenTimeStamp,
        ///         nvmlValueType_t *sampleValType, unsigned int *sampleCount, nvmlSample_t *samples);
        /// 
        /// /**
        ///  * Gets Total, Available and Used size of BAR1 memory.
        ///  * 
        ///  * BAR1 is used to map the FB (device memory) so that it can be directly accessed by the CPU or by 3rd party 
        ///  * devices (peer-to-peer on the PCIE bus). 
        ///  * 
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param bar1Memory                           Reference in which BAR1 memory
        ///  *                                             information is returned.
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if BAR1 memory is successfully retrieved
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, \a bar1Memory is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if this query is not supported by the device
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  *
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetBAR1MemoryInfo(nvmlDevice_t device, nvmlBAR1Memory_t *bar1Memory);
        /// 
        /// 
        /// /**
        ///  * Gets the duration of time during which the device was throttled (lower than requested clocks) due to power 
        ///  * or thermal constraints.
        ///  *
        ///  * The method is important to users who are tying to understand if their GPUs throttle at any point during their applications. The
        ///  * difference in violation times at two different reference times gives the indication of GPU throttling event. 
        ///  *
        ///  * Violation for thermal capping is not supported at this time.
        ///  * 
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param perfPolicyType                       Represents Performance policy which can trigger GPU throttling
        ///  * @param violTime                             Reference to which violation time related information is returned 
        ///  *                                         
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if violation time is successfully retrieved
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, \a perfPolicyType is invalid, or \a violTime is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if this query is not supported by the device
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetViolationStatus(nvmlDevice_t device, nvmlPerfPolicyType_t perfPolicyType, nvmlViolationTime_t *violTime);
        /// 
        /// /**
        ///  * @}
        ///  */
        /// 
        /// /** @addtogroup nvmlAccountingStats
        ///  *  @{
        ///  */
        /// 
        /// /**
        ///  * Queries the state of per process accounting mode.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * See \ref nvmlDeviceGetAccountingStats for more details.
        ///  * See \ref nvmlDeviceSetAccountingMode
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param mode                                 Reference in which to return the current accounting mode
        ///  *
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if the mode has been successfully retrieved 
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a mode are NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetAccountingMode(nvmlDevice_t device, nvmlEnableState_t *mode);
        /// 
        /// /**
        ///  * Queries process's accounting stats.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  * 
        ///  * Accounting stats capture GPU utilization and other statistics across the lifetime of a process.
        ///  * Accounting stats can be queried during life time of the process and after its termination.
        ///  * The time field in \ref nvmlAccountingStats_t is reported as 0 during the lifetime of the process and 
        ///  * updated to actual running time after its termination.
        ///  * Accounting stats are kept in a circular buffer, newly created processes overwrite information about old
        ///  * processes.
        ///  *
        ///  * See \ref nvmlAccountingStats_t for description of each returned metric.
        ///  * List of processes that can be queried can be retrieved from \ref nvmlDeviceGetAccountingPids.
        ///  *
        ///  * @note Accounting Mode needs to be on. See \ref nvmlDeviceGetAccountingMode.
        ///  * @note Only compute and graphics applications stats can be queried. Monitoring applications stats can't be
        ///  *         queried since they don't contribute to GPU utilization.
        ///  * @note In case of pid collision stats of only the latest process (that terminated last) will be reported
        ///  *
        ///  * @warning On Kepler devices per process statistics are accurate only if there's one process running on a GPU.
        ///  * 
        ///  * @param device                               The identifier of the target device
        ///  * @param pid                                  Process Id of the target process to query stats for
        ///  * @param stats                                Reference in which to return the process's accounting stats
        ///  *
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if stats have been successfully retrieved
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a stats are NULL
        ///  *         - \ref NVML_ERROR_NOT_FOUND         if process stats were not found
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature or accounting mode is disabled
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  *
        ///  * @see nvmlDeviceGetAccountingBufferSize
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetAccountingStats(nvmlDevice_t device, unsigned int pid, nvmlAccountingStats_t *stats);
        /// 
        /// /**
        ///  * Queries list of processes that can be queried for accounting stats. The list of processes returned 
        ///  * can be in running or terminated state.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * To just query the number of processes ready to be queried, call this function with *count = 0 and
        ///  * pids=NULL. The return code will be NVML_ERROR_INSUFFICIENT_SIZE, or NVML_SUCCESS if list is empty.
        ///  * 
        ///  * For more details see \ref nvmlDeviceGetAccountingStats.
        ///  *
        ///  * @note In case of PID collision some processes might not be accessible before the circular buffer is full.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param count                                Reference in which to provide the \a pids array size, and
        ///  *                                               to return the number of elements ready to be queried
        ///  * @param pids                                 Reference in which to return list of process ids
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if pids were successfully retrieved
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a count is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature or accounting mode is disabled
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE if \a count is too small (\a count is set to
        ///  *                                                 expected value)
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  *
        ///  * @see nvmlDeviceGetAccountingBufferSize
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetAccountingPids(nvmlDevice_t device, unsigned int *count, unsigned int *pids);
        /// 
        /// /**
        ///  * Returns the number of processes that the circular buffer with accounting pids can hold.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * This is the maximum number of processes that accounting information will be stored for before information
        ///  * about oldest processes will get overwritten by information about new processes.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param bufferSize                           Reference in which to provide the size (in number of elements)
        ///  *                                               of the circular buffer for accounting stats.
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if buffer size was successfully retrieved
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a bufferSize is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature or accounting mode is disabled
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  * 
        ///  * @see nvmlDeviceGetAccountingStats
        ///  * @see nvmlDeviceGetAccountingPids
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetAccountingBufferSize(nvmlDevice_t device, unsigned int *bufferSize);
        /// 
        /// /** @} */
        /// 
        /// /** @addtogroup nvmlDeviceQueries
        ///  *  @{
        ///  */
        /// 
        /// /**
        ///  * Returns the list of retired pages by source, including pages that are pending retirement
        ///  * The address information provided from this API is the hardware address of the page that was retired.  Note
        ///  * that this does not match the virtual address used in CUDA, but will match the address information in XID 63
        ///  * 
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                            The identifier of the target device
        ///  * @param cause                             Filter page addresses by cause of retirement
        ///  * @param pageCount                         Reference in which to provide the \a addresses buffer size, and
        ///  *                                          to return the number of retired pages that match \a cause
        ///  *                                          Set to 0 to query the size without allocating an \a addresses buffer
        ///  * @param addresses                         Buffer to write the page addresses into
        ///  * 
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if \a pageCount was populated and \a addresses was filled
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE if \a pageCount indicates the buffer is not large enough to store all the
        ///  *                                             matching page addresses.  \a pageCount is set to the needed size.
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, \a pageCount is NULL, \a cause is invalid, or 
        ///  *                                             \a addresses is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetRetiredPages(nvmlDevice_t device, nvmlPageRetirementCause_t cause,
        ///     unsigned int *pageCount, unsigned long long *addresses);
        /// 
        /// /**
        ///  * Returns the list of retired pages by source, including pages that are pending retirement
        ///  * The address information provided from this API is the hardware address of the page that was retired.  Note
        ///  * that this does not match the virtual address used in CUDA, but will match the address information in XID 63
        ///  *
        ///  * \note nvmlDeviceGetRetiredPages_v2 adds an additional timestamps paramter to return the time of each page's
        ///  *       retirement.
        ///  * 
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                            The identifier of the target device
        ///  * @param cause                             Filter page addresses by cause of retirement
        ///  * @param pageCount                         Reference in which to provide the \a addresses buffer size, and
        ///  *                                          to return the number of retired pages that match \a cause
        ///  *                                          Set to 0 to query the size without allocating an \a addresses buffer
        ///  * @param addresses                         Buffer to write the page addresses into
        ///  * @param timestamps                        Buffer to write the timestamps of page retirement, additional for _v2
        ///  * 
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if \a pageCount was populated and \a addresses was filled
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE if \a pageCount indicates the buffer is not large enough to store all the
        ///  *                                             matching page addresses.  \a pageCount is set to the needed size.
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, \a pageCount is NULL, \a cause is invalid, or 
        ///  *                                             \a addresses is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetRetiredPages_v2(nvmlDevice_t device, nvmlPageRetirementCause_t cause,
        ///     unsigned int *pageCount, unsigned long long *addresses, unsigned long long *timestamps);
        /// 
        /// /**
        ///  * Check if any pages are pending retirement and need a reboot to fully retire.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                            The identifier of the target device
        ///  * @param isPending                         Reference in which to return the pending status
        ///  * 
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if \a isPending was populated
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a isPending is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetRetiredPagesPendingStatus(nvmlDevice_t device, nvmlEnableState_t *isPending);
        /// 
        /// /** @} */
        /// 
        /// /***************************************************************************************************/
        /// /** @defgroup nvmlUnitCommands Unit Commands
        ///  *  This chapter describes NVML operations that change the state of the unit. For S-class products.
        ///  *  Each of these requires root/admin access. Non-admin users will see an NVML_ERROR_NO_PERMISSION
        ///  *  error code when invoking any of these methods.
        ///  *  @{
        ///  */
        /// /***************************************************************************************************/
        /// 
        /// /**
        ///  * Set the LED state for the unit. The LED can be either green (0) or amber (1).
        ///  *
        ///  * For S-class products.
        ///  * Requires root/admin permissions.
        ///  *
        ///  * This operation takes effect immediately.
        ///  * 
        ///  *
        ///  * &lt;b&gt;Current S-Class products don't provide unique LEDs for each unit. As such, both front 
        ///  * and back LEDs will be toggled in unison regardless of which unit is specified with this command.&lt;/b&gt;
        ///  *
        ///  * See \ref nvmlLedColor_t for available colors.
        ///  *
        ///  * @param unit                                 The identifier of the target unit
        ///  * @param color                                The target LED color
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if the LED color has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a unit or \a color is invalid
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if this is not an S-class product
        ///  *         - \ref NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  * 
        ///  * @see nvmlUnitGetLedState()
        ///  */
        /// nvmlReturn_t DECLDIR nvmlUnitSetLedState(nvmlUnit_t unit, nvmlLedColor_t color);
        /// 
        /// /** @} */
        /// 
        /// /***************************************************************************************************/
        /// /** @defgroup nvmlDeviceCommands Device Commands
        ///  *  This chapter describes NVML operations that change the state of the device.
        ///  *  Each of these requires root/admin access. Non-admin users will see an NVML_ERROR_NO_PERMISSION
        ///  *  error code when invoking any of these methods.
        ///  *  @{
        ///  */
        /// /***************************************************************************************************/
        /// 
        /// /**
        ///  * Set the persistence mode for the device.
        ///  *
        ///  * For all products.
        ///  * For Linux only.
        ///  * Requires root/admin permissions.
        ///  *
        ///  * The persistence mode determines whether the GPU driver software is torn down after the last client
        ///  * exits.
        ///  *
        ///  * This operation takes effect immediately. It is not persistent across reboots. After each reboot the
        ///  * persistence mode is reset to "Disabled".
        ///  *
        ///  * See \ref nvmlEnableState_t for available modes.
        ///  *
        ///  * After calling this API with mode set to NVML_FEATURE_DISABLED on a device that has its own NUMA
        ///  * memory, the given device handle will no longer be valid, and to continue to interact with this
        ///  * device, a new handle should be obtained from one of the nvmlDeviceGetHandleBy*() APIs. This
        ///  * limitation is currently only applicable to devices that have a coherent NVLink connection to
        ///  * system memory.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param mode                                 The target persistence mode
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if the persistence mode was set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a mode is invalid
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  *
        ///  * @see nvmlDeviceGetPersistenceMode()
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceSetPersistenceMode(nvmlDevice_t device, nvmlEnableState_t mode);
        /// 
        /// /**
        ///  * Set the compute mode for the device.
        ///  *
        ///  * For all products.
        ///  * Requires root/admin permissions.
        ///  *
        ///  * The compute mode determines whether a GPU can be used for compute operations and whether it can
        ///  * be shared across contexts.
        ///  *
        ///  * This operation takes effect immediately. Under Linux it is not persistent across reboots and
        ///  * always resets to "Default". Under windows it is persistent.
        ///  *
        ///  * Under windows compute mode may only be set to DEFAULT when running in WDDM
        ///  *
        ///  * See \ref nvmlComputeMode_t for details on available compute modes.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param mode                                 The target compute mode
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if the compute mode was set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a mode is invalid
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  *
        ///  * @see nvmlDeviceGetComputeMode()
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceSetComputeMode(nvmlDevice_t device, nvmlComputeMode_t mode);
        /// 
        /// /**
        ///  * Set the ECC mode for the device.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  * Only applicable to devices with ECC.
        ///  * Requires \a NVML_INFOROM_ECC version 1.0 or higher.
        ///  * Requires root/admin permissions.
        ///  *
        ///  * The ECC mode determines whether the GPU enables its ECC support.
        ///  *
        ///  * This operation takes effect after the next reboot.
        ///  *
        ///  * See \ref nvmlEnableState_t for details on available modes.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param ecc                                  The target ECC mode
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if the ECC mode was set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a ecc is invalid
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  *
        ///  * @see nvmlDeviceGetEccMode()
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceSetEccMode(nvmlDevice_t device, nvmlEnableState_t ecc);  
        /// 
        /// /**
        ///  * Clear the ECC error and other memory error counts for the device.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  * Only applicable to devices with ECC.
        ///  * Requires \a NVML_INFOROM_ECC version 2.0 or higher to clear aggregate location-based ECC counts.
        ///  * Requires \a NVML_INFOROM_ECC version 1.0 or higher to clear all other ECC counts.
        ///  * Requires root/admin permissions.
        ///  * Requires ECC Mode to be enabled.
        ///  *
        ///  * Sets all of the specified ECC counters to 0, including both detailed and total counts.
        ///  *
        ///  * This operation takes effect immediately.
        ///  *
        ///  * See \ref nvmlMemoryErrorType_t for details on available counter types.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param counterType                          Flag that indicates which type of errors should be cleared.
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if the error counts were cleared
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a counterType is invalid
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  *
        ///  * @see 
        ///  *      - nvmlDeviceGetDetailedEccErrors()
        ///  *      - nvmlDeviceGetTotalEccErrors()
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceClearEccErrorCounts(nvmlDevice_t device, nvmlEccCounterType_t counterType);
        /// 
        /// /**
        ///  * Set the driver model for the device.
        ///  *
        ///  * For Fermi &amp;tm; or newer fully supported devices.
        ///  * For windows only.
        ///  * Requires root/admin permissions.
        ///  *
        ///  * On Windows platforms the device driver can run in either WDDM or WDM (TCC) mode. If a display is attached
        ///  * to the device it must run in WDDM mode.  
        ///  *
        ///  * It is possible to force the change to WDM (TCC) while the display is still attached with a force flag (nvmlFlagForce).
        ///  * This should only be done if the host is subsequently powered down and the display is detached from the device
        ///  * before the next reboot. 
        ///  *
        ///  * This operation takes effect after the next reboot.
        ///  * 
        ///  * Windows driver model may only be set to WDDM when running in DEFAULT compute mode.
        ///  *
        ///  * Change driver model to WDDM is not supported when GPU doesn't support graphics acceleration or 
        ///  * will not support it after reboot. See \ref nvmlDeviceSetGpuOperationMode.
        ///  *
        ///  * See \ref nvmlDriverModel_t for details on available driver models.
        ///  * See \ref nvmlFlagDefault and \ref nvmlFlagForce
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param driverModel                          The target driver model
        ///  * @param flags                                Flags that change the default behavior
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if the driver model has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a driverModel is invalid
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the platform is not windows or the device does not support this feature
        ///  *         - \ref NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  * 
        ///  * @see nvmlDeviceGetDriverModel()
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceSetDriverModel(nvmlDevice_t device, nvmlDriverModel_t driverModel, unsigned int flags);
        /// 
        /// /**
        ///  * Set clocks that device will lock to.
        ///  *
        ///  * Sets the clocks that the device will be running at to the value in the range of minGpuClockMHz to maxGpuClockMHz.
        ///  * Setting this will supercede application clock values and take effect regardless if a cuda app is running.
        ///  * See /ref nvmlDeviceSetApplicationsClocks
        ///  *
        ///  * Can be used as a setting to request constant performance.
        ///  *
        ///  * Requires root/admin permissions.
        ///  *
        ///  * After system reboot or driver reload applications clocks go back to their default value.
        ///  * See \ref nvmlDeviceResetGpuLockedClocks.
        ///  *
        ///  * For newer than Pascal &amp;tm; fully supported devices.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param minGpuClockMHz                       Requested minimum gpu clock in MHz
        ///  * @param maxGpuClockMHz                       Requested maximum gpu clock in MHz
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if new settings were successfully set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a minGpuClockMHz and \a maxGpuClockMHz
        ///  *                                                 is not a valid clock combination
        ///  *         - \ref NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceSetGpuLockedClocks(nvmlDevice_t device, unsigned int minGpuClockMHz, unsigned int maxGpuClockMHz);
        /// 
        /// /**
        ///  * Resets the gpu clock to the default value
        ///  *
        ///  * This is the gpu clock that will be used after system reboot or driver reload.
        ///  * Default values are idle clocks, but the current values can be changed using \ref nvmlDeviceSetApplicationsClocks.
        ///  *
        ///  * @see nvmlDeviceSetGpuLockedClocks
        ///  *
        ///  * For newer than Pascal &amp;tm; fully supported devices.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if new settings were successfully set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceResetGpuLockedClocks(nvmlDevice_t device);
        /// 
        /// /**
        ///  * Set clocks that applications will lock to.
        ///  *
        ///  * Sets the clocks that compute and graphics applications will be running at.
        ///  * e.g. CUDA driver requests these clocks during context creation which means this property
        ///  * defines clocks at which CUDA applications will be running unless some overspec event
        ///  * occurs (e.g. over power, over thermal or external HW brake).
        ///  *
        ///  * Can be used as a setting to request constant performance.
        ///  *
        ///  * On Pascal and newer hardware, this will automatically disable automatic boosting of clocks.
        ///  *
        ///  * On K80 and newer Kepler and Maxwell GPUs, users desiring fixed performance should also call
        ///  * \ref nvmlDeviceSetAutoBoostedClocksEnabled to prevent clocks from automatically boosting
        ///  * above the clock value being set.
        ///  *
        ///  * For Kepler &amp;tm; or newer non-GeForce fully supported devices and Maxwell or newer GeForce devices.
        ///  * Requires root/admin permissions.
        ///  *
        ///  * See \ref nvmlDeviceGetSupportedMemoryClocks and \ref nvmlDeviceGetSupportedGraphicsClocks
        ///  * for details on how to list available clocks combinations.
        ///  *
        ///  * After system reboot or driver reload applications clocks go back to their default value.
        ///  * See \ref nvmlDeviceResetApplicationsClocks.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param memClockMHz                          Requested memory clock in MHz
        ///  * @param graphicsClockMHz                     Requested graphics clock in MHz
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if new settings were successfully set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a memClockMHz and \a graphicsClockMHz
        ///  *                                                 is not a valid clock combination
        ///  *         - \ref NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceSetApplicationsClocks(nvmlDevice_t device, unsigned int memClockMHz, unsigned int graphicsClockMHz);
        /// 
        /// /**
        ///  * Set new power limit of this device.
        ///  * 
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  * Requires root/admin permissions.
        ///  *
        ///  * See \ref nvmlDeviceGetPowerManagementLimitConstraints to check the allowed ranges of values.
        ///  *
        ///  * \note Limit is not persistent across reboots or driver unloads.
        ///  * Enable persistent mode to prevent driver from unloading when no application is using the device.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param limit                                Power management limit in milliwatts to set
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a limit has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a defaultLimit is out of range
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  *
        ///  * @see nvmlDeviceGetPowerManagementLimitConstraints
        ///  * @see nvmlDeviceGetPowerManagementDefaultLimit
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceSetPowerManagementLimit(nvmlDevice_t device, unsigned int limit);
        /// 
        /// /**
        ///  * Sets new GOM. See \a nvmlGpuOperationMode_t for details.
        ///  *
        ///  * For GK110 M-class and X-class Tesla &amp;tm; products from the Kepler family.
        ///  * Modes \ref NVML_GOM_LOW_DP and \ref NVML_GOM_ALL_ON are supported on fully supported GeForce products.
        ///  * Not supported on Quadro &amp;reg; and Tesla &amp;tm; C-class products.
        ///  * Requires root/admin permissions.
        ///  * 
        ///  * Changing GOMs requires a reboot. 
        ///  * The reboot requirement might be removed in the future.
        ///  *
        ///  * Compute only GOMs don't support graphics acceleration. Under windows switching to these GOMs when
        ///  * pending driver model is WDDM is not supported. See \ref nvmlDeviceSetDriverModel.
        ///  * 
        ///  * @param device                               The identifier of the target device
        ///  * @param mode                                 Target GOM
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a mode has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a mode incorrect
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support GOM or specific mode
        ///  *         - \ref NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  *
        ///  * @see nvmlGpuOperationMode_t
        ///  * @see nvmlDeviceGetGpuOperationMode
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceSetGpuOperationMode(nvmlDevice_t device, nvmlGpuOperationMode_t mode);
        /// 
        /// /**
        ///  * Changes the root/admin restructions on certain APIs. See \a nvmlRestrictedAPI_t for the list of supported APIs.
        ///  * This method can be used by a root/admin user to give non-root/admin access to certain otherwise-restricted APIs.
        ///  * The new setting lasts for the lifetime of the NVIDIA driver; it is not persistent. See \a nvmlDeviceGetAPIRestriction
        ///  * to query the current restriction settings.
        ///  * 
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  * Requires root/admin permissions.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param apiType                              Target API type for this operation
        ///  * @param isRestricted                         The target restriction
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if \a isRestricted has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a apiType incorrect
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support changing API restrictions or the device does not support
        ///  *                                                 the feature that api restrictions are being set for (E.G. Enabling/disabling auto 
        ///  *                                                 boosted clocks is not supported by the device)
        ///  *         - \ref NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  *
        ///  * @see nvmlRestrictedAPI_t
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceSetAPIRestriction(nvmlDevice_t device, nvmlRestrictedAPI_t apiType, nvmlEnableState_t isRestricted);
        /// 
        /// /**
        ///  * @}
        ///  */
        ///  
        /// /** @addtogroup nvmlAccountingStats
        ///  *  @{
        ///  */
        /// 
        /// /**
        ///  * Enables or disables per process accounting.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  * Requires root/admin permissions.
        ///  *
        ///  * @note This setting is not persistent and will default to disabled after driver unloads.
        ///  *       Enable persistence mode to be sure the setting doesn't switch off to disabled.
        ///  * 
        ///  * @note Enabling accounting mode has no negative impact on the GPU performance.
        ///  *
        ///  * @note Disabling accounting clears all accounting pids information.
        ///  *
        ///  * See \ref nvmlDeviceGetAccountingMode
        ///  * See \ref nvmlDeviceGetAccountingStats
        ///  * See \ref nvmlDeviceClearAccountingPids
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param mode                                 The target accounting mode
        ///  *
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if the new mode has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device or \a mode are invalid
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature
        ///  *         - \ref NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceSetAccountingMode(nvmlDevice_t device, nvmlEnableState_t mode);
        /// 
        /// /**
        ///  * Clears accounting information about all processes that have already terminated.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  * Requires root/admin permissions.
        ///  *
        ///  * See \ref nvmlDeviceGetAccountingMode
        ///  * See \ref nvmlDeviceGetAccountingStats
        ///  * See \ref nvmlDeviceSetAccountingMode
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  *
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if accounting information has been cleared 
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device are invalid
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature
        ///  *         - \ref NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceClearAccountingPids(nvmlDevice_t device);
        /// 
        /// /** @} */
        /// 
        /// /***************************************************************************************************/
        /// /** @defgroup NvLink NvLink Methods
        ///  * This chapter describes methods that NVML can perform on NVLINK enabled devices.
        ///  *  @{
        ///  */
        /// /***************************************************************************************************/
        /// 
        /// /**
        ///  * Retrieves the state of the device's NvLink for the link specified
        ///  *
        ///  * For Pascal &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param link                                 Specifies the NvLink link to be queried
        ///  * @param isActive                             \a nvmlEnableState_t where NVML_FEATURE_ENABLED indicates that
        ///  *                                             the link is active and NVML_FEATURE_DISABLED indicates it 
        ///  *                                             is inactive
        ///  *
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a isActive has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device or \a link is invalid or \a isActive is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetNvLinkState(nvmlDevice_t device, unsigned int link, nvmlEnableState_t *isActive);
        /// 
        /// /**
        ///  * Retrieves the version of the device's NvLink for the link specified
        ///  *
        ///  * For Pascal &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param link                                 Specifies the NvLink link to be queried
        ///  * @param version                              Requested NvLink version
        ///  *
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a version has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device or \a link is invalid or \a version is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetNvLinkVersion(nvmlDevice_t device, unsigned int link, unsigned int *version);
        /// 
        /// /**
        ///  * Retrieves the requested capability from the device's NvLink for the link specified
        ///  * Please refer to the \a nvmlNvLinkCapability_t structure for the specific caps that can be queried
        ///  * The return value should be treated as a boolean.
        ///  *
        ///  * For Pascal &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param link                                 Specifies the NvLink link to be queried
        ///  * @param capability                           Specifies the \a nvmlNvLinkCapability_t to be queried
        ///  * @param capResult                            A boolean for the queried capability indicating that feature is available
        ///  *
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a capResult has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device, \a link, or \a capability is invalid or \a capResult is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetNvLinkCapability(nvmlDevice_t device, unsigned int link,
        ///                                                    nvmlNvLinkCapability_t capability, unsigned int *capResult); 
        /// 
        /// /**
        ///  * Retrieves the PCI information for the remote node on a NvLink link 
        ///  * Note: pciSubSystemId is not filled in this function and is indeterminate
        ///  *
        ///  * For Pascal &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param link                                 Specifies the NvLink link to be queried
        ///  * @param pci                                  \a nvmlPciInfo_t of the remote node for the specified link                            
        ///  *
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a pci has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device or \a link is invalid or \a pci is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetNvLinkRemotePciInfo(nvmlDevice_t device, unsigned int link, nvmlPciInfo_t *pci);
        /// 
        /// /**
        ///  * Retrieves the specified error counter value
        ///  * Please refer to \a nvmlNvLinkErrorCounter_t for error counters that are available
        ///  *
        ///  * For Pascal &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param link                                 Specifies the NvLink link to be queried
        ///  * @param counter                              Specifies the NvLink counter to be queried
        ///  * @param counterValue                         Returned counter value
        ///  *
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a counter has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device, \a link, or \a counter is invalid or \a counterValue is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetNvLinkErrorCounter(nvmlDevice_t device, unsigned int link,
        ///                                                      nvmlNvLinkErrorCounter_t counter, unsigned long long *counterValue);
        /// 
        /// /**
        ///  * Resets all error counters to zero
        ///  * Please refer to \a nvmlNvLinkErrorCounter_t for the list of error counters that are reset
        ///  *
        ///  * For Pascal &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param link                                 Specifies the NvLink link to be queried
        ///  *
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if the reset is successful
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device or \a link is invalid
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceResetNvLinkErrorCounters(nvmlDevice_t device, unsigned int link);
        /// 
        /// /**
        ///  * Set the NVLINK utilization counter control information for the specified counter, 0 or 1.
        ///  * Please refer to \a nvmlNvLinkUtilizationControl_t for the structure definition.  Performs a reset
        ///  * of the counters if the reset parameter is non-zero.
        ///  *
        ///  * For Pascal &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param counter                              Specifies the counter that should be set (0 or 1).
        ///  * @param link                                 Specifies the NvLink link to be queried
        ///  * @param control                              A reference to the \a nvmlNvLinkUtilizationControl_t to set
        ///  * @param reset                                Resets the counters on set if non-zero
        ///  *
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if the control has been set successfully
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device, \a counter, \a link, or \a control is invalid 
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceSetNvLinkUtilizationControl(nvmlDevice_t device, unsigned int link, unsigned int counter,
        ///                                                            nvmlNvLinkUtilizationControl_t *control, unsigned int reset);
        /// 
        /// /**
        ///  * Get the NVLINK utilization counter control information for the specified counter, 0 or 1.
        ///  * Please refer to \a nvmlNvLinkUtilizationControl_t for the structure definition
        ///  *
        ///  * For Pascal &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param counter                              Specifies the counter that should be set (0 or 1).
        ///  * @param link                                 Specifies the NvLink link to be queried
        ///  * @param control                              A reference to the \a nvmlNvLinkUtilizationControl_t to place information
        ///  *
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if the control has been set successfully
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device, \a counter, \a link, or \a control is invalid 
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetNvLinkUtilizationControl(nvmlDevice_t device, unsigned int link, unsigned int counter,
        ///                                                            nvmlNvLinkUtilizationControl_t *control);
        /// 
        /// 
        /// /**
        ///  * Retrieve the NVLINK utilization counter based on the current control for a specified counter.
        ///  * In general it is good practice to use \a nvmlDeviceSetNvLinkUtilizationControl
        ///  *  before reading the utilization counters as they have no default state
        ///  *
        ///  * For Pascal &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param link                                 Specifies the NvLink link to be queried
        ///  * @param counter                              Specifies the counter that should be read (0 or 1).
        ///  * @param rxcounter                            Receive counter return value
        ///  * @param txcounter                            Transmit counter return value
        ///  *
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a rxcounter and \a txcounter have been successfully set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device, \a counter, or \a link is invalid or \a rxcounter or \a txcounter are NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetNvLinkUtilizationCounter(nvmlDevice_t device, unsigned int link, unsigned int counter, 
        ///                                                            unsigned long long *rxcounter, unsigned long long *txcounter);
        /// 
        /// /**
        ///  * Freeze the NVLINK utilization counters 
        ///  * Both the receive and transmit counters are operated on by this function
        ///  *
        ///  * For Pascal &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param link                                 Specifies the NvLink link to be queried
        ///  * @param counter                              Specifies the counter that should be frozen (0 or 1).
        ///  * @param freeze                               NVML_FEATURE_ENABLED = freeze the receive and transmit counters
        ///  *                                             NVML_FEATURE_DISABLED = unfreeze the receive and transmit counters
        ///  *
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if counters were successfully frozen or unfrozen
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device, \a link, \a counter, or \a freeze is invalid
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceFreezeNvLinkUtilizationCounter (nvmlDevice_t device, unsigned int link, 
        ///                                             unsigned int counter, nvmlEnableState_t freeze);
        /// 
        /// /**
        ///  * Reset the NVLINK utilization counters 
        ///  * Both the receive and transmit counters are operated on by this function
        ///  *
        ///  * For Pascal &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param link                                 Specifies the NvLink link to be reset
        ///  * @param counter                              Specifies the counter that should be reset (0 or 1)
        ///  *
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if counters were successfully reset
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device, \a link, or \a counter is invalid
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceResetNvLinkUtilizationCounter (nvmlDevice_t device, unsigned int link, unsigned int counter);
        /// 
        /// /** @} */
        /// 
        /// /***************************************************************************************************/
        /// /** @defgroup nvmlEvents Event Handling Methods
        ///  * This chapter describes methods that NVML can perform against each device to register and wait for 
        ///  * some event to occur.
        ///  *  @{
        ///  */
        /// /***************************************************************************************************/
        /// 
        /// /**
        ///  * Create an empty set of events.
        ///  * Event set should be freed by \ref nvmlEventSetFree
        ///  *
        ///  * For Fermi &amp;tm; or newer fully supported devices.
        ///  * @param set                                  Reference in which to return the event handle
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if the event has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a set is NULL
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  * 
        ///  * @see nvmlEventSetFree
        ///  */
        /// nvmlReturn_t DECLDIR nvmlEventSetCreate(nvmlEventSet_t *set);
        /// 
        /// /**
        ///  * Starts recording of events on a specified devices and add the events to specified \ref nvmlEventSet_t
        ///  *
        ///  * For Fermi &amp;tm; or newer fully supported devices.
        ///  * Ecc events are available only on ECC enabled devices (see \ref nvmlDeviceGetTotalEccErrors)
        ///  * Power capping events are available only on Power Management enabled devices (see \ref nvmlDeviceGetPowerManagementMode)
        ///  *
        ///  * For Linux only.
        ///  *
        ///  * \b IMPORTANT: Operations on \a set are not thread safe
        ///  *
        ///  * This call starts recording of events on specific device.
        ///  * All events that occurred before this call are not recorded.
        ///  * Checking if some event occurred can be done with \ref nvmlEventSetWait
        ///  *
        ///  * If function reports NVML_ERROR_UNKNOWN, event set is in undefined state and should be freed.
        ///  * If function reports NVML_ERROR_NOT_SUPPORTED, event set can still be used. None of the requested eventTypes
        ///  *     are registered in that case.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param eventTypes                           Bitmask of \ref nvmlEventType to record
        ///  * @param set                                  Set to which add new event types
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if the event has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a eventTypes is invalid or \a set is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the platform does not support this feature or some of requested event types
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  * 
        ///  * @see nvmlEventType
        ///  * @see nvmlDeviceGetSupportedEventTypes
        ///  * @see nvmlEventSetWait
        ///  * @see nvmlEventSetFree
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceRegisterEvents(nvmlDevice_t device, unsigned long long eventTypes, nvmlEventSet_t set);
        /// 
        /// /**
        ///  * Returns information about events supported on device
        ///  *
        ///  * For Fermi &amp;tm; or newer fully supported devices.
        ///  *
        ///  * Events are not supported on Windows. So this function returns an empty mask in \a eventTypes on Windows.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param eventTypes                           Reference in which to return bitmask of supported events
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if the eventTypes has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a eventType is NULL
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  * 
        ///  * @see nvmlEventType
        ///  * @see nvmlDeviceRegisterEvents
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetSupportedEventTypes(nvmlDevice_t device, unsigned long long *eventTypes);
        /// 
        /// /**
        ///  * Waits on events and delivers events
        ///  *
        ///  * For Fermi &amp;tm; or newer fully supported devices.
        ///  *
        ///  * If some events are ready to be delivered at the time of the call, function returns immediately.
        ///  * If there are no events ready to be delivered, function sleeps till event arrives 
        ///  * but not longer than specified timeout. This function in certain conditions can return before
        ///  * specified timeout passes (e.g. when interrupt arrives)
        ///  * 
        ///  * In case of xid error, the function returns the most recent xid error type seen by the system. If there are multiple
        ///  * xid errors generated before nvmlEventSetWait is invoked then the last seen xid error type is returned for all
        ///  * xid error events.
        ///  * 
        ///  * @param set                                  Reference to set of events to wait on
        ///  * @param data                                 Reference in which to return event data
        ///  * @param timeoutms                            Maximum amount of wait time in milliseconds for registered event
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if the data has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a data is NULL
        ///  *         - \ref NVML_ERROR_TIMEOUT           if no event arrived in specified timeout or interrupt arrived
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if a GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  * 
        ///  * @see nvmlEventType
        ///  * @see nvmlDeviceRegisterEvents
        ///  */
        /// nvmlReturn_t DECLDIR nvmlEventSetWait(nvmlEventSet_t set, nvmlEventData_t * data, unsigned int timeoutms);
        /// 
        /// /**
        ///  * Releases events in the set
        ///  *
        ///  * For Fermi &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param set                                  Reference to events to be released 
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if the event has been successfully released
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  * 
        ///  * @see nvmlDeviceRegisterEvents
        ///  */
        /// nvmlReturn_t DECLDIR nvmlEventSetFree(nvmlEventSet_t set);
        /// 
        /// /** @} */
        /// 
        /// /***************************************************************************************************/
        /// /** @defgroup nvmlZPI Drain states 
        ///  * This chapter describes methods that NVML can perform against each device to control their drain state
        ///  * and recognition by NVML and NVIDIA kernel driver. These methods can be used with out-of-band tools to
        ///  * power on/off GPUs, enable robust reset scenarios, etc.
        ///  *  @{
        ///  */
        /// /***************************************************************************************************/
        /// 
        /// /**
        ///  * Modify the drain state of a GPU.  This method forces a GPU to no longer accept new incoming requests.
        ///  * Any new NVML process will no longer see this GPU.  Persistence mode for this GPU must be turned off before
        ///  * this call is made.
        ///  * Must be called as administrator.
        ///  * For Linux only.
        ///  * 
        ///  * For Pascal &amp;tm; or newer fully supported devices.
        ///  * Some Kepler devices supported.
        ///  *
        ///  * @param pciInfo                              The PCI address of the GPU drain state to be modified
        ///  * @param newState                             The drain state that should be entered, see \ref nvmlEnableState_t
        ///  *
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if counters were successfully reset
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a nvmlIndex or \a newState is invalid
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature
        ///  *         - \ref NVML_ERROR_NO_PERMISSION     if the calling process has insufficient permissions to perform operation
        ///  *         - \ref NVML_ERROR_IN_USE            if the device has persistence mode turned on
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceModifyDrainState (nvmlPciInfo_t *pciInfo, nvmlEnableState_t newState);
        /// 
        /// /**
        ///  * Query the drain state of a GPU.  This method is used to check if a GPU is in a currently draining
        ///  * state.
        ///  * For Linux only.
        ///  * 
        ///  * For Pascal &amp;tm; or newer fully supported devices.
        ///  * Some Kepler devices supported.
        ///  *
        ///  * @param pciInfo                              The PCI address of the GPU drain state to be queried
        ///  * @param currentState                         The current drain state for this GPU, see \ref nvmlEnableState_t
        ///  *
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if counters were successfully reset
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a nvmlIndex or \a currentState is invalid
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceQueryDrainState (nvmlPciInfo_t *pciInfo, nvmlEnableState_t *currentState);
        /// 
        /// /**
        ///  * This method will remove the specified GPU from the view of both NVML and the NVIDIA kernel driver
        ///  * as long as no other processes are attached. If other processes are attached, this call will return
        ///  * NVML_ERROR_IN_USE and the GPU will be returned to its original "draining" state. Note: the
        ///  * only situation where a process can still be attached after nvmlDeviceModifyDrainState() is called
        ///  * to initiate the draining state is if that process was using, and is still using, a GPU before the 
        ///  * call was made. Also note, persistence mode counts as an attachment to the GPU thus it must be disabled
        ///  * prior to this call.
        ///  *
        ///  * For long-running NVML processes please note that this will change the enumeration of current GPUs.
        ///  * For example, if there are four GPUs present and GPU1 is removed, the new enumeration will be 0-2.
        ///  * Also, device handles after the removed GPU will not be valid and must be re-established.
        ///  * Must be run as administrator. 
        ///  * For Linux only.
        ///  *
        ///  * For Pascal &amp;tm; or newer fully supported devices.
        ///  * Some Kepler devices supported.
        ///  *
        ///  * @param pciInfo                              The PCI address of the GPU to be removed
        ///  * @param gpuState                             Whether the GPU is to be removed, from the OS
        ///  *                                             see \ref nvmlDetachGpuState_t
        ///  * @param linkState                            Requested upstream PCIe link state, see \ref nvmlPcieLinkState_t
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if counters were successfully reset
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a nvmlIndex is invalid
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature
        ///  *         - \ref NVML_ERROR_IN_USE            if the device is still in use and cannot be removed
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceRemoveGpu (nvmlPciInfo_t *pciInfo, nvmlDetachGpuState_t gpuState, nvmlPcieLinkState_t linkState);
        /// 
        /// /**
        ///  * Request the OS and the NVIDIA kernel driver to rediscover a portion of the PCI subsystem looking for GPUs that
        ///  * were previously removed. The portion of the PCI tree can be narrowed by specifying a domain, bus, and device.  
        ///  * If all are zeroes then the entire PCI tree will be searched.  Please note that for long-running NVML processes
        ///  * the enumeration will change based on how many GPUs are discovered and where they are inserted in bus order.
        ///  *
        ///  * In addition, all newly discovered GPUs will be initialized and their ECC scrubbed which may take several seconds
        ///  * per GPU. Also, all device handles are no longer guaranteed to be valid post discovery.
        ///  *
        ///  * Must be run as administrator.
        ///  * For Linux only.
        ///  * 
        ///  * For Pascal &amp;tm; or newer fully supported devices.
        ///  * Some Kepler devices supported.
        ///  *
        ///  * @param pciInfo                              The PCI tree to be searched.  Only the domain, bus, and device
        ///  *                                             fields are used in this call.
        ///  *
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if counters were successfully reset
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a pciInfo is invalid
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the operating system does not support this feature
        ///  *         - \ref NVML_ERROR_OPERATING_SYSTEM  if the operating system is denying this feature
        ///  *         - \ref NVML_ERROR_NO_PERMISSION     if the calling process has insufficient permissions to perform operation
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceDiscoverGpus (nvmlPciInfo_t *pciInfo);
        /// 
        /// /** @} */
        /// 
        /// /***************************************************************************************************/
        /// /** @defgroup nvmlFieldValueQueries Field Value Queries
        ///  *  This chapter describes NVML operations that are associated with retrieving Field Values from NVML
        ///  *  @{
        ///  */
        /// /***************************************************************************************************/
        /// 
        /// /**
        ///  * Request values for a list of fields for a device. This API allows multiple fields to be queried at once.
        ///  * If any of the underlying fieldIds are populated by the same driver call, the results for those field IDs
        ///  * will be populated from a single call rather than making a driver call for each fieldId.
        ///  *
        ///  * @param device                               The device handle of the GPU to request field values for
        ///  * @param valuesCount                          Number of entries in values that should be retrieved
        ///  * @param values                               Array of \a valuesCount structures to hold field values.
        ///  *                                             Each value's fieldId must be populated prior to this call
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if any values in \a values were populated. Note that you must
        ///  *                                             check the nvmlReturn field of each value for each individual
        ///  *                                             status
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a values is NULL
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetFieldValues(nvmlDevice_t device, int valuesCount, nvmlFieldValue_t *values);
        /// 
        /// 
        /// /** @} */
        /// 
        /// /***************************************************************************************************/
        /// /** @defgroup nvmlGridQueries Grid Queries
        ///  *  This chapter describes NVML operations that are associated with NVIDIA GRID products.
        ///  *  @{
        ///  */
        /// /***************************************************************************************************/
        /// 
        /// /**
        ///  * This method is used to get the virtualization mode corresponding to the GPU.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                    Identifier of the target device
        ///  * @param pVirtualMode              Reference to virtualization mode. One of NVML_GPU_VIRTUALIZATION_?
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                  if \a pVirtualMode is fetched
        ///  *         - \ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT   if \a device is invalid or \a pVirtualMode is NULL
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST        if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN            on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetVirtualizationMode(nvmlDevice_t device, nvmlGpuVirtualizationMode_t *pVirtualMode);
        /// 
        /// /** @} */
        /// 
        /// /***************************************************************************************************/
        /// /** @defgroup nvmlGridCommands Grid Commands
        ///  *  This chapter describes NVML operations that are associated with NVIDIA GRID products.
        ///  *  @{
        ///  */
        /// /***************************************************************************************************/
        /// 
        /// /**
        ///  * This method is used to set the virtualization mode corresponding to the GPU.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                    Identifier of the target device
        ///  * @param virtualMode               virtualization mode. One of NVML_GPU_VIRTUALIZATION_?
        ///  *
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                  if \a pVirtualMode is set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT   if \a device is invalid or \a pVirtualMode is NULL
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST        if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED      if setting of virtualization mode is not supported.
        ///  *         - \ref NVML_ERROR_NO_PERMISSION      if setting of virtualization mode is not allowed for this client.
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceSetVirtualizationMode(nvmlDevice_t device, nvmlGpuVirtualizationMode_t virtualMode);
        /// 
        /// /** @} */
        /// 
        /// /***************************************************************************************************/
        /// /** @defgroup nvmlVgpu vGPU Management
        ///  * @{
        ///  *
        ///  * Set of APIs supporting GRID vGPU
        ///  */
        /// /***************************************************************************************************/
        /// 
        /// /**
        ///  * Retrieve the supported vGPU types on a physical GPU (device).
        ///  *
        ///  * An array of supported vGPU types for the physical GPU indicated by \a device is returned in the caller-supplied buffer
        ///  * pointed at by \a vgpuTypeIds. The element count of nvmlVgpuTypeId_t array is passed in \a vgpuCount, and \a vgpuCount
        ///  * is used to return the number of vGPU types written to the buffer.
        ///  *
        ///  * If the supplied buffer is not large enough to accomodate the vGPU type array, the function returns
        ///  * NVML_ERROR_INSUFFICIENT_SIZE, with the element count of nvmlVgpuTypeId_t array required in \a vgpuCount.
        ///  * To query the number of vGPU types supported for the GPU, call this function with *vgpuCount = 0.
        ///  * The code will return NVML_ERROR_INSUFFICIENT_SIZE, or NVML_SUCCESS if no vGPU types are supported.
        ///  *
        ///  * @param device                   The identifier of the target device
        ///  * @param vgpuCount                Pointer to caller-supplied array size, and returns number of vGPU types
        ///  * @param vgpuTypeIds              Pointer to caller-supplied array in which to return list of vGPU types
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                      successful completion
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE      \a vgpuTypeIds buffer is too small, array element count is returned in \a vgpuCount
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT       if \a vgpuCount is NULL or \a device is invalid
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED          if vGPU is not supported by the device
        ///  *         - \ref NVML_ERROR_VGPU_ECC_NOT_SUPPORTED if ECC is enabled on the device
        ///  *         - \ref NVML_ERROR_UNKNOWN                on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetSupportedVgpus(nvmlDevice_t device, unsigned int *vgpuCount, nvmlVgpuTypeId_t *vgpuTypeIds);
        /// 
        /// /**
        ///  * Retrieve the currently creatable vGPU types on a physical GPU (device).
        ///  *
        ///  * An array of creatable vGPU types for the physical GPU indicated by \a device is returned in the caller-supplied buffer
        ///  * pointed at by \a vgpuTypeIds. The element count of nvmlVgpuTypeId_t array is passed in \a vgpuCount, and \a vgpuCount
        ///  * is used to return the number of vGPU types written to the buffer.
        ///  *
        ///  * The creatable vGPU types for a device may differ over time, as there may be restrictions on what type of vGPU types
        ///  * can concurrently run on a device.  For example, if only one vGPU type is allowed at a time on a device, then the creatable
        ///  * list will be restricted to whatever vGPU type is already running on the device.
        ///  *
        ///  * If the supplied buffer is not large enough to accomodate the vGPU type array, the function returns
        ///  * NVML_ERROR_INSUFFICIENT_SIZE, with the element count of nvmlVgpuTypeId_t array required in \a vgpuCount.
        ///  * To query the number of vGPU types createable for the GPU, call this function with *vgpuCount = 0.
        ///  * The code will return NVML_ERROR_INSUFFICIENT_SIZE, or NVML_SUCCESS if no vGPU types are creatable.
        ///  *
        ///  * @param device                   The identifier of the target device
        ///  * @param vgpuCount                Pointer to caller-supplied array size, and returns number of vGPU types
        ///  * @param vgpuTypeIds              Pointer to caller-supplied array in which to return list of vGPU types
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                      successful completion
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE      \a vgpuTypeIds buffer is too small, array element count is returned in \a vgpuCount
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT       if \a vgpuCount is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED          if vGPU is not supported by the device
        ///  *         - \ref NVML_ERROR_VGPU_ECC_NOT_SUPPORTED if ECC is enabled on the device
        ///  *         - \ref NVML_ERROR_UNKNOWN                on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetCreatableVgpus(nvmlDevice_t device, unsigned int *vgpuCount, nvmlVgpuTypeId_t *vgpuTypeIds);
        /// 
        /// /**
        ///  * Retrieve the class of a vGPU type. It will not exceed 64 characters in length (including the NUL terminator).
        ///  * See \ref nvmlConstants::NVML_DEVICE_NAME_BUFFER_SIZE.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param vgpuTypeId               Handle to vGPU type
        ///  * @param vgpuTypeClass            Pointer to string array to return class in
        ///  * @param size                     Size of string
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                   successful completion
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT    if \a vgpuTypeId is invalid, or \a vgpuTypeClass is NULL
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE   if \a size is too small
        ///  *         - \ref NVML_ERROR_UNKNOWN             on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuTypeGetClass(nvmlVgpuTypeId_t vgpuTypeId, char *vgpuTypeClass, unsigned int *size);
        /// 
        /// /**
        ///  * Retrieve the vGPU type name.
        ///  *
        ///  * The name is an alphanumeric string that denotes a particular vGPU, e.g. GRID M60-2Q. It will not
        ///  * exceed 64 characters in length (including the NUL terminator).  See \ref
        ///  * nvmlConstants::NVML_DEVICE_NAME_BUFFER_SIZE.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param vgpuTypeId               Handle to vGPU type
        ///  * @param vgpuTypeName             Pointer to buffer to return name
        ///  * @param size                     Size of buffer
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 successful completion
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a vgpuTypeId is invalid, or \a name is NULL
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE if \a size is too small
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuTypeGetName(nvmlVgpuTypeId_t vgpuTypeId, char *vgpuTypeName, unsigned int *size);
        /// 
        /// /**
        ///  * Retrieve the device ID of a vGPU type.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param vgpuTypeId               Handle to vGPU type
        ///  * @param deviceID                 Device ID and vendor ID of the device contained in single 32 bit value
        ///  * @param subsystemID              Subsytem ID and subsytem vendor ID of the device contained in single 32 bit value
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 successful completion
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a vgpuTypeId is invalid, or \a deviceId or \a subsystemID are NULL
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuTypeGetDeviceID(nvmlVgpuTypeId_t vgpuTypeId, unsigned long long *deviceID, unsigned long long *subsystemID);
        /// 
        /// /**
        ///  * Retrieve the vGPU framebuffer size in bytes.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param vgpuTypeId               Handle to vGPU type
        ///  * @param fbSize                   Pointer to framebuffer size in bytes
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 successful completion
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a vgpuTypeId is invalid, or \a fbSize is NULL
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuTypeGetFramebufferSize(nvmlVgpuTypeId_t vgpuTypeId, unsigned long long *fbSize);
        /// 
        /// /**
        ///  * Retrieve count of vGPU's supported display heads.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param vgpuTypeId               Handle to vGPU type
        ///  * @param numDisplayHeads          Pointer to number of display heads
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 successful completion
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a vgpuTypeId is invalid, or \a numDisplayHeads is NULL
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuTypeGetNumDisplayHeads(nvmlVgpuTypeId_t vgpuTypeId, unsigned int *numDisplayHeads);
        /// 
        /// /**
        ///  * Retrieve vGPU display head's maximum supported resolution.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param vgpuTypeId               Handle to vGPU type
        ///  * @param displayIndex             Zero-based index of display head
        ///  * @param xdim                     Pointer to maximum number of pixels in X dimension
        ///  * @param ydim                     Pointer to maximum number of pixels in Y dimension
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 successful completion
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a vgpuTypeId is invalid, or \a xdim or \a ydim are NULL, or \a displayIndex
        ///  *                                             is out of range.
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuTypeGetResolution(nvmlVgpuTypeId_t vgpuTypeId, unsigned int displayIndex, unsigned int *xdim, unsigned int *ydim);
        /// 
        /// /**
        ///  * Retrieve license requirements for a vGPU type
        ///  *
        ///  * The license type and version required to run the specified vGPU type is returned as an alphanumeric string, in the form
        ///  * "&lt;license name&gt;,&lt;version&gt;", for example "GRID-Virtual-PC,2.0". If a vGPU is runnable with* more than one type of license,
        ///  * the licenses are delimited by a semicolon, for example "GRID-Virtual-PC,2.0;GRID-Virtual-WS,2.0;GRID-Virtual-WS-Ext,2.0".
        ///  *
        ///  * The total length of the returned string will not exceed 128 characters, including the NUL terminator.
        ///  * See \ref nvmlVgpuConstants::NVML_GRID_LICENSE_BUFFER_SIZE.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param vgpuTypeId               Handle to vGPU type
        ///  * @param vgpuTypeLicenseString    Pointer to buffer to return license info
        ///  * @param size                     Size of \a vgpuTypeLicenseString buffer
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 successful completion
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a vgpuTypeId is invalid, or \a vgpuTypeLicenseString is NULL
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE if \a size is too small
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuTypeGetLicense(nvmlVgpuTypeId_t vgpuTypeId, char *vgpuTypeLicenseString, unsigned int size);
        /// 
        /// /**
        ///  * Retrieve the static frame rate limit value of the vGPU type
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param vgpuTypeId               Handle to vGPU type
        ///  * @param frameRateLimit           Reference to return the frame rate limit value
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 successful completion
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if frame rate limiter is turned off for the vGPU type
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a vgpuTypeId is invalid, or \a frameRateLimit is NULL
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuTypeGetFrameRateLimit(nvmlVgpuTypeId_t vgpuTypeId, unsigned int *frameRateLimit);
        /// 
        /// /**
        ///  * Retrieve the maximum number of vGPU instances creatable on a device for given vGPU type
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                   The identifier of the target device
        ///  * @param vgpuTypeId               Handle to vGPU type
        ///  * @param vgpuInstanceCount        Pointer to get the max number of vGPU instances
        ///  *                                 that can be created on a deicve for given vgpuTypeId
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 successful completion
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a vgpuTypeId is invalid or is not supported on target device,
        ///  *                                             or \a vgpuInstanceCount is NULL
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuTypeGetMaxInstances(nvmlDevice_t device, nvmlVgpuTypeId_t vgpuTypeId, unsigned int *vgpuInstanceCount);
        /// 
        /// /**
        ///  * Retrieve the maximum number of vGPU instances supported per VM for given vGPU type
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param vgpuTypeId               Handle to vGPU type
        ///  * @param vgpuInstanceCountPerVm   Pointer to get the max number of vGPU instances supported per VM for given \a vgpuTypeId
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 successful completion
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a vgpuTypeId is invalid, or \a vgpuInstanceCountPerVm is NULL
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuTypeGetMaxInstancesPerVm(nvmlVgpuTypeId_t vgpuTypeId, unsigned int *vgpuInstanceCountPerVm);
        /// 
        /// /**
        ///  * Retrieve the active vGPU instances on a device.
        ///  *
        ///  * An array of active vGPU instances is returned in the caller-supplied buffer pointed at by \a vgpuInstances. The
        ///  * array elememt count is passed in \a vgpuCount, and \a vgpuCount is used to return the number of vGPU instances
        ///  * written to the buffer.
        ///  *
        ///  * If the supplied buffer is not large enough to accomodate the vGPU instance array, the function returns
        ///  * NVML_ERROR_INSUFFICIENT_SIZE, with the element count of nvmlVgpuInstance_t array required in \a vgpuCount.
        ///  * To query the number of active vGPU instances, call this function with *vgpuCount = 0.  The code will return
        ///  * NVML_ERROR_INSUFFICIENT_SIZE, or NVML_SUCCESS if no vGPU Types are supported.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                   The identifier of the target device
        ///  * @param vgpuCount                Pointer which passes in the array size as well as get
        ///  *                                 back the number of types
        ///  * @param vgpuInstances            Pointer to array in which to return list of vGPU instances
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                  successful completion
        ///  *         - \ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT   if \a device is invalid, or \a vgpuCount is NULL
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE  if \a size is too small
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED      if vGPU is not supported by the device
        ///  *         - \ref NVML_ERROR_UNKNOWN            on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetActiveVgpus(nvmlDevice_t device, unsigned int *vgpuCount, nvmlVgpuInstance_t *vgpuInstances);
        /// 
        /// /**
        ///  * Retrieve the VM ID associated with a vGPU instance.
        ///  *
        ///  * The VM ID is returned as a string, not exceeding 80 characters in length (including the NUL terminator).
        ///  * See \ref nvmlConstants::NVML_DEVICE_UUID_BUFFER_SIZE.
        ///  *
        ///  * The format of the VM ID varies by platform, and is indicated by the type identifier returned in \a vmIdType.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param vgpuInstance             Identifier of the target vGPU instance
        ///  * @param vmId                     Pointer to caller-supplied buffer to hold VM ID
        ///  * @param size                     Size of buffer in bytes
        ///  * @param vmIdType                 Pointer to hold VM ID type
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 successful completion
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a vmId or \a vmIdType is NULL, or \a vgpuInstance is 0
        ///  *         - \ref NVML_ERROR_NOT_FOUND         if \a vgpuInstance does not match a valid active vGPU instance on the system
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE if \a size is too small
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuInstanceGetVmID(nvmlVgpuInstance_t vgpuInstance, char *vmId, unsigned int size, nvmlVgpuVmIdType_t *vmIdType);
        /// 
        /// /**
        ///  * Retrieve the UUID of a vGPU instance.
        ///  *
        ///  * The UUID is a globally unique identifier associated with the vGPU, and is returned as a 5-part hexadecimal string,
        ///  * not exceeding 80 characters in length (including the NULL terminator).
        ///  * See \ref nvmlConstants::NVML_DEVICE_UUID_BUFFER_SIZE.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param vgpuInstance             Identifier of the target vGPU instance
        ///  * @param uuid                     Pointer to caller-supplied buffer to hold vGPU UUID
        ///  * @param size                     Size of buffer in bytes
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 successful completion
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a vgpuInstance is 0, or \a uuid is NULL
        ///  *         - \ref NVML_ERROR_NOT_FOUND         if \a vgpuInstance does not match a valid active vGPU instance on the system
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE if \a size is too small
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuInstanceGetUUID(nvmlVgpuInstance_t vgpuInstance, char *uuid, unsigned int size);
        /// 
        /// /**
        ///  * Retrieve the NVIDIA driver version installed in the VM associated with a vGPU.
        ///  *
        ///  * The version is returned as an alphanumeric string in the caller-supplied buffer \a version. The length of the version
        ///  * string will not exceed 80 characters in length (including the NUL terminator).
        ///  * See \ref nvmlConstants::NVML_SYSTEM_DRIVER_VERSION_BUFFER_SIZE.
        ///  *
        ///  * nvmlVgpuInstanceGetVmDriverVersion() may be called at any time for a vGPU instance. The guest VM driver version is
        ///  * returned as "Unknown" if no NVIDIA driver is installed in the VM, or the VM has not yet booted to the point where the
        ///  * NVIDIA driver is loaded and initialized.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param vgpuInstance             Identifier of the target vGPU instance
        ///  * @param version                  Caller-supplied buffer to return driver version string
        ///  * @param length                   Size of \a version buffer
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if \a version has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a vgpuInstance is 0
        ///  *         - \ref NVML_ERROR_NOT_FOUND         if \a vgpuInstance does not match a valid active vGPU instance on the system
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE if \a length is too small
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuInstanceGetVmDriverVersion(nvmlVgpuInstance_t vgpuInstance, char* version, unsigned int length);
        /// 
        /// /**
        ///  * Retrieve the framebuffer usage in bytes.
        ///  *
        ///  * Framebuffer usage is the amont of vGPU framebuffer memory that is currently in use by the VM.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param vgpuInstance             The identifier of the target instance
        ///  * @param fbUsage                  Pointer to framebuffer usage in bytes
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 successful completion
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a vgpuInstance is 0, or \a fbUsage is NULL
        ///  *         - \ref NVML_ERROR_NOT_FOUND         if \a vgpuInstance does not match a valid active vGPU instance on the system
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuInstanceGetFbUsage(nvmlVgpuInstance_t vgpuInstance, unsigned long long *fbUsage);
        /// 
        /// /**
        ///  * Retrieve the current licensing state of the vGPU instance.
        ///  *
        ///  * If the vGPU is currently licensed, \a licensed is set to 1, otherwise it is set to 0.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param vgpuInstance             Identifier of the target vGPU instance
        ///  * @param licensed                 Reference to return the licensing status
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if \a licensed has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a vgpuInstance is 0, or \a licensed is NULL
        ///  *         - \ref NVML_ERROR_NOT_FOUND         if \a vgpuInstance does not match a valid active vGPU instance on the system
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuInstanceGetLicenseStatus(nvmlVgpuInstance_t vgpuInstance, unsigned int *licensed);
        /// 
        /// /**
        ///  * Retrieve the vGPU type of a vGPU instance.
        ///  *
        ///  * Returns the vGPU type ID of vgpu assigned to the vGPU instance.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param vgpuInstance             Identifier of the target vGPU instance
        ///  * @param vgpuTypeId               Reference to return the vgpuTypeId
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if \a vgpuTypeId has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a vgpuInstance is 0, or \a vgpuTypeId is NULL
        ///  *         - \ref NVML_ERROR_NOT_FOUND         if \a vgpuInstance does not match a valid active vGPU instance on the system
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuInstanceGetType(nvmlVgpuInstance_t vgpuInstance, nvmlVgpuTypeId_t *vgpuTypeId);
        /// 
        /// /**
        ///  * Retrieve the frame rate limit set for the vGPU instance.
        ///  *
        ///  * Returns the value of the frame rate limit set for the vGPU instance
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param vgpuInstance             Identifier of the target vGPU instance
        ///  * @param frameRateLimit           Reference to return the frame rate limit
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if \a frameRateLimit has been set
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if frame rate limiter is turned off for the vGPU type
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a vgpuInstance is 0, or \a frameRateLimit is NULL
        ///  *         - \ref NVML_ERROR_NOT_FOUND         if \a vgpuInstance does not match a valid active vGPU instance on the system
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuInstanceGetFrameRateLimit(nvmlVgpuInstance_t vgpuInstance, unsigned int *frameRateLimit);
        /// 
        /// /**
        ///  * Retrieve the encoder capacity of a vGPU instance, as a percentage of maximum encoder capacity with valid values in the range 0-100.
        ///  *
        ///  * For Maxwell &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param vgpuInstance             Identifier of the target vGPU instance
        ///  * @param encoderCapacity          Reference to an unsigned int for the encoder capacity
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if \a encoderCapacity has been retrived
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a vgpuInstance is 0, or \a encoderQueryType is invalid
        ///  *         - \ref NVML_ERROR_NOT_FOUND         if \a vgpuInstance does not match a valid active vGPU instance on the system
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuInstanceGetEncoderCapacity(nvmlVgpuInstance_t vgpuInstance, unsigned int *encoderCapacity);
        /// 
        /// /**
        ///  * Set the encoder capacity of a vGPU instance, as a percentage of maximum encoder capacity with valid values in the range 0-100.
        ///  *
        ///  * For Maxwell &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param vgpuInstance             Identifier of the target vGPU instance
        ///  * @param encoderCapacity          Unsigned int for the encoder capacity value
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if \a encoderCapacity has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a vgpuInstance is 0, or \a encoderCapacity is out of range of 0-100.
        ///  *         - \ref NVML_ERROR_NOT_FOUND         if \a vgpuInstance does not match a valid active vGPU instance on the system
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuInstanceSetEncoderCapacity(nvmlVgpuInstance_t vgpuInstance, unsigned int  encoderCapacity);
        /// 
        /// /**
        ///  * Retrieves current utilization for vGPUs on a physical GPU (device).
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * Reads recent utilization of GPU SM (3D/Compute), framebuffer, video encoder, and video decoder for vGPU instances running
        ///  * on a device. Utilization values are returned as an array of utilization sample structures in the caller-supplied buffer
        ///  * pointed at by \a utilizationSamples. One utilization sample structure is returned per vGPU instance, and includes the
        ///  * CPU timestamp at which the samples were recorded. Individual utilization values are returned as "unsigned int" values
        ///  * in nvmlValue_t unions. The function sets the caller-supplied \a sampleValType to NVML_VALUE_TYPE_UNSIGNED_INT to
        ///  * indicate the returned value type.
        ///  *
        ///  * To read utilization values, first determine the size of buffer required to hold the samples by invoking the function with
        ///  * \a utilizationSamples set to NULL. The function will return NVML_ERROR_INSUFFICIENT_SIZE, with the current vGPU instance
        ///  * count in \a vgpuInstanceSamplesCount, or NVML_SUCCESS if the current vGPU instance count is zero. The caller should allocate
        ///  * a buffer of size vgpuInstanceSamplesCount * sizeof(nvmlVgpuInstanceUtilizationSample_t). Invoke the function again with
        ///  * the allocated buffer passed in \a utilizationSamples, and \a vgpuInstanceSamplesCount set to the number of entries the
        ///  * buffer is sized for.
        ///  *
        ///  * On successful return, the function updates \a vgpuInstanceSampleCount with the number of vGPU utilization sample
        ///  * structures that were actually written. This may differ from a previously read value as vGPU instances are created or
        ///  * destroyed.
        ///  *
        ///  * lastSeenTimeStamp represents the CPU timestamp in microseconds at which utilization samples were last read. Set it to 0
        ///  * to read utilization based on all the samples maintained by the driver's internal sample buffer. Set lastSeenTimeStamp
        ///  * to a timeStamp retrieved from a previous query to read utilization since the previous query.
        ///  *
        ///  * @param device                        The identifier for the target device
        ///  * @param lastSeenTimeStamp             Return only samples with timestamp greater than lastSeenTimeStamp.
        ///  * @param sampleValType                 Pointer to caller-supplied buffer to hold the type of returned sample values
        ///  * @param vgpuInstanceSamplesCount      Pointer to caller-supplied array size, and returns number of vGPU instances
        ///  * @param utilizationSamples            Pointer to caller-supplied buffer in which vGPU utilization samples are returned
        /// 
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if utilization samples are successfully retrieved
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, \a vgpuInstanceSamplesCount or \a sampleValType is
        ///  *                                             NULL, or a sample count of 0 is passed with a non-NULL \a utilizationSamples
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE if supplied \a vgpuInstanceSamplesCount is too small to return samples for all
        ///  *                                             vGPU instances currently executing on the device
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if vGPU is not supported by the device
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_NOT_FOUND         if sample entries are not found
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetVgpuUtilization(nvmlDevice_t device, unsigned long long lastSeenTimeStamp,
        ///                                                   nvmlValueType_t *sampleValType, unsigned int *vgpuInstanceSamplesCount,
        ///                                                   nvmlVgpuInstanceUtilizationSample_t *utilizationSamples);
        /// 
        /// /**
        ///  * Retrieves current utilization for processes running on vGPUs on a physical GPU (device).
        ///  *
        ///  * For Maxwell &amp;tm; or newer fully supported devices.
        ///  *
        ///  * Reads recent utilization of GPU SM (3D/Compute), framebuffer, video encoder, and video decoder for processes running on
        ///  * vGPU instances active on a device. Utilization values are returned as an array of utilization sample structures in the
        ///  * caller-supplied buffer pointed at by \a utilizationSamples. One utilization sample structure is returned per process running
        ///  * on vGPU instances, that had some non-zero utilization during the last sample period. It includes the CPU timestamp at which
        ///  * the samples were recorded. Individual utilization values are returned as "unsigned int" values.
        ///  *
        ///  * To read utilization values, first determine the size of buffer required to hold the samples by invoking the function with
        ///  * \a utilizationSamples set to NULL. The function will return NVML_ERROR_INSUFFICIENT_SIZE, with the current vGPU instance
        ///  * count in \a vgpuProcessSamplesCount. The caller should allocate a buffer of size
        ///  * vgpuProcessSamplesCount * sizeof(nvmlVgpuProcessUtilizationSample_t). Invoke the function again with
        ///  * the allocated buffer passed in \a utilizationSamples, and \a vgpuProcessSamplesCount set to the number of entries the
        ///  * buffer is sized for.
        ///  *
        ///  * On successful return, the function updates \a vgpuSubProcessSampleCount with the number of vGPU sub process utilization sample
        ///  * structures that were actually written. This may differ from a previously read value depending on the number of processes that are active
        ///  * in any given sample period.
        ///  *
        ///  * lastSeenTimeStamp represents the CPU timestamp in microseconds at which utilization samples were last read. Set it to 0
        ///  * to read utilization based on all the samples maintained by the driver's internal sample buffer. Set lastSeenTimeStamp
        ///  * to a timeStamp retrieved from a previous query to read utilization since the previous query.
        ///  *
        ///  * @param device                        The identifier for the target device
        ///  * @param lastSeenTimeStamp             Return only samples with timestamp greater than lastSeenTimeStamp.
        ///  * @param vgpuProcessSamplesCount       Pointer to caller-supplied array size, and returns number of processes running on vGPU instances
        ///  * @param utilizationSamples            Pointer to caller-supplied buffer in which vGPU sub process utilization samples are returned
        /// 
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if utilization samples are successfully retrieved
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, \a vgpuProcessSamplesCount or a sample count of 0 is
        ///  *                                             passed with a non-NULL \a utilizationSamples
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE if supplied \a vgpuProcessSamplesCount is too small to return samples for all
        ///  *                                             vGPU instances currently executing on the device
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if vGPU is not supported by the device
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_NOT_FOUND         if sample entries are not found
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetVgpuProcessUtilization(nvmlDevice_t device, unsigned long long lastSeenTimeStamp,
        ///                                                          unsigned int *vgpuProcessSamplesCount,
        ///                                                          nvmlVgpuProcessUtilizationSample_t *utilizationSamples);
        /// /**
        ///  * Retrieve the GRID licensable features.
        ///  *
        ///  * Identifies whether the system supports GRID Software Licensing. If it does, return the list of licensable feature(s)
        ///  * and their current license status.
        ///  *
        ///  * @param device                    Identifier of the target device
        ///  * @param pGridLicensableFeatures   Pointer to structure in which GRID licensable features are returned
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if licensable features are successfully retrieved
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a pGridLicensableFeatures is NULL
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetGridLicensableFeatures(nvmlDevice_t device, nvmlGridLicensableFeatures_t *pGridLicensableFeatures);
        /// 
        /// /**
        ///  * Retrieves the current encoder statistics of a vGPU Instance
        ///  *
        ///  * For Maxwell &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param vgpuInstance                      Identifier of the target vGPU instance
        ///  * @param sessionCount                      Reference to an unsigned int for count of active encoder sessions
        ///  * @param averageFps                        Reference to an unsigned int for trailing average FPS of all active sessions
        ///  * @param averageLatency                    Reference to an unsigned int for encode latency in microseconds
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                  if \a sessionCount, \a averageFps and \a averageLatency is fetched
        ///  *         - \ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT   if \a sessionCount , or \a averageFps or \a averageLatency is NULL
        ///  *                                              or \a vgpuInstance is 0.
        ///  *         - \ref NVML_ERROR_NOT_FOUND          if \a vgpuInstance does not match a valid active vGPU instance on the system
        ///  *         - \ref NVML_ERROR_UNKNOWN            on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuInstanceGetEncoderStats(nvmlVgpuInstance_t vgpuInstance, unsigned int *sessionCount,
        ///                                                      unsigned int *averageFps, unsigned int *averageLatency);
        /// 
        /// /**
        ///  * Retrieves information about all active encoder sessions on a vGPU Instance.
        ///  *
        ///  * An array of active encoder sessions is returned in the caller-supplied buffer pointed at by \a sessionInfo. The
        ///  * array element count is passed in \a sessionCount, and \a sessionCount is used to return the number of sessions
        ///  * written to the buffer.
        ///  *
        ///  * If the supplied buffer is not large enough to accomodate the active session array, the function returns
        ///  * NVML_ERROR_INSUFFICIENT_SIZE, with the element count of nvmlEncoderSessionInfo_t array required in \a sessionCount.
        ///  * To query the number of active encoder sessions, call this function with *sessionCount = 0. The code will return
        ///  * NVML_SUCCESS with number of active encoder sessions updated in *sessionCount.
        ///  *
        ///  * For Maxwell &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param vgpuInstance                      Identifier of the target vGPU instance
        ///  * @param sessionCount                      Reference to caller supplied array size, and returns
        ///  *                                          the number of sessions.
        ///  * @param sessionInfo                       Reference to caller supplied array in which the list
        ///  *                                          of session information us returned.
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                  if \a sessionInfo is fetched
        ///  *         - \ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE  if \a sessionCount is too small, array element count is
        ///                                                 returned in \a sessionCount
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT   if \a sessionCount is NULL, or \a vgpuInstance is 0.
        ///  *         - \ref NVML_ERROR_NOT_FOUND          if \a vgpuInstance does not match a valid active vGPU instance on the system
        ///  *         - \ref NVML_ERROR_UNKNOWN            on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuInstanceGetEncoderSessions(nvmlVgpuInstance_t vgpuInstance, unsigned int *sessionCount, nvmlEncoderSessionInfo_t *sessionInfo);
        /// 
        /// /**
        /// * Retrieves the active frame buffer capture sessions statistics of a vGPU Instance
        /// *
        /// * For Maxwell &amp;tm; or newer fully supported devices.
        /// *
        /// * @param vgpuInstance                      Identifier of the target vGPU instance
        /// * @param fbcStats                          Reference to nvmlFBCStats_t structure contianing NvFBC stats
        /// *
        /// * @return
        /// *         - \ref NVML_SUCCESS                  if \a fbcStats is fetched
        /// *         - \ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized
        /// *         - \ref NVML_ERROR_INVALID_ARGUMENT   if \a vgpuInstance is 0, or \a fbcStats is NULL
        /// *         - \ref NVML_ERROR_NOT_FOUND          if \a vgpuInstance does not match a valid active vGPU instance on the system
        /// *         - \ref NVML_ERROR_UNKNOWN            on any unexpected error
        /// */
        /// nvmlReturn_t DECLDIR nvmlVgpuInstanceGetFBCStats(nvmlVgpuInstance_t vgpuInstance, nvmlFBCStats_t *fbcStats);
        /// 
        /// /**
        /// * Retrieves information about active frame buffer capture sessions on a vGPU Instance.
        /// *
        /// * An array of active FBC sessions is returned in the caller-supplied buffer pointed at by \a sessionInfo. The
        /// * array element count is passed in \a sessionCount, and \a sessionCount is used to return the number of sessions
        /// * written to the buffer.
        /// *
        /// * If the supplied buffer is not large enough to accomodate the active session array, the function returns
        /// * NVML_ERROR_INSUFFICIENT_SIZE, with the element count of nvmlFBCSessionInfo_t array required in \a sessionCount.
        /// * To query the number of active FBC sessions, call this function with *sessionCount = 0.  The code will return
        /// * NVML_SUCCESS with number of active FBC sessions updated in *sessionCount.
        /// *
        /// * For Maxwell &amp;tm; or newer fully supported devices.
        /// *
        /// * @note hResolution, vResolution, averageFPS and averageLatency data for a FBC session returned in \a sessionInfo may
        /// *       be zero if there are no new frames captured since the session started.
        /// *
        /// * @param vgpuInstance                      Identifier of the target vGPU instance
        /// * @param sessionCount                      Reference to caller supplied array size, and returns the number of sessions.
        /// * @param sessionInfo                       Reference in which to return the session information
        /// *
        /// * @return
        /// *         - \ref NVML_SUCCESS                  if \a sessionInfo is fetched
        /// *         - \ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized
        /// *         - \ref NVML_ERROR_INVALID_ARGUMENT   if \a vgpuInstance is 0, or \a sessionCount is NULL.
        /// *         - \ref NVML_ERROR_NOT_FOUND          if \a vgpuInstance does not match a valid active vGPU instance on the system
        /// *         - \ref NVML_ERROR_INSUFFICIENT_SIZE  if \a sessionCount is too small, array element count is returned in \a sessionCount
        /// *         - \ref NVML_ERROR_UNKNOWN            on any unexpected error
        /// */
        /// nvmlReturn_t DECLDIR nvmlVgpuInstanceGetFBCSessions(nvmlVgpuInstance_t vgpuInstance, unsigned int *sessionCount, nvmlFBCSessionInfo_t *sessionInfo);
        /// 
        /// /**
        ///  * Retrieves the current utilization and process ID
        ///  *
        ///  * For Maxwell &amp;tm; or newer fully supported devices.
        ///  *
        ///  * Reads recent utilization of GPU SM (3D/Compute), framebuffer, video encoder, and video decoder for processes running.
        ///  * Utilization values are returned as an array of utilization sample structures in the caller-supplied buffer pointed at
        ///  * by \a utilization. One utilization sample structure is returned per process running, that had some non-zero utilization
        ///  * during the last sample period. It includes the CPU timestamp at which  the samples were recorded. Individual utilization values
        ///  * are returned as "unsigned int" values.
        ///  *
        ///  * To read utilization values, first determine the size of buffer required to hold the samples by invoking the function with
        ///  * \a utilization set to NULL. The caller should allocate a buffer of size
        ///  * processSamplesCount * sizeof(nvmlProcessUtilizationSample_t). Invoke the function again with the allocated buffer passed
        ///  * in \a utilization, and \a processSamplesCount set to the number of entries the buffer is sized for.
        ///  *
        ///  * On successful return, the function updates \a processSamplesCount with the number of process utilization sample
        ///  * structures that were actually written. This may differ from a previously read value as instances are created or
        ///  * destroyed.
        ///  *
        ///  * lastSeenTimeStamp represents the CPU timestamp in microseconds at which utilization samples were last read. Set it to 0
        ///  * to read utilization based on all the samples maintained by the driver's internal sample buffer. Set lastSeenTimeStamp
        ///  * to a timeStamp retrieved from a previous query to read utilization since the previous query.
        ///  *
        ///  * @param device                    The identifier of the target device
        ///  * @param utilization               Pointer to caller-supplied buffer in which guest process utilization samples are returned
        ///  * @param processSamplesCount       Pointer to caller-supplied array size, and returns number of processes running
        ///  * @param lastSeenTimeStamp         Return only samples with timestamp greater than lastSeenTimeStamp.
        /// 
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if \a utilization has been populated
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, \a utilization is NULL, or \a samplingPeriodUs is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetProcessUtilization(nvmlDevice_t device, nvmlProcessUtilizationSample_t *utilization,
        ///                                               unsigned int *processSamplesCount, unsigned long long lastSeenTimeStamp);
        /// 
        /// /**
        ///  * Queries the state of per process accounting mode on vGPU.
        ///  *
        ///  * For Maxwell &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param vgpuInstance            The identifier of the target vGPU VM
        ///  * @param mode                    Reference in which to return the current accounting mode
        ///  *
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if the mode has been successfully retrieved 
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a vgpuInstance is 0, or \a mode is NULL
        ///  *         - \ref NVML_ERROR_NOT_FOUND         if \a vgpuInstance does not match a valid active vGPU instance on the system
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the vGPU doesn't support this feature
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuInstanceGetAccountingMode(nvmlVgpuInstance_t vgpuInstance, nvmlEnableState_t *mode);
        /// 
        /// /**
        ///  * Queries list of processes running on vGPU that can be queried for accounting stats. The list of processes 
        ///  * returned can be in running or terminated state.
        ///  *
        ///  * For Maxwell &amp;tm; or newer fully supported devices.
        ///  * 
        ///  * To just query the maximum number of processes that can be queried, call this function with *count = 0 and
        ///  * pids=NULL. The return code will be NVML_ERROR_INSUFFICIENT_SIZE, or NVML_SUCCESS if list is empty.
        ///  * 
        ///  * For more details see \ref nvmlVgpuInstanceGetAccountingStats.
        ///  *
        ///  * @note In case of PID collision some processes might not be accessible before the circular buffer is full.
        ///  *
        ///  * @param vgpuInstance            The identifier of the target vGPU VM
        ///  * @param count                   Reference in which to provide the \a pids array size, and
        ///  *                                to return the number of elements ready to be queried
        ///  * @param pids                    Reference in which to return list of process ids
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if pids were successfully retrieved
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a vgpuInstance is 0, or \a count is NULL
        ///  *         - \ref NVML_ERROR_NOT_FOUND         if \a vgpuInstance does not match a valid active vGPU instance on the system
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the vGPU doesn't support this feature or accounting mode is disabled
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE if \a count is too small (\a count is set to expected value)
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  *
        ///  * @see nvmlVgpuInstanceGetAccountingPids
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuInstanceGetAccountingPids(nvmlVgpuInstance_t vgpuInstance, unsigned int *count, unsigned int *pids);
        /// 
        /// /**
        ///  * Queries process's accounting stats.
        ///  *
        ///  * For Maxwell &amp;tm; or newer fully supported devices.
        ///  * 
        ///  * Accounting stats capture GPU utilization and other statistics across the lifetime of a process, and
        ///  * can be queried during life time of the process or after its termination.
        ///  * The time field in \ref nvmlAccountingStats_t is reported as 0 during the lifetime of the process and 
        ///  * updated to actual running time after its termination.
        ///  * Accounting stats are kept in a circular buffer, newly created processes overwrite information about old
        ///  * processes.
        ///  *
        ///  * See \ref nvmlAccountingStats_t for description of each returned metric.
        ///  * List of processes that can be queried can be retrieved from \ref nvmlVgpuInstanceGetAccountingPids.
        ///  *
        ///  * @note Accounting Mode needs to be on. See \ref nvmlVgpuInstanceGetAccountingMode.
        ///  * @note Only compute and graphics applications stats can be queried. Monitoring applications stats can't be
        ///  *         queried since they don't contribute to GPU utilization.
        ///  * @note In case of pid collision stats of only the latest process (that terminated last) will be reported
        ///  *
        ///  * @param vgpuInstance            The identifier of the target vGPU VM
        ///  * @param pid                     Process Id of the target process to query stats for
        ///  * @param stats                   Reference in which to return the process's accounting stats
        ///  *
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if stats have been successfully retrieved
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a vgpuInstance is 0, or \a stats is NULL
        ///  *         - \ref NVML_ERROR_NOT_FOUND         if \a vgpuInstance does not match a valid active vGPU instance on the system
        ///  *                                             or \a stats is not found
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the vGPU doesn't support this feature or accounting mode is disabled
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuInstanceGetAccountingStats(nvmlVgpuInstance_t vgpuInstance, unsigned int pid, nvmlAccountingStats_t *stats);
        /// 
        /// /** @} */
        /// 
        /// /***************************************************************************************************/
        /// /** @defgroup nvml vGPU Migration
        ///  * This chapter describes NVML operations that are associated with vGPU Migration.
        ///  *  @{
        ///  */
        /// /***************************************************************************************************/
        /// 
        /// /**
        ///  * Structure representing range of vGPU versions.
        ///  */
        /// typedef struct nvmlVgpuVersion_st
        /// {
        ///     unsigned int minVersion; //!&lt; Minimum vGPU version.
        ///     unsigned int maxVersion; //!&lt; Maximum vGPU version.
        /// } nvmlVgpuVersion_t;
        /// 
        /// /**
        ///  * vGPU metadata structure.
        ///  */
        /// typedef struct nvmlVgpuMetadata_st
        /// {
        ///     unsigned int             version;                                                    //!&lt; Current version of the structure
        ///     unsigned int             revision;                                                   //!&lt; Current revision of the structure
        ///     nvmlVgpuGuestInfoState_t guestInfoState;                                             //!&lt; Current state of Guest-dependent fields
        ///     char                     guestDriverVersion[NVML_SYSTEM_DRIVER_VERSION_BUFFER_SIZE]; //!&lt; Version of driver installed in guest
        ///     char                     hostDriverVersion[NVML_SYSTEM_DRIVER_VERSION_BUFFER_SIZE];  //!&lt; Version of driver installed in host
        ///     unsigned int             reserved[7];                                                //!&lt; Reserved for internal use
        ///     unsigned int             guestVgpuVersion;                                           //!&lt; vGPU version of guest driver
        ///     unsigned int             opaqueDataSize;                                             //!&lt; Size of opaque data field in bytes
        ///     char                     opaqueData[4];                                              //!&lt; Opaque data
        /// } nvmlVgpuMetadata_t;
        /// 
        /// /**
        ///  * Physical GPU metadata structure
        ///  */
        /// typedef struct nvmlVgpuPgpuMetadata_st
        /// {
        ///     unsigned int            version;                                                    //!&lt; Current version of the structure
        ///     unsigned int            revision;                                                   //!&lt; Current revision of the structure
        ///     char                    hostDriverVersion[NVML_SYSTEM_DRIVER_VERSION_BUFFER_SIZE];  //!&lt; Host driver version
        ///     unsigned int            pgpuVirtualizationCaps;                                     //!&lt; Pgpu virtualizaion capabilities bitfileld
        ///     unsigned int            reserved[5];                                                //!&lt; Reserved for internal use
        ///     nvmlVgpuVersion_t       hostSupportedVgpuRange;                                     //!&lt; vGPU version range supported by host driver
        ///     unsigned int            opaqueDataSize;                                             //!&lt; Size of opaque data field in bytes
        ///     char                    opaqueData[4];                                              //!&lt; Opaque data
        /// } nvmlVgpuPgpuMetadata_t;
        /// 
        /// /**
        ///  * vGPU VM compatibility codes
        ///  */
        /// typedef enum nvmlVgpuVmCompatibility_enum
        /// {
        ///     NVML_VGPU_VM_COMPATIBILITY_NONE         = 0x0,    //!&lt; vGPU is not runnable
        ///     NVML_VGPU_VM_COMPATIBILITY_COLD         = 0x1,    //!&lt; vGPU is runnable from a cold / powered-off state (ACPI S5)
        ///     NVML_VGPU_VM_COMPATIBILITY_HIBERNATE    = 0x2,    //!&lt; vGPU is runnable from a hibernated state (ACPI S4)
        ///     NVML_VGPU_VM_COMPATIBILITY_SLEEP        = 0x4,    //!&lt; vGPU is runnable from a sleeped state (ACPI S3)
        ///     NVML_VGPU_VM_COMPATIBILITY_LIVE         = 0x8,    //!&lt; vGPU is runnable from a live/paused (ACPI S0)
        /// } nvmlVgpuVmCompatibility_t;
        /// 
        /// /**
        ///  *  vGPU-pGPU compatibility limit codes
        ///  */
        /// typedef enum nvmlVgpuPgpuCompatibilityLimitCode_enum
        /// {
        ///     NVML_VGPU_COMPATIBILITY_LIMIT_NONE          = 0x0,           //!&lt; Compatibility is not limited.
        ///     NVML_VGPU_COMPATIBILITY_LIMIT_HOST_DRIVER   = 0x1,           //!&lt; ompatibility is limited by host driver version.
        ///     NVML_VGPU_COMPATIBILITY_LIMIT_GUEST_DRIVER  = 0x2,           //!&lt; Compatibility is limited by guest driver version.
        ///     NVML_VGPU_COMPATIBILITY_LIMIT_GPU           = 0x4,           //!&lt; Compatibility is limited by GPU hardware.
        ///     NVML_VGPU_COMPATIBILITY_LIMIT_OTHER         = 0x80000000,    //!&lt; Compatibility is limited by an undefined factor.
        /// } nvmlVgpuPgpuCompatibilityLimitCode_t;
        /// 
        /// /**
        ///  * vGPU-pGPU compatibility structure
        ///  */
        /// typedef struct nvmlVgpuPgpuCompatibility_st
        /// {
        ///     nvmlVgpuVmCompatibility_t               vgpuVmCompatibility;    //!&lt; Compatibility of vGPU VM. See \ref nvmlVgpuVmCompatibility_t
        ///     nvmlVgpuPgpuCompatibilityLimitCode_t    compatibilityLimitCode; //!&lt; Limiting factor for vGPU-pGPU compatibility. See \ref nvmlVgpuPgpuCompatibilityLimitCode_t
        /// } nvmlVgpuPgpuCompatibility_t;
        /// 
        /// /**
        ///  * Returns vGPU metadata structure for a running vGPU. The structure contains information about the vGPU and its associated VM
        ///  * such as the currently installed NVIDIA guest driver version, together with host driver version and an opaque data section
        ///  * containing internal state.
        ///  *
        ///  * nvmlVgpuInstanceGetMetadata() may be called at any time for a vGPU instance. Some fields in the returned structure are
        ///  * dependent on information obtained from the guest VM, which may not yet have reached a state where that information
        ///  * is available. The current state of these dependent fields is reflected in the info structure's \ref nvmlVgpuGuestInfoState_t field.
        ///  *
        ///  * The VMM may choose to read and save the vGPU's VM info as persistent metadata associated with the VM, and provide
        ///  * it to GRID Virtual GPU Manager when creating a vGPU for subsequent instances of the VM.
        ///  *
        ///  * The caller passes in a buffer via \a vgpuMetadata, with the size of the buffer in \a bufferSize. If the vGPU Metadata structure
        ///  * is too large to fit in the supplied buffer, the function returns NVML_ERROR_INSUFFICIENT_SIZE with the size needed
        ///  * in \a bufferSize.
        ///  *
        ///  * @param vgpuInstance             vGPU instance handle
        ///  * @param vgpuMetadata             Pointer to caller-supplied buffer into which vGPU metadata is written
        ///  * @param bufferSize               Size of vgpuMetadata buffer
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                   vGPU metadata structure was successfully returned
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE   vgpuMetadata buffer is too small, required size is returned in \a bufferSize
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT    if \a bufferSize is NULL or \a vgpuInstance is 0; if \a vgpuMetadata is NULL and the value of \a bufferSize is not 0.
        ///  *         - \ref NVML_ERROR_NOT_FOUND           if \a vgpuInstance does not match a valid active vGPU instance on the system
        ///  *         - \ref NVML_ERROR_UNKNOWN             on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuInstanceGetMetadata(nvmlVgpuInstance_t vgpuInstance, nvmlVgpuMetadata_t *vgpuMetadata, unsigned int *bufferSize);
        /// 
        /// /**
        ///  * Returns a vGPU metadata structure for the physical GPU indicated by \a device. The structure contains information about
        ///  * the GPU and the currently installed NVIDIA host driver version that's controlling it, together with an opaque data section
        ///  * containing internal state.
        ///  *
        ///  * The caller passes in a buffer via \a pgpuMetadata, with the size of the buffer in \a bufferSize. If the \a pgpuMetadata
        ///  * structure is too large to fit in the supplied buffer, the function returns NVML_ERROR_INSUFFICIENT_SIZE with the size needed
        ///  * in \a bufferSize.
        ///  *
        ///  * @param device                The identifier of the target device
        ///  * @param pgpuMetadata          Pointer to caller-supplied buffer into which \a pgpuMetadata is written
        ///  * @param bufferSize            Pointer to size of \a pgpuMetadata buffer
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                   GPU metadata structure was successfully returned
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE   pgpuMetadata buffer is too small, required size is returned in \a bufferSize
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT    if \a bufferSize is NULL or \a device is invalid; if \a pgpuMetadata is NULL and the value of \a bufferSize is not 0.
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED       vGPU is not supported by the system
        ///  *         - \ref NVML_ERROR_UNKNOWN             on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetVgpuMetadata(nvmlDevice_t device, nvmlVgpuPgpuMetadata_t *pgpuMetadata, unsigned int *bufferSize);
        /// 
        /// /**
        ///  * Takes a vGPU instance metadata structure read from \ref nvmlVgpuInstanceGetMetadata(), and a vGPU metadata structure for a
        ///  * physical GPU read from \ref nvmlDeviceGetVgpuMetadata(), and returns compatibility information of the vGPU instance and the
        ///  * physical GPU.
        ///  *
        ///  * The caller passes in a buffer via \a compatibilityInfo, into which a compatibility information structure is written. The
        ///  * structure defines the states in which the vGPU / VM may be booted on the physical GPU. If the vGPU / VM compatibility
        ///  * with the physical GPU is limited, a limit code indicates the factor limiting compability.
        ///  * (see \ref nvmlVgpuPgpuCompatibilityLimitCode_t for details).
        ///  *
        ///  * Note: vGPU compatibility does not take into account dynamic capacity conditions that may limit a system's ability to
        ///  *       boot a given vGPU or associated VM.
        ///  *
        ///  * @param vgpuMetadata          Pointer to caller-supplied vGPU metadata structure
        ///  * @param pgpuMetadata          Pointer to caller-supplied GPU metadata structure
        ///  * @param compatibilityInfo     Pointer to caller-supplied buffer to hold compatibility info
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                   vGPU metadata structure was successfully returned
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT    if \a vgpuMetadata or \a pgpuMetadata or \a bufferSize are NULL
        ///  *         - \ref NVML_ERROR_UNKNOWN             on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlGetVgpuCompatibility(nvmlVgpuMetadata_t *vgpuMetadata, nvmlVgpuPgpuMetadata_t *pgpuMetadata, nvmlVgpuPgpuCompatibility_t *compatibilityInfo);
        /// 
        /// /*
        ///  * Virtual GPU (vGPU) version
        ///  *
        ///  * The NVIDIA vGPU Manager and the guest drivers are tagged with a range of supported vGPU versions. This determines the range of NVIDIA guest driver versions that
        ///  * are compatible for vGPU feature support with a given NVIDIA vGPU Manager. For vGPU feature support, the range of supported versions for the NVIDIA vGPU Manager 
        ///  * and the guest driver must overlap. Otherwise, the guest driver fails to load in the VM.
        ///  *
        ///  * When the NVIDIA guest driver loads, either when the VM is booted or when the driver is installed or upgraded, a negotiation occurs between the guest driver
        ///  * and the NVIDIA vGPU Manager to select the highest mutually compatible vGPU version. The negotiated vGPU version stays the same across VM migration.
        ///  */
        /// 
        /// /**
        ///  * Query the ranges of supported vGPU versions.
        ///  *
        ///  * This function gets the linear range of supported vGPU versions that is preset for the NVIDIA vGPU Manager and the range set by an administrator.
        ///  * If the preset range has not been overridden by \ref nvmlSetVgpuVersion, both ranges are the same.
        ///  *
        ///  * The caller passes pointers to the following \ref nvmlVgpuVersion_t structures, into which the NVIDIA vGPU Manager writes the ranges:
        ///  * 1. \a supported structure that represents the preset range of vGPU versions supported by the NVIDIA vGPU Manager.
        ///  * 2. \a current structure that represents the range of supported vGPU versions set by an administrator. By default, this range is the same as the preset range.
        ///  *
        ///  * @param supported  Pointer to the structure in which the preset range of vGPU versions supported by the NVIDIA vGPU Manager is written
        ///  * @param current    Pointer to the structure in which the range of supported vGPU versions set by an administrator is written
        ///  *
        ///  * @return
        ///  * - \ref NVML_SUCCESS                 The vGPU version range structures were successfully obtained.
        ///  * - \ref NVML_ERROR_NOT_SUPPORTED     The API is not supported.
        ///  * - \ref NVML_ERROR_INVALID_ARGUMENT  The \a supported parameter or the \a current parameter is NULL.
        ///  * - \ref NVML_ERROR_UNKNOWN           An error occurred while the data was being fetched.
        ///  */
        /// nvmlReturn_t DECLDIR nvmlGetVgpuVersion(nvmlVgpuVersion_t *supported, nvmlVgpuVersion_t *current);
        /// 
        /// /**
        ///  * Override the preset range of vGPU versions supported by the NVIDIA vGPU Manager with a range set by an administrator.
        ///  *
        ///  * This function configures the NVIDIA vGPU Manager with a range of supported vGPU versions set by an administrator. This range must be a subset of the
        ///  * preset range that the NVIDIA vGPU Manager supports. The custom range set by an administrator takes precedence over the preset range and is advertised to
        ///  * the guest VM for negotiating the vGPU version. See \ref nvmlGetVgpuVersion for details of how to query the preset range of versions supported.
        ///  *
        ///  * This function takes a pointer to vGPU version range structure \ref nvmlVgpuVersion_t as input to override the preset vGPU version range that the NVIDIA vGPU Manager supports.
        ///  *
        ///  * After host system reboot or driver reload, the range of supported versions reverts to the range that is preset for the NVIDIA vGPU Manager.
        ///  *
        ///  * @note 1. The range set by the administrator must be a subset of the preset range that the NVIDIA vGPU Manager supports. Otherwise, an error is returned.
        ///  *       2. If the range of supported guest driver versions does not overlap the range set by the administrator, the guest driver fails to load.
        ///  *       3. If the range of supported guest driver versions overlaps the range set by the administrator, the guest driver will load with a negotiated 
        ///  *          vGPU version that is the maximum value in the overlapping range.
        ///  *       4. No VMs must be running on the host when this function is called. If a VM is running on the host, the call to this function fails.
        ///  *
        ///  * @param vgpuVersion   Pointer to a caller-supplied range of supported vGPU versions.
        ///  *
        ///  * @return
        ///  * - \ref NVML_SUCCESS                 The preset range of supported vGPU versions was successfully overridden.
        ///  * - \ref NVML_ERROR_NOT_SUPPORTED     The API is not supported.
        ///  * - \ref NVML_ERROR_IN_USE            The range was not overridden because a VM is running on the host.
        ///  * - \ref NVML_ERROR_INVALID_ARGUMENT  The \a vgpuVersion parameter specifies a range that is outside the range supported by the NVIDIA vGPU Manager or if \a vgpuVersion is NULL.
        ///  */
        /// nvmlReturn_t DECLDIR nvmlSetVgpuVersion(nvmlVgpuVersion_t *vgpuVersion);
        /// 
        /// /** @} */
        /// 
        /// /***************************************************************************************************/
        /// /** @defgroup nvmlGpuBlacklistQueries GPU Blacklist Queries
        ///  * This chapter describes NVML operations that are associated with blacklisted GPUs.
        ///  *  @{
        ///  */
        /// /***************************************************************************************************/
        /// 
        /// /**
        ///  * Blacklist GPU device information
        ///  **/
        /// typedef struct nvmlBlacklistDeviceInfo_st
        /// {
        ///     nvmlPciInfo_t pciInfo;                   //!&lt; The PCI information for the blacklisted GPU
        ///     char uuid[NVML_DEVICE_UUID_BUFFER_SIZE]; //!&lt; The ASCII string UUID for the blacklisted GPU
        /// } nvmlBlacklistDeviceInfo_t;
        /// 
        ///  /**
        ///  * Retrieves the number of blacklisted GPU devices in the system.
        ///  * 
        ///  * For all products.
        ///  *
        ///  * @param deviceCount                          Reference in which to return the number of blacklisted devices
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a deviceCount has been set
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a deviceCount is NULL
        ///  */
        /// nvmlReturn_t DECLDIR nvmlGetBlacklistDeviceCount(unsigned int *deviceCount);
        /// 
        /// /**
        ///  * Acquire the device information for a blacklisted device, based on its index.
        ///  * 
        ///  * For all products.
        ///  *
        ///  * Valid indices are derived from the \a deviceCount returned by 
        ///  *   \ref nvmlGetBlacklistDeviceCount(). For example, if \a deviceCount is 2 the valid indices  
        ///  *   are 0 and 1, corresponding to GPU 0 and GPU 1.
        ///  *
        ///  * @param index                                The index of the target GPU, &gt;= 0 and &lt; \a deviceCount
        ///  * @param info                                 Reference in which to return the device information
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                  if \a device has been set
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT   if \a index is invalid or \a info is NULL
        ///  *
        ///  * @see nvmlGetBlacklistDeviceCount
        ///  */
        /// nvmlReturn_t DECLDIR nvmlGetBlacklistDeviceInfoByIndex(unsigned int index, nvmlBlacklistDeviceInfo_t *info);
        /// 
        /// /** @} */
        /// 
        /// /**
        ///  * NVML API versioning support
        ///  */
        /// #if defined(__NVML_API_VERSION_INTERNAL)
        /// #undef nvmlDeviceGetGridLicensableFeatures
        /// #undef nvmlDeviceRemoveGpu
        /// #undef nvmlDeviceGetNvLinkRemotePciInfo
        /// #undef nvmlDeviceGetPciInfo
        /// #undef nvmlDeviceGetCount
        /// #undef nvmlDeviceGetHandleByIndex
        /// #undef nvmlDeviceGetHandleByPciBusId
        /// #undef nvmlInit
        /// #endif
        /// 
        /// #ifdef __cplusplus
        /// }
        /// #endif
        /// 
        /// #endifnvmlConstants::NVML_DEVICE_NAME_BUFFER_SIZE. NVML_SUCCESS                 if \a name has been set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, or \a name is NULL- NVML_ERROR_INSUFFICIENT_SIZE if \a length is too small- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetName(nvmlDevice_st device, IntPtr name, uint length);
        
        /// <summary>
        /// Retrieves the brand of this device.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="type">Reference in which to return the product brand type</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For all products.The type is a member of nvmlBrandType_t defined above. NVML_SUCCESS                 if \a name has been set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, or \a type is NULL- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetBrand(nvmlDevice_st device, ref nvmlBrandType_enum type);
        
        /// <summary>
        /// Retrieves the NVML index of this device.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="index">Reference in which to return the NVML index of the device</param>
        /// <returns>-</returns>
        /// <seealso cref="nvmlDeviceGetHandleByIndex()"/>
        /// 
        /// <seealso cref="nvmlDeviceGetCount()"/>
        /// 
        /// <remarks>
        /// For all products.Valid indices are derived from the @a accessibleDevices count returned by nvmlDeviceGetCount(). For example, if \a accessibleDevices is 2 the valid indicesare 0 and 1, corresponding to GPU 0 and GPU 1.The order in which NVML enumerates devices has no guarantees of consistency between reboots. For that reason it
        /// is recommended that devices be looked up by their PCI ids or GPU UUID. See nvmlDeviceGetHandleByPciBusId() and \ref nvmlDeviceGetHandleByUUID().Note: The NVML index may not correlate with other APIs, such as the CUDA device index. NVML_SUCCESS                 if \a index has been set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, or \a index is NULL- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetIndex(nvmlDevice_st device, ref uint index);
        
        /// <summary>
        /// Retrieves the globally unique board serial number associated with this device's board.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="serial">Reference in which to return the board/module serial number</param>
        /// <param name="length">The maximum allowed length of the string returned in @a serial</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For all products with an inforom.The serial number is an alphanumeric string that will not exceed 30 characters (including the NULL terminator).
        /// This number matches the serial number tag that is physically attached to the board.  See
        ///  * nvmlConstants::NVML_DEVICE_SERIAL_BUFFER_SIZE.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param serial                               Reference in which to return the board/module serial number
        ///  * @param length                               The maximum allowed length of the string returned in \a serial
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a serial has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, or \a serial is NULL
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE if \a length is too small
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetSerial(nvmlDevice_t device, char *serial, unsigned int length);
        /// 
        /// /**
        ///  * Retrieves an array of unsigned ints (sized to cpuSetSize) of bitmasks with the ideal CPU affinity for the device
        ///  * For example, if processors 0, 1, 32, and 33 are ideal for the device and cpuSetSize == 2,
        ///  *     result[0] = 0x3, result[1] = 0x3
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  * Supported on Linux only.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param cpuSetSize                           The size of the cpuSet array that is safe to access
        ///  * @param cpuSet                               Array reference in which to return a bitmask of CPUs, 64 CPUs per 
        ///  *                                                 unsigned long on 64-bit machines, 32 on 32-bit machines
        ///  *
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a cpuAffinity has been filled
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, cpuSetSize == 0, or cpuSet is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetCpuAffinity(nvmlDevice_t device, unsigned int cpuSetSize, unsigned long *cpuSet);
        /// 
        /// /**
        ///  * Sets the ideal affinity for the calling thread and device using the guidelines 
        ///  * given in nvmlDeviceGetCpuAffinity().  Note, this is a change as of version 8.0.  
        ///  * Older versions set the affinity for a calling process and all children.
        ///  * Currently supports up to 64 processors.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  * Supported on Linux only.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  *
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if the calling process has been successfully bound
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceSetCpuAffinity(nvmlDevice_t device);
        /// 
        /// /**
        ///  * Clear all affinity bindings for the calling thread.  Note, this is a change as of version
        ///  * 8.0 as older versions cleared the affinity for a calling process and all children.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  * Supported on Linux only.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  *
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if the calling process has been successfully unbound
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceClearCpuAffinity(nvmlDevice_t device);
        /// 
        /// /**
        ///  * Retrieve the common ancestor for two devices
        ///  * For all products.
        ///  * Supported on Linux only.
        ///  *
        ///  * @param device1                              The identifier of the first device
        ///  * @param device2                              The identifier of the second device
        ///  * @param pathInfo                             A \ref nvmlGpuTopologyLevel_t that gives the path type
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if \a pathInfo has been set
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device1, or \a device2 is invalid, or \a pathInfo is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device or OS does not support this feature
        ///  *         - \ref NVML_ERROR_UNKNOWN           an error has occurred in underlying topology discovery
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetTopologyCommonAncestor(nvmlDevice_t device1, nvmlDevice_t device2, nvmlGpuTopologyLevel_t *pathInfo);
        /// 
        /// /**
        ///  * Retrieve the set of GPUs that are nearest to a given device at a specific interconnectivity level
        ///  * For all products.
        ///  * Supported on Linux only.
        ///  *
        ///  * @param device                               The identifier of the first device
        ///  * @param level                                The \ref nvmlGpuTopologyLevel_t level to search for other GPUs
        ///  * @param count                                When zero, is set to the number of matching GPUs such that \a deviceArray 
        ///  *                                             can be malloc'd.  When non-zero, \a deviceArray will be filled with \a count
        ///  *                                             number of device handles.
        ///  * @param deviceArray                          An array of device handles for GPUs found at \a level
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if \a deviceArray or \a count (if initially zero) has been set
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device, \a level, or \a count is invalid, or \a deviceArray is NULL with a non-zero \a count
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device or OS does not support this feature
        ///  *         - \ref NVML_ERROR_UNKNOWN           an error has occurred in underlying topology discovery
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetTopologyNearestGpus(nvmlDevice_t device, nvmlGpuTopologyLevel_t level, unsigned int *count, nvmlDevice_t *deviceArray);
        /// 
        /// /**
        ///  * Retrieve the set of GPUs that have a CPU affinity with the given CPU number
        ///  * For all products.
        ///  * Supported on Linux only.
        ///  *
        ///  * @param cpuNumber                            The CPU number
        ///  * @param count                                When zero, is set to the number of matching GPUs such that \a deviceArray 
        ///  *                                             can be malloc'd.  When non-zero, \a deviceArray will be filled with \a count
        ///  *                                             number of device handles.
        ///  * @param deviceArray                          An array of device handles for GPUs found with affinity to \a cpuNumber
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if \a deviceArray or \a count (if initially zero) has been set
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a cpuNumber, or \a count is invalid, or \a deviceArray is NULL with a non-zero \a count
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device or OS does not support this feature
        ///  *         - \ref NVML_ERROR_UNKNOWN           an error has occurred in underlying topology discovery
        ///  */
        /// nvmlReturn_t DECLDIR nvmlSystemGetTopologyGpuSet(unsigned int cpuNumber, unsigned int *count, nvmlDevice_t *deviceArray);
        /// 
        /// /**
        ///  * Retrieve the status for a given p2p capability index between a given pair of GPU 
        ///  * 
        ///  * @param device1                              The first device 
        ///  * @param device2                              The second device
        ///  * @param p2pIndex                             p2p Capability Index being looked for between \a device1 and \a device2
        ///  * @param p2pStatus                            Reference in which to return the status of the \a p2pIndex
        ///  *                                             between \a device1 and \a device2
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS         if \a p2pStatus has been populated
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT     if \a device1 or \a device2 or \a p2pIndex is invalid or \a p2pStatus is NULL
        ///  *         - \ref NVML_ERROR_UNKNOWN              on any unexpected error
        ///  */ 
        /// nvmlReturn_t DECLDIR nvmlDeviceGetP2PStatus(nvmlDevice_t device1, nvmlDevice_t device2, nvmlGpuP2PCapsIndex_t p2pIndex,nvmlGpuP2PStatus_t *p2pStatus);
        /// 
        /// /**
        ///  * Retrieves the globally unique immutable UUID associated with this device, as a 5 part hexadecimal string,
        ///  * that augments the immutable, board serial identifier.
        ///  *
        ///  * For all products.
        ///  *
        ///  * The UUID is a globally unique identifier. It is the only available identifier for pre-Fermi-architecture products.
        ///  * It does NOT correspond to any identifier printed on the board.  It will not exceed 80 characters in length
        ///  * (including the NULL terminator).  See \ref nvmlConstants::NVML_DEVICE_UUID_BUFFER_SIZE.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param uuid                                 Reference in which to return the GPU UUID
        ///  * @param length                               The maximum allowed length of the string returned in \a uuid
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a uuid has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, or \a uuid is NULL
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE if \a length is too small 
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetUUID(nvmlDevice_t device, char *uuid, unsigned int length);
        /// 
        /// /**
        ///  * Retrieves minor number for the device. The minor number for the device is such that the Nvidia device node file for 
        ///  * each GPU will have the form /dev/nvidia[minor number].
        ///  *
        ///  * For all products.
        ///  * Supported only for Linux
        ///  *
        ///  * @param device                                The identifier of the target device
        ///  * @param minorNumber                           Reference in which to return the minor number for the device
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if the minor number is successfully retrieved
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a minorNumber is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if this query is not supported by the device
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetMinorNumber(nvmlDevice_t device, unsigned int *minorNumber);
        /// 
        /// /**
        ///  * Retrieves the the device board part number which is programmed into the board's InfoROM
        ///  *
        ///  * For all products.
        ///  *
        ///  * @param device                                Identifier of the target device
        ///  * @param partNumber                            Reference to the buffer to return
        ///  * @param length                                Length of the buffer reference
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                  if \a partNumber has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED      if the needed VBIOS fields have not been filled
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT   if \a device is invalid or \a serial is NULL
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST        if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN            on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetBoardPartNumber(nvmlDevice_t device, char* partNumber, unsigned int length);
        /// 
        /// /**
        ///  * Retrieves the version information for the device's infoROM object.
        ///  *
        ///  * For all products with an inforom.
        ///  *
        ///  * Fermi and higher parts have non-volatile on-board memory for persisting device info, such as aggregate 
        ///  * ECC counts. The version of the data structures in this memory may change from time to time. It will not
        ///  * exceed 16 characters in length (including the NULL terminator).
        ///  * See \ref nvmlConstants::NVML_DEVICE_INFOROM_VERSION_BUFFER_SIZE.
        ///  *
        ///  * See \ref nvmlInforomObject_t for details on the available infoROM objects.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param object                               The target infoROM object
        ///  * @param version                              Reference in which to return the infoROM version
        ///  * @param length                               The maximum allowed length of the string returned in \a version
        ///  *
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a version has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a version is NULL
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE if \a length is too small 
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not have an infoROM
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  *
        ///  * @see nvmlDeviceGetInforomImageVersion
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetInforomVersion(nvmlDevice_t device, nvmlInforomObject_t object, char *version, unsigned int length);
        /// 
        /// /**
        ///  * Retrieves the global infoROM image version
        ///  *
        ///  * For all products with an inforom.
        ///  *
        ///  * Image version just like VBIOS version uniquely describes the exact version of the infoROM flashed on the board 
        ///  * in contrast to infoROM object version which is only an indicator of supported features.
        ///  * Version string will not exceed 16 characters in length (including the NULL terminator).
        ///  * See \ref nvmlConstants::NVML_DEVICE_INFOROM_VERSION_BUFFER_SIZE.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param version                              Reference in which to return the infoROM image version
        ///  * @param length                               The maximum allowed length of the string returned in \a version
        ///  *
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a version has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a version is NULL
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE if \a length is too small 
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not have an infoROM
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  *
        ///  * @see nvmlDeviceGetInforomVersion
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetInforomImageVersion(nvmlDevice_t device, char *version, unsigned int length);
        /// 
        /// /**
        ///  * Retrieves the checksum of the configuration stored in the device's infoROM.
        ///  *
        ///  * For all products with an inforom.
        ///  *
        ///  * Can be used to make sure that two GPUs have the exact same configuration.
        ///  * Current checksum takes into account configuration stored in PWR and ECC infoROM objects.
        ///  * Checksum can change between driver releases or when user changes configuration (e.g. disable/enable ECC)
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param checksum                             Reference in which to return the infoROM configuration checksum
        ///  *
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a checksum has been set
        ///  *         - \ref NVML_ERROR_CORRUPTED_INFOROM if the device's checksum couldn't be retrieved due to infoROM corruption
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a checksum is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error 
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetInforomConfigurationChecksum(nvmlDevice_t device, unsigned int *checksum);
        /// 
        /// /**
        ///  * Reads the infoROM from the flash and verifies the checksums.
        ///  *
        ///  * For all products with an inforom.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  *
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if infoROM is not corrupted
        ///  *         - \ref NVML_ERROR_CORRUPTED_INFOROM if the device's infoROM is corrupted
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error 
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceValidateInforom(nvmlDevice_t device);
        /// 
        /// /**
        ///  * Retrieves the display mode for the device.
        ///  *
        ///  * For all products.
        ///  *
        ///  * This method indicates whether a physical display (e.g. monitor) is currently connected to
        ///  * any of the device's connectors.
        ///  *
        ///  * See \ref nvmlEnableState_t for details on allowed modes.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param display                              Reference in which to return the display mode
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a display has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a display is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetDisplayMode(nvmlDevice_t device, nvmlEnableState_t *display);
        /// 
        /// /**
        ///  * Retrieves the display active state for the device.
        ///  *
        ///  * For all products.
        ///  *
        ///  * This method indicates whether a display is initialized on the device.
        ///  * For example whether X Server is attached to this device and has allocated memory for the screen.
        ///  *
        ///  * Display can be active even when no monitor is physically attached.
        ///  *
        ///  * See \ref nvmlEnableState_t for details on allowed modes.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param isActive                             Reference in which to return the display active state
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a isActive has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a isActive is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetDisplayActive(nvmlDevice_t device, nvmlEnableState_t *isActive);
        /// 
        /// /**
        ///  * Retrieves the persistence mode associated with this device.
        ///  *
        ///  * For all products.
        ///  * For Linux only.
        ///  *
        ///  * When driver persistence mode is enabled the driver software state is not torn down when the last 
        ///  * client disconnects. By default this feature is disabled. 
        ///  *
        ///  * See \ref nvmlEnableState_t for details on allowed modes.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param mode                                 Reference in which to return the current driver persistence mode
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a mode has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a mode is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  *
        ///  * @see nvmlDeviceSetPersistenceMode()
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetPersistenceMode(nvmlDevice_t device, nvmlEnableState_t *mode);
        /// 
        /// /**
        ///  * Retrieves the PCI attributes of this device.
        ///  * 
        ///  * For all products.
        ///  *
        ///  * See \ref nvmlPciInfo_t for details on the available PCI info.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param pci                                  Reference in which to return the PCI info
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a pci has been populated
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a pci is NULL
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetPciInfo(nvmlDevice_t device, nvmlPciInfo_t *pci);
        /// 
        /// /**
        ///  * Retrieves the maximum PCIe link generation possible with this device and system
        ///  *
        ///  * I.E. for a generation 2 PCIe device attached to a generation 1 PCIe bus the max link generation this function will
        ///  * report is generation 1.
        ///  * 
        ///  * For Fermi &amp;tm; or newer fully supported devices.
        ///  * 
        ///  * @param device                               The identifier of the target device
        ///  * @param maxLinkGen                           Reference in which to return the max PCIe link generation
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a maxLinkGen has been populated
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a maxLinkGen is null
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if PCIe link information is not available
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetMaxPcieLinkGeneration(nvmlDevice_t device, unsigned int *maxLinkGen);
        /// 
        /// /**
        ///  * Retrieves the maximum PCIe link width possible with this device and system
        ///  *
        ///  * I.E. for a device with a 16x PCIe bus width attached to a 8x PCIe system bus this function will report
        ///  * a max link width of 8.
        ///  * 
        ///  * For Fermi &amp;tm; or newer fully supported devices.
        ///  * 
        ///  * @param device                               The identifier of the target device
        ///  * @param maxLinkWidth                         Reference in which to return the max PCIe link generation
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a maxLinkWidth has been populated
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a maxLinkWidth is null
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if PCIe link information is not available
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetMaxPcieLinkWidth(nvmlDevice_t device, unsigned int *maxLinkWidth);
        /// 
        /// /**
        ///  * Retrieves the current PCIe link generation
        ///  * 
        ///  * For Fermi &amp;tm; or newer fully supported devices.
        ///  * 
        ///  * @param device                               The identifier of the target device
        ///  * @param currLinkGen                          Reference in which to return the current PCIe link generation
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a currLinkGen has been populated
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a currLinkGen is null
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if PCIe link information is not available
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetCurrPcieLinkGeneration(nvmlDevice_t device, unsigned int *currLinkGen);
        /// 
        /// /**
        ///  * Retrieves the current PCIe link width
        ///  * 
        ///  * For Fermi &amp;tm; or newer fully supported devices.
        ///  * 
        ///  * @param device                               The identifier of the target device
        ///  * @param currLinkWidth                        Reference in which to return the current PCIe link generation
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a currLinkWidth has been populated
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a currLinkWidth is null
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if PCIe link information is not available
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetCurrPcieLinkWidth(nvmlDevice_t device, unsigned int *currLinkWidth);
        /// 
        /// /**
        ///  * Retrieve PCIe utilization information.
        ///  * This function is querying a byte counter over a 20ms interval and thus is the 
        ///  *   PCIe throughput over that interval.
        ///  *
        ///  * For Maxwell &amp;tm; or newer fully supported devices.
        ///  *
        ///  * This method is not supported in virtual machines running virtual GPU (vGPU).
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param counter                              The specific counter that should be queried \ref nvmlPcieUtilCounter_t
        ///  * @param value                                Reference in which to return throughput in KB/s
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if \a value has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device or \a counter is invalid, or \a value is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetPcieThroughput(nvmlDevice_t device, nvmlPcieUtilCounter_t counter, unsigned int *value);
        /// 
        /// /**  
        ///  * Retrieve the PCIe replay counter.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param value                                Reference in which to return the counter's value
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if \a value has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, or \a value is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetPcieReplayCounter(nvmlDevice_t device, unsigned int *value);
        /// 
        /// /**
        ///  * Retrieves the current clock speeds for the device.
        ///  *
        ///  * For Fermi &amp;tm; or newer fully supported devices.
        ///  *
        ///  * See \ref nvmlClockType_t for details on available clock information.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param type                                 Identify which clock domain to query
        ///  * @param clock                                Reference in which to return the clock speed in MHz
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a clock has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a clock is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device cannot report the specified clock
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetClockInfo(nvmlDevice_t device, nvmlClockType_t type, unsigned int *clock);
        /// 
        /// /**
        ///  * Retrieves the maximum clock speeds for the device.
        ///  *
        ///  * For Fermi &amp;tm; or newer fully supported devices.
        ///  *
        ///  * See \ref nvmlClockType_t for details on available clock information.
        ///  *
        ///  * \note On GPUs from Fermi family current P0 clocks (reported by \ref nvmlDeviceGetClockInfo) can differ from max clocks
        ///  *       by few MHz.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param type                                 Identify which clock domain to query
        ///  * @param clock                                Reference in which to return the clock speed in MHz
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a clock has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a clock is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device cannot report the specified clock
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetMaxClockInfo(nvmlDevice_t device, nvmlClockType_t type, unsigned int *clock);
        /// 
        /// /**
        ///  * Retrieves the current setting of a clock that applications will use unless an overspec situation occurs.
        ///  * Can be changed using \ref nvmlDeviceSetApplicationsClocks.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param clockType                            Identify which clock domain to query
        ///  * @param clockMHz                             Reference in which to return the clock in MHz
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a clockMHz has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a clockMHz is NULL or \a clockType is invalid
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetApplicationsClock(nvmlDevice_t device, nvmlClockType_t clockType, unsigned int *clockMHz);
        /// 
        /// /**
        ///  * Retrieves the default applications clock that GPU boots with or 
        ///  * defaults to after \ref nvmlDeviceResetApplicationsClocks call.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param clockType                            Identify which clock domain to query
        ///  * @param clockMHz                             Reference in which to return the default clock in MHz
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a clockMHz has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a clockMHz is NULL or \a clockType is invalid
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  *
        ///  * \see nvmlDeviceGetApplicationsClock
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetDefaultApplicationsClock(nvmlDevice_t device, nvmlClockType_t clockType, unsigned int *clockMHz);
        /// 
        /// /**
        ///  * Resets the application clock to the default value
        ///  *
        ///  * This is the applications clock that will be used after system reboot or driver reload.
        ///  * Default value is constant, but the current value an be changed using \ref nvmlDeviceSetApplicationsClocks.
        ///  *
        ///  * On Pascal and newer hardware, if clocks were previously locked with \ref nvmlDeviceSetApplicationsClocks,
        ///  * this call will unlock clocks. This returns clocks their default behavior ofautomatically boosting above
        ///  * base clocks as thermal limits allow.
        ///  *
        ///  * @see nvmlDeviceGetApplicationsClock
        ///  * @see nvmlDeviceSetApplicationsClocks
        ///  *
        ///  * For Fermi &amp;tm; or newer non-GeForce fully supported devices and Maxwell or newer GeForce devices.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if new settings were successfully set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceResetApplicationsClocks(nvmlDevice_t device);
        /// 
        /// /**
        ///  * Retrieves the clock speed for the clock specified by the clock type and clock ID.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param clockType                            Identify which clock domain to query
        ///  * @param clockId                              Identify which clock in the domain to query
        ///  * @param clockMHz                             Reference in which to return the clock in MHz
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if \a clockMHz has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a clockMHz is NULL or \a clockType is invalid
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetClock(nvmlDevice_t device, nvmlClockType_t clockType, nvmlClockId_t clockId, unsigned int *clockMHz);
        /// 
        /// /**
        ///  * Retrieves the customer defined maximum boost clock speed specified by the given clock type.
        ///  *
        ///  * For Pascal &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param clockType                            Identify which clock domain to query
        ///  * @param clockMHz                             Reference in which to return the clock in MHz
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if \a clockMHz has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a clockMHz is NULL or \a clockType is invalid
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device or the \a clockType on this device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetMaxCustomerBoostClock(nvmlDevice_t device, nvmlClockType_t clockType, unsigned int *clockMHz);
        /// 
        /// /**
        ///  * Retrieves the list of possible memory clocks that can be used as an argument for \ref nvmlDeviceSetApplicationsClocks.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param count                                Reference in which to provide the \a clocksMHz array size, and
        ///  *                                             to return the number of elements
        ///  * @param clocksMHz                            Reference in which to return the clock in MHz
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a count and \a clocksMHz have been populated 
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a count is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE if \a count is too small (\a count is set to the number of
        ///  *                                                required elements)
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  *
        ///  * @see nvmlDeviceSetApplicationsClocks
        ///  * @see nvmlDeviceGetSupportedGraphicsClocks
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetSupportedMemoryClocks(nvmlDevice_t device, unsigned int *count, unsigned int *clocksMHz);
        /// 
        /// /**
        ///  * Retrieves the list of possible graphics clocks that can be used as an argument for \ref nvmlDeviceSetApplicationsClocks.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param memoryClockMHz                       Memory clock for which to return possible graphics clocks
        ///  * @param count                                Reference in which to provide the \a clocksMHz array size, and
        ///  *                                             to return the number of elements
        ///  * @param clocksMHz                            Reference in which to return the clocks in MHz
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a count and \a clocksMHz have been populated 
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_NOT_FOUND         if the specified \a memoryClockMHz is not a supported frequency
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a clock is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE if \a count is too small 
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  *
        ///  * @see nvmlDeviceSetApplicationsClocks
        ///  * @see nvmlDeviceGetSupportedMemoryClocks
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetSupportedGraphicsClocks(nvmlDevice_t device, unsigned int memoryClockMHz, unsigned int *count, unsigned int *clocksMHz);
        /// 
        /// /**
        ///  * Retrieve the current state of Auto Boosted clocks on a device and store it in \a isEnabled
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * Auto Boosted clocks are enabled by default on some hardware, allowing the GPU to run at higher clock rates
        ///  * to maximize performance as thermal limits allow.
        ///  *
        ///  * On Pascal and newer hardware, Auto Aoosted clocks are controlled through application clocks.
        ///  * Use \ref nvmlDeviceSetApplicationsClocks and \ref nvmlDeviceResetApplicationsClocks to control Auto Boost
        ///  * behavior.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param isEnabled                            Where to store the current state of Auto Boosted clocks of the target device
        ///  * @param defaultIsEnabled                     Where to store the default Auto Boosted clocks behavior of the target device that the device will
        ///  *                                                 revert to when no applications are using the GPU
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 If \a isEnabled has been been set with the Auto Boosted clocks state of \a device
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a isEnabled is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support Auto Boosted clocks
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  *
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetAutoBoostedClocksEnabled(nvmlDevice_t device, nvmlEnableState_t *isEnabled, nvmlEnableState_t *defaultIsEnabled);
        /// 
        /// /**
        ///  * Try to set the current state of Auto Boosted clocks on a device.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * Auto Boosted clocks are enabled by default on some hardware, allowing the GPU to run at higher clock rates
        ///  * to maximize performance as thermal limits allow. Auto Boosted clocks should be disabled if fixed clock
        ///  * rates are desired.
        ///  *
        ///  * Non-root users may use this API by default but can be restricted by root from using this API by calling
        ///  * \ref nvmlDeviceSetAPIRestriction with apiType=NVML_RESTRICTED_API_SET_AUTO_BOOSTED_CLOCKS.
        ///  * Note: Persistence Mode is required to modify current Auto Boost settings, therefore, it must be enabled.
        ///  *
        ///  * On Pascal and newer hardware, Auto Boosted clocks are controlled through application clocks.
        ///  * Use \ref nvmlDeviceSetApplicationsClocks and \ref nvmlDeviceResetApplicationsClocks to control Auto Boost
        ///  * behavior.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param enabled                              What state to try to set Auto Boosted clocks of the target device to
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 If the Auto Boosted clocks were successfully set to the state specified by \a enabled
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support Auto Boosted clocks
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  *
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceSetAutoBoostedClocksEnabled(nvmlDevice_t device, nvmlEnableState_t enabled);
        /// 
        /// /**
        ///  * Try to set the default state of Auto Boosted clocks on a device. This is the default state that Auto Boosted clocks will
        ///  * return to when no compute running processes (e.g. CUDA application which have an active context) are running
        ///  *
        ///  * For Kepler &amp;tm; or newer non-GeForce fully supported devices and Maxwell or newer GeForce devices.
        ///  * Requires root/admin permissions.
        ///  *
        ///  * Auto Boosted clocks are enabled by default on some hardware, allowing the GPU to run at higher clock rates
        ///  * to maximize performance as thermal limits allow. Auto Boosted clocks should be disabled if fixed clock
        ///  * rates are desired.
        ///  *
        ///  * On Pascal and newer hardware, Auto Boosted clocks are controlled through application clocks.
        ///  * Use \ref nvmlDeviceSetApplicationsClocks and \ref nvmlDeviceResetApplicationsClocks to control Auto Boost
        ///  * behavior.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param enabled                              What state to try to set default Auto Boosted clocks of the target device to
        ///  * @param flags                                Flags that change the default behavior. Currently Unused.
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 If the Auto Boosted clock's default state was successfully set to the state specified by \a enabled
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_NO_PERMISSION     If the calling user does not have permission to change Auto Boosted clock's default state.
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support Auto Boosted clocks
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  *
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceSetDefaultAutoBoostedClocksEnabled(nvmlDevice_t device, nvmlEnableState_t enabled, unsigned int flags);
        /// 
        /// 
        /// /**
        ///  * Retrieves the intended operating speed of the device's fan.
        ///  *
        ///  * Note: The reported speed is the intended fan speed.  If the fan is physically blocked and unable to spin, the
        ///  * output will not match the actual fan speed.
        ///  * 
        ///  * For all discrete products with dedicated fans.
        ///  *
        ///  * The fan speed is expressed as a percent of the maximum, i.e. full speed is 100%.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param speed                                Reference in which to return the fan speed percentage
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a speed has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a speed is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not have a fan
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetFanSpeed(nvmlDevice_t device, unsigned int *speed);
        /// 
        /// 
        /// /**
        ///  * Retrieves the intended operating speed of the device's specified fan.
        ///  *
        ///  * Note: The reported speed is the intended fan speed. If the fan is physically blocked and unable to spin, the
        ///  * output will not match the actual fan speed.
        ///  *
        ///  * For all discrete products with dedicated fans.
        ///  *
        ///  * The fan speed is expressed as a percentage of the maximum, i.e. full speed is 100%
        ///  *
        ///  * @param device                                The identifier of the target device
        ///  * @param fan                                   The index of the target fan, zero indexed.
        ///  * @param speed                                 Reference in which to return the fan speed percentage
        ///  *
        ///  * @return
        ///  *        - \ref NVML_SUCCESS                   if \a speed has been set
        ///  *        - \ref NVML_ERROR_UNINITIALIZED       if the library has not been successfully initialized
        ///  *        - \ref NVML_ERROR_INVALID_ARGUMENT    if \a device is invalid, \a fan is not an acceptable index, or \a speed is NULL
        ///  *        - \ref NVML_ERROR_NOT_SUPPORTED       if the device does not have a fan or is newer than Maxwell
        ///  *        - \ref NVML_ERROR_GPU_IS_LOST         if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *        - \ref NVML_ERROR_UNKNOWN             on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetFanSpeed_v2(nvmlDevice_t device, unsigned int fan, unsigned int * speed);
        /// 
        /// 
        /// /**
        ///  * Retrieves the current temperature readings for the device, in degrees C. 
        ///  * 
        ///  * For all products.
        ///  *
        ///  * See \ref nvmlTemperatureSensors_t for details on available temperature sensors.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param sensorType                           Flag that indicates which sensor reading to retrieve
        ///  * @param temp                                 Reference in which to return the temperature reading
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a temp has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, \a sensorType is invalid or \a temp is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not have the specified sensor
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetTemperature(nvmlDevice_t device, nvmlTemperatureSensors_t sensorType, unsigned int *temp);
        /// 
        /// /**
        ///  * Retrieves the temperature threshold for the GPU with the specified threshold type in degrees C.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * See \ref nvmlTemperatureThresholds_t for details on available temperature thresholds.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param thresholdType                        The type of threshold value queried
        ///  * @param temp                                 Reference in which to return the temperature reading
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if \a temp has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, \a thresholdType is invalid or \a temp is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not have a temperature sensor or is unsupported
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetTemperatureThreshold(nvmlDevice_t device, nvmlTemperatureThresholds_t thresholdType, unsigned int *temp);
        /// 
        /// /**
        ///  * Retrieves the current performance state for the device. 
        ///  *
        ///  * For Fermi &amp;tm; or newer fully supported devices.
        ///  *
        ///  * See \ref nvmlPstates_t for details on allowed performance states.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param pState                               Reference in which to return the performance state reading
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a pState has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a pState is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetPerformanceState(nvmlDevice_t device, nvmlPstates_t *pState);
        /// 
        /// /**
        ///  * Retrieves current clocks throttling reasons.
        ///  *
        ///  * For all fully supported products.
        ///  *
        ///  * \note More than one bit can be enabled at the same time. Multiple reasons can be affecting clocks at once.
        ///  *
        ///  * @param device                                The identifier of the target device
        ///  * @param clocksThrottleReasons                 Reference in which to return bitmask of active clocks throttle
        ///  *                                                  reasons
        ///  *
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a clocksThrottleReasons has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a clocksThrottleReasons is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  *
        ///  * @see nvmlClocksThrottleReasons
        ///  * @see nvmlDeviceGetSupportedClocksThrottleReasons
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetCurrentClocksThrottleReasons(nvmlDevice_t device, unsigned long long *clocksThrottleReasons);
        /// 
        /// /**
        ///  * Retrieves bitmask of supported clocks throttle reasons that can be returned by 
        ///  * \ref nvmlDeviceGetCurrentClocksThrottleReasons
        ///  *
        ///  * For all fully supported products.
        ///  *
        ///  * This method is not supported in virtual machines running virtual GPU (vGPU).
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param supportedClocksThrottleReasons       Reference in which to return bitmask of supported
        ///  *                                              clocks throttle reasons
        ///  *
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a supportedClocksThrottleReasons has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a supportedClocksThrottleReasons is NULL
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  *
        ///  * @see nvmlClocksThrottleReasons
        ///  * @see nvmlDeviceGetCurrentClocksThrottleReasons
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetSupportedClocksThrottleReasons(nvmlDevice_t device, unsigned long long *supportedClocksThrottleReasons);
        /// 
        /// /**
        ///  * Deprecated: Use \ref nvmlDeviceGetPerformanceState. This function exposes an incorrect generalization.
        ///  *
        ///  * Retrieve the current performance state for the device. 
        ///  *
        ///  * For Fermi &amp;tm; or newer fully supported devices.
        ///  *
        ///  * See \ref nvmlPstates_t for details on allowed performance states.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param pState                               Reference in which to return the performance state reading
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a pState has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a pState is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetPowerState(nvmlDevice_t device, nvmlPstates_t *pState);
        /// 
        /// /**
        ///  * This API has been deprecated.
        ///  *
        ///  * Retrieves the power management mode associated with this device.
        ///  *
        ///  * For products from the Fermi family.
        ///  *     - Requires \a NVML_INFOROM_POWER version 3.0 or higher.
        ///  *
        ///  * For from the Kepler or newer families.
        ///  *     - Does not require \a NVML_INFOROM_POWER object.
        ///  *
        ///  * This flag indicates whether any power management algorithm is currently active on the device. An 
        ///  * enabled state does not necessarily mean the device is being actively throttled -- only that 
        ///  * that the driver will do so if the appropriate conditions are met.
        ///  *
        ///  * See \ref nvmlEnableState_t for details on allowed modes.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param mode                                 Reference in which to return the current power management mode
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a mode has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a mode is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetPowerManagementMode(nvmlDevice_t device, nvmlEnableState_t *mode);
        /// 
        /// /**
        ///  * Retrieves the power management limit associated with this device.
        ///  *
        ///  * For Fermi &amp;tm; or newer fully supported devices.
        ///  *
        ///  * The power limit defines the upper boundary for the card's power draw. If
        ///  * the card's total power draw reaches this limit the power management algorithm kicks in.
        ///  *
        ///  * This reading is only available if power management mode is supported. 
        ///  * See \ref nvmlDeviceGetPowerManagementMode.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param limit                                Reference in which to return the power management limit in milliwatts
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a limit has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a limit is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetPowerManagementLimit(nvmlDevice_t device, unsigned int *limit);
        /// 
        /// /**
        ///  * Retrieves information about possible values of power management limits on this device.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param minLimit                             Reference in which to return the minimum power management limit in milliwatts
        ///  * @param maxLimit                             Reference in which to return the maximum power management limit in milliwatts
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a minLimit and \a maxLimit have been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a minLimit or \a maxLimit is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  *
        ///  * @see nvmlDeviceSetPowerManagementLimit
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetPowerManagementLimitConstraints(nvmlDevice_t device, unsigned int *minLimit, unsigned int *maxLimit);
        /// 
        /// /**
        ///  * Retrieves default power management limit on this device, in milliwatts.
        ///  * Default power management limit is a power management limit that the device boots with.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param defaultLimit                         Reference in which to return the default power management limit in milliwatts
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a defaultLimit has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a defaultLimit is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetPowerManagementDefaultLimit(nvmlDevice_t device, unsigned int *defaultLimit);
        /// 
        /// /**
        ///  * Retrieves power usage for this GPU in milliwatts and its associated circuitry (e.g. memory)
        ///  *
        ///  * For Fermi &amp;tm; or newer fully supported devices.
        ///  *
        ///  * On Fermi and Kepler GPUs the reading is accurate to within +/- 5% of current power draw.
        ///  *
        ///  * It is only available if power management mode is supported. See \ref nvmlDeviceGetPowerManagementMode.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param power                                Reference in which to return the power usage information
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a power has been populated
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a power is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support power readings
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetPowerUsage(nvmlDevice_t device, unsigned int *power);
        /// 
        /// /**
        ///  * Retrieves total energy consumption for this GPU in millijoules (mJ) since the driver was last reloaded
        ///  *
        ///  * For newer than Pascal &amp;tm; fully supported devices.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param energy                               Reference in which to return the energy consumption information
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if \a energy has been populated
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a energy is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support energy readings
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetTotalEnergyConsumption(nvmlDevice_t device, unsigned long long *energy);
        /// 
        /// /**
        ///  * Get the effective power limit that the driver enforces after taking into account all limiters
        ///  *
        ///  * Note: This can be different from the \ref nvmlDeviceGetPowerManagementLimit if other limits are set elsewhere
        ///  * This includes the out of band power limit interface
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                           The device to communicate with
        ///  * @param limit                            Reference in which to return the power management limit in milliwatts
        ///  *
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a limit has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a limit is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetEnforcedPowerLimit(nvmlDevice_t device, unsigned int *limit);
        /// 
        /// /**
        ///  * Retrieves the current GOM and pending GOM (the one that GPU will switch to after reboot).
        ///  *
        ///  * For GK110 M-class and X-class Tesla &amp;tm; products from the Kepler family.
        ///  * Modes \ref NVML_GOM_LOW_DP and \ref NVML_GOM_ALL_ON are supported on fully supported GeForce products.
        ///  * Not supported on Quadro &amp;reg; and Tesla &amp;tm; C-class products.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param current                              Reference in which to return the current GOM
        ///  * @param pending                              Reference in which to return the pending GOM
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a mode has been populated
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a current or \a pending is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  *
        ///  * @see nvmlGpuOperationMode_t
        ///  * @see nvmlDeviceSetGpuOperationMode
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetGpuOperationMode(nvmlDevice_t device, nvmlGpuOperationMode_t *current, nvmlGpuOperationMode_t *pending);
        /// 
        /// /**
        ///  * Retrieves the amount of used, free and total memory available on the device, in bytes.
        ///  * 
        ///  * For all products.
        ///  *
        ///  * Enabling ECC reduces the amount of total available memory, due to the extra required parity bits.
        ///  * Under WDDM most device memory is allocated and managed on startup by Windows.
        ///  *
        ///  * Under Linux and Windows TCC, the reported amount of used memory is equal to the sum of memory allocated 
        ///  * by all active channels on the device.
        ///  *
        ///  * See \ref nvmlMemory_t for details on available memory info.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param memory                               Reference in which to return the memory information
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a memory has been populated
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a memory is NULL
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetMemoryInfo(nvmlDevice_t device, nvmlMemory_t *memory);
        /// 
        /// /**
        ///  * Retrieves the current compute mode for the device.
        ///  *
        ///  * For all products.
        ///  *
        ///  * See \ref nvmlComputeMode_t for details on allowed compute modes.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param mode                                 Reference in which to return the current compute mode
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a mode has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a mode is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  *
        ///  * @see nvmlDeviceSetComputeMode()
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetComputeMode(nvmlDevice_t device, nvmlComputeMode_t *mode);
        /// 
        /// /**
        ///  * Retrieves the CUDA compute capability of the device.
        ///  *
        ///  * For all products.
        ///  *
        ///  * Returns the major and minor compute capability version numbers of the
        ///  * device.  The major and minor versions are equivalent to the
        ///  * CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MINOR and
        ///  * CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MAJOR attributes that would be
        ///  * returned by CUDA's cuDeviceGetAttribute().
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param major                                Reference in which to return the major CUDA compute capability
        ///  * @param minor                                Reference in which to return the minor CUDA compute capability
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if \a major and \a minor have been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a major or \a minor are NULL
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetCudaComputeCapability(nvmlDevice_t device, int *major, int *minor);
        /// 
        /// /**
        ///  * Retrieves the current and pending ECC modes for the device.
        ///  *
        ///  * For Fermi &amp;tm; or newer fully supported devices.
        ///  * Only applicable to devices with ECC.
        ///  * Requires \a NVML_INFOROM_ECC version 1.0 or higher.
        ///  *
        ///  * Changing ECC modes requires a reboot. The "pending" ECC mode refers to the target mode following
        ///  * the next reboot.
        ///  *
        ///  * See \ref nvmlEnableState_t for details on allowed modes.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param current                              Reference in which to return the current ECC mode
        ///  * @param pending                              Reference in which to return the pending ECC mode
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a current and \a pending have been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or either \a current or \a pending is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  *
        ///  * @see nvmlDeviceSetEccMode()
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetEccMode(nvmlDevice_t device, nvmlEnableState_t *current, nvmlEnableState_t *pending);
        /// 
        /// /**
        ///  * Retrieves the device boardId from 0-N.
        ///  * Devices with the same boardId indicate GPUs connected to the same PLX.  Use in conjunction with 
        ///  *  \ref nvmlDeviceGetMultiGpuBoard() to decide if they are on the same board as well.
        ///  *  The boardId returned is a unique ID for the current configuration.  Uniqueness and ordering across 
        ///  *  reboots and system configurations is not guaranteed (i.e. if a Tesla K40c returns 0x100 and
        ///  *  the two GPUs on a Tesla K10 in the same system returns 0x200 it is not guaranteed they will 
        ///  *  always return those values but they will always be different from each other).
        ///  *  
        ///  *
        ///  * For Fermi &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param boardId                              Reference in which to return the device's board ID
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if \a boardId has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a boardId is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetBoardId(nvmlDevice_t device, unsigned int *boardId);
        /// 
        /// /**
        ///  * Retrieves whether the device is on a Multi-GPU Board
        ///  * Devices that are on multi-GPU boards will set \a multiGpuBool to a non-zero value.
        ///  *
        ///  * For Fermi &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param multiGpuBool                         Reference in which to return a zero or non-zero value
        ///  *                                                 to indicate whether the device is on a multi GPU board
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if \a multiGpuBool has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a multiGpuBool is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetMultiGpuBoard(nvmlDevice_t device, unsigned int *multiGpuBool);
        /// 
        /// /**
        ///  * Retrieves the total ECC error counts for the device.
        ///  *
        ///  * For Fermi &amp;tm; or newer fully supported devices.
        ///  * Only applicable to devices with ECC.
        ///  * Requires \a NVML_INFOROM_ECC version 1.0 or higher.
        ///  * Requires ECC Mode to be enabled.
        ///  *
        ///  * The total error count is the sum of errors across each of the separate memory systems, i.e. the total set of 
        ///  * errors across the entire device.
        ///  *
        ///  * See \ref nvmlMemoryErrorType_t for a description of available error types.\n
        ///  * See \ref nvmlEccCounterType_t for a description of available counter types.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param errorType                            Flag that specifies the type of the errors. 
        ///  * @param counterType                          Flag that specifies the counter-type of the errors. 
        ///  * @param eccCounts                            Reference in which to return the specified ECC errors
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a eccCounts has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device, \a errorType or \a counterType is invalid, or \a eccCounts is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  *
        ///  * @see nvmlDeviceClearEccErrorCounts()
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetTotalEccErrors(nvmlDevice_t device, nvmlMemoryErrorType_t errorType, nvmlEccCounterType_t counterType, unsigned long long *eccCounts);
        /// 
        /// /**
        ///  * Retrieves the detailed ECC error counts for the device.
        ///  *
        ///  * @deprecated   This API supports only a fixed set of ECC error locations
        ///  *               On different GPU architectures different locations are supported
        ///  *               See \ref nvmlDeviceGetMemoryErrorCounter
        ///  *
        ///  * For Fermi &amp;tm; or newer fully supported devices.
        ///  * Only applicable to devices with ECC.
        ///  * Requires \a NVML_INFOROM_ECC version 2.0 or higher to report aggregate location-based ECC counts.
        ///  * Requires \a NVML_INFOROM_ECC version 1.0 or higher to report all other ECC counts.
        ///  * Requires ECC Mode to be enabled.
        ///  *
        ///  * Detailed errors provide separate ECC counts for specific parts of the memory system.
        ///  *
        ///  * Reports zero for unsupported ECC error counters when a subset of ECC error counters are supported.
        ///  *
        ///  * See \ref nvmlMemoryErrorType_t for a description of available bit types.\n
        ///  * See \ref nvmlEccCounterType_t for a description of available counter types.\n
        ///  * See \ref nvmlEccErrorCounts_t for a description of provided detailed ECC counts.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param errorType                            Flag that specifies the type of the errors. 
        ///  * @param counterType                          Flag that specifies the counter-type of the errors. 
        ///  * @param eccCounts                            Reference in which to return the specified ECC errors
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a eccCounts has been populated
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device, \a errorType or \a counterType is invalid, or \a eccCounts is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  *
        ///  * @see nvmlDeviceClearEccErrorCounts()
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetDetailedEccErrors(nvmlDevice_t device, nvmlMemoryErrorType_t errorType, nvmlEccCounterType_t counterType, nvmlEccErrorCounts_t *eccCounts);
        /// 
        /// /**
        ///  * Retrieves the requested memory error counter for the device.
        ///  *
        ///  * For Fermi &amp;tm; or newer fully supported devices.
        ///  * Requires \a NVML_INFOROM_ECC version 2.0 or higher to report aggregate location-based memory error counts.
        ///  * Requires \a NVML_INFOROM_ECC version 1.0 or higher to report all other memory error counts.
        ///  *
        ///  * Only applicable to devices with ECC.
        ///  *
        ///  * Requires ECC Mode to be enabled.
        ///  *
        ///  * See \ref nvmlMemoryErrorType_t for a description of available memory error types.\n
        ///  * See \ref nvmlEccCounterType_t for a description of available counter types.\n
        ///  * See \ref nvmlMemoryLocation_t for a description of available counter locations.\n
        ///  * 
        ///  * @param device                               The identifier of the target device
        ///  * @param errorType                            Flag that specifies the type of error.
        ///  * @param counterType                          Flag that specifies the counter-type of the errors. 
        ///  * @param locationType                         Specifies the location of the counter. 
        ///  * @param count                                Reference in which to return the ECC counter
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a count has been populated
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device, \a bitTyp,e \a counterType or \a locationType is
        ///  *                                             invalid, or \a count is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support ECC error reporting in the specified memory
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetMemoryErrorCounter(nvmlDevice_t device, nvmlMemoryErrorType_t errorType,
        ///                                                    nvmlEccCounterType_t counterType,
        ///                                                    nvmlMemoryLocation_t locationType, unsigned long long *count);
        /// 
        /// /**
        ///  * Retrieves the current utilization rates for the device's major subsystems.
        ///  *
        ///  * For Fermi &amp;tm; or newer fully supported devices.
        ///  *
        ///  * See \ref nvmlUtilization_t for details on available utilization rates.
        ///  *
        ///  * \note During driver initialization when ECC is enabled one can see high GPU and Memory Utilization readings.
        ///  *       This is caused by ECC Memory Scrubbing mechanism that is performed during driver initialization.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param utilization                          Reference in which to return the utilization information
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a utilization has been populated
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a utilization is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetUtilizationRates(nvmlDevice_t device, nvmlUtilization_t *utilization);
        /// 
        /// /**
        ///  * Retrieves the current utilization and sampling size in microseconds for the Encoder
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param utilization                          Reference to an unsigned int for encoder utilization info
        ///  * @param samplingPeriodUs                     Reference to an unsigned int for the sampling period in US
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if \a utilization has been populated
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, \a utilization is NULL, or \a samplingPeriodUs is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetEncoderUtilization(nvmlDevice_t device, unsigned int *utilization, unsigned int *samplingPeriodUs);
        /// 
        /// /**
        ///  * Retrieves the current capacity of the device's encoder, as a percentage of maximum encoder capacity with valid values in the range 0-100.
        ///  *
        ///  * For Maxwell &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                            The identifier of the target device
        ///  * @param encoderQueryType                  Type of encoder to query
        ///  * @param encoderCapacity                   Reference to an unsigned int for the encoder capacity
        ///  * 
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                  if \a encoderCapacity is fetched
        ///  *         - \ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT   if \a encoderCapacity is NULL, or \a device or \a encoderQueryType
        ///  *                                              are invalid
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED      if device does not support the encoder specified in \a encodeQueryType
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST        if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN            on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetEncoderCapacity (nvmlDevice_t device, nvmlEncoderType_t encoderQueryType, unsigned int *encoderCapacity);
        /// 
        /// /**
        ///  * Retrieves the current encoder statistics for a given device.
        ///  *
        ///  * For Maxwell &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                            The identifier of the target device
        ///  * @param sessionCount                      Reference to an unsigned int for count of active encoder sessions
        ///  * @param averageFps                        Reference to an unsigned int for trailing average FPS of all active sessions
        ///  * @param averageLatency                    Reference to an unsigned int for encode latency in microseconds
        ///  * 
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                  if \a sessionCount, \a averageFps and \a averageLatency is fetched
        ///  *         - \ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT   if \a sessionCount, or \a device or \a averageFps,
        ///  *                                              or \a averageLatency is NULL
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST        if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN            on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetEncoderStats (nvmlDevice_t device, unsigned int *sessionCount,
        ///                                                 unsigned int *averageFps, unsigned int *averageLatency);
        /// 
        /// /**
        ///  * Retrieves information about active encoder sessions on a target device.
        ///  *
        ///  * An array of active encoder sessions is returned in the caller-supplied buffer pointed at by \a sessionInfos. The
        ///  * array elememt count is passed in \a sessionCount, and \a sessionCount is used to return the number of sessions
        ///  * written to the buffer.
        ///  *
        ///  * If the supplied buffer is not large enough to accomodate the active session array, the function returns
        ///  * NVML_ERROR_INSUFFICIENT_SIZE, with the element count of nvmlEncoderSessionInfo_t array required in \a sessionCount.
        ///  * To query the number of active encoder sessions, call this function with *sessionCount = 0.  The code will return
        ///  * NVML_SUCCESS with number of active encoder sessions updated in *sessionCount.
        ///  *
        ///  * For Maxwell &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                            The identifier of the target device
        ///  * @param sessionCount                      Reference to caller supplied array size, and returns the number of sessions.
        ///  * @param sessionInfos                      Reference in which to return the session information
        ///  * 
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                  if \a sessionInfos is fetched
        ///  *         - \ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE  if \a sessionCount is too small, array element count is returned in \a sessionCount
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT   if \a sessionCount is NULL.
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST        if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN            on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetEncoderSessions(nvmlDevice_t device, unsigned int *sessionCount, nvmlEncoderSessionInfo_t *sessionInfos);
        /// 
        /// /**
        ///  * Retrieves the current utilization and sampling size in microseconds for the Decoder
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param utilization                          Reference to an unsigned int for decoder utilization info
        ///  * @param samplingPeriodUs                     Reference to an unsigned int for the sampling period in US
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if \a utilization has been populated
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, \a utilization is NULL, or \a samplingPeriodUs is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetDecoderUtilization(nvmlDevice_t device, unsigned int *utilization, unsigned int *samplingPeriodUs);
        /// 
        /// /**
        /// * Retrieves the active frame buffer capture sessions statistics for a given device.
        /// *
        /// * For Maxwell &amp;tm; or newer fully supported devices.
        /// *
        /// * @param device                            The identifier of the target device
        /// * @param fbcStats                          Reference to nvmlFBCStats_t structure contianing NvFBC stats
        /// *
        /// * @return
        /// *         - \ref NVML_SUCCESS                  if \a fbcStats is fetched
        /// *         - \ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized
        /// *         - \ref NVML_ERROR_INVALID_ARGUMENT   if \a fbcStats is NULL
        /// *         - \ref NVML_ERROR_GPU_IS_LOST        if the target GPU has fallen off the bus or is otherwise inaccessible
        /// *         - \ref NVML_ERROR_UNKNOWN            on any unexpected error
        /// */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetFBCStats(nvmlDevice_t device, nvmlFBCStats_t *fbcStats);
        /// 
        /// /**
        /// * Retrieves information about active frame buffer capture sessions on a target device.
        /// *
        /// * An array of active FBC sessions is returned in the caller-supplied buffer pointed at by \a sessionInfo. The
        /// * array element count is passed in \a sessionCount, and \a sessionCount is used to return the number of sessions
        /// * written to the buffer.
        /// *
        /// * If the supplied buffer is not large enough to accomodate the active session array, the function returns
        /// * NVML_ERROR_INSUFFICIENT_SIZE, with the element count of nvmlFBCSessionInfo_t array required in \a sessionCount.
        /// * To query the number of active FBC sessions, call this function with *sessionCount = 0.  The code will return
        /// * NVML_SUCCESS with number of active FBC sessions updated in *sessionCount.
        /// *
        /// * For Maxwell &amp;tm; or newer fully supported devices.
        /// *
        /// * @note hResolution, vResolution, averageFPS and averageLatency data for a FBC session returned in \a sessionInfo may
        /// *       be zero if there are no new frames captured since the session started.
        /// *
        /// * @param device                            The identifier of the target device
        /// * @param sessionCount                      Reference to caller supplied array size, and returns the number of sessions.
        /// * @param sessionInfo                       Reference in which to return the session information
        /// *
        /// * @return
        /// *         - \ref NVML_SUCCESS                  if \a sessionInfo is fetched
        /// *         - \ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized
        /// *         - \ref NVML_ERROR_INSUFFICIENT_SIZE  if \a sessionCount is too small, array element count is returned in \a sessionCount
        /// *         - \ref NVML_ERROR_INVALID_ARGUMENT   if \a sessionCount is NULL.
        /// *         - \ref NVML_ERROR_GPU_IS_LOST        if the target GPU has fallen off the bus or is otherwise inaccessible
        /// *         - \ref NVML_ERROR_UNKNOWN            on any unexpected error
        /// */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetFBCSessions(nvmlDevice_t device, unsigned int *sessionCount, nvmlFBCSessionInfo_t *sessionInfo);
        /// 
        /// /**
        ///  * Retrieves the current and pending driver model for the device.
        ///  *
        ///  * For Fermi &amp;tm; or newer fully supported devices.
        ///  * For windows only.
        ///  *
        ///  * On Windows platforms the device driver can run in either WDDM or WDM (TCC) mode. If a display is attached
        ///  * to the device it must run in WDDM mode. TCC mode is preferred if a display is not attached.
        ///  *
        ///  * See \ref nvmlDriverModel_t for details on available driver models.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param current                              Reference in which to return the current driver model
        ///  * @param pending                              Reference in which to return the pending driver model
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if either \a current and/or \a pending have been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or both \a current and \a pending are NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the platform is not windows
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  * 
        ///  * @see nvmlDeviceSetDriverModel()
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetDriverModel(nvmlDevice_t device, nvmlDriverModel_t *current, nvmlDriverModel_t *pending);
        /// 
        /// /**
        ///  * Get VBIOS version of the device.
        ///  *
        ///  * For all products.
        ///  *
        ///  * The VBIOS version may change from time to time. It will not exceed 32 characters in length 
        ///  * (including the NULL terminator).  See \ref nvmlConstants::NVML_DEVICE_VBIOS_VERSION_BUFFER_SIZE.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param version                              Reference to which to return the VBIOS version
        ///  * @param length                               The maximum allowed length of the string returned in \a version
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a version has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, or \a version is NULL
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE if \a length is too small 
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetVbiosVersion(nvmlDevice_t device, char *version, unsigned int length);
        /// 
        /// /**
        ///  * Get Bridge Chip Information for all the bridge chips on the board.
        ///  * 
        ///  * For all fully supported products.
        ///  * Only applicable to multi-GPU products.
        ///  * 
        ///  * @param device                                The identifier of the target device
        ///  * @param bridgeHierarchy                       Reference to the returned bridge chip Hierarchy
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if bridge chip exists
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, or \a bridgeInfo is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if bridge chip not supported on the device
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  * 
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetBridgeChipInfo(nvmlDevice_t device, nvmlBridgeChipHierarchy_t *bridgeHierarchy);
        /// 
        /// /**
        ///  * Get information about processes with a compute context on a device
        ///  *
        ///  * For Fermi &amp;tm; or newer fully supported devices.
        ///  *
        ///  * This function returns information only about compute running processes (e.g. CUDA application which have
        ///  * active context). Any graphics applications (e.g. using OpenGL, DirectX) won't be listed by this function.
        ///  *
        ///  * To query the current number of running compute processes, call this function with *infoCount = 0. The
        ///  * return code will be NVML_ERROR_INSUFFICIENT_SIZE, or NVML_SUCCESS if none are running. For this call
        ///  * \a infos is allowed to be NULL.
        ///  *
        ///  * The usedGpuMemory field returned is all of the memory used by the application.
        ///  *
        ///  * Keep in mind that information returned by this call is dynamic and the number of elements might change in
        ///  * time. Allocate more space for \a infos table in case new compute processes are spawned.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param infoCount                            Reference in which to provide the \a infos array size, and
        ///  *                                             to return the number of returned elements
        ///  * @param infos                                Reference in which to return the process information
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a infoCount and \a infos have been populated
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE if \a infoCount indicates that the \a infos array is too small
        ///  *                                             \a infoCount will contain minimal amount of space necessary for
        ///  *                                             the call to complete
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, either of \a infoCount or \a infos is NULL
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  *
        ///  * @see \ref nvmlSystemGetProcessName
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetComputeRunningProcesses(nvmlDevice_t device, unsigned int *infoCount, nvmlProcessInfo_t *infos);
        /// 
        /// /**
        ///  * Get information about processes with a graphics context on a device
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * This function returns information only about graphics based processes 
        ///  * (eg. applications using OpenGL, DirectX)
        ///  *
        ///  * To query the current number of running graphics processes, call this function with *infoCount = 0. The
        ///  * return code will be NVML_ERROR_INSUFFICIENT_SIZE, or NVML_SUCCESS if none are running. For this call
        ///  * \a infos is allowed to be NULL.
        ///  *
        ///  * The usedGpuMemory field returned is all of the memory used by the application.
        ///  *
        ///  * Keep in mind that information returned by this call is dynamic and the number of elements might change in
        ///  * time. Allocate more space for \a infos table in case new graphics processes are spawned.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param infoCount                            Reference in which to provide the \a infos array size, and
        ///  *                                             to return the number of returned elements
        ///  * @param infos                                Reference in which to return the process information
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a infoCount and \a infos have been populated
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE if \a infoCount indicates that the \a infos array is too small
        ///  *                                             \a infoCount will contain minimal amount of space necessary for
        ///  *                                             the call to complete
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, either of \a infoCount or \a infos is NULL
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  *
        ///  * @see \ref nvmlSystemGetProcessName
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetGraphicsRunningProcesses(nvmlDevice_t device, unsigned int *infoCount, nvmlProcessInfo_t *infos);
        /// 
        /// /**
        ///  * Check if the GPU devices are on the same physical board.
        ///  *
        ///  * For all fully supported products.
        ///  *
        ///  * @param device1                               The first GPU device
        ///  * @param device2                               The second GPU device
        ///  * @param onSameBoard                           Reference in which to return the status.
        ///  *                                              Non-zero indicates that the GPUs are on the same board.
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if \a onSameBoard has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a dev1 or \a dev2 are invalid or \a onSameBoard is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if this check is not supported by the device
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the either GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceOnSameBoard(nvmlDevice_t device1, nvmlDevice_t device2, int *onSameBoard);
        /// 
        /// /**
        ///  * Retrieves the root/admin permissions on the target API. See \a nvmlRestrictedAPI_t for the list of supported APIs.
        ///  * If an API is restricted only root users can call that API. See \a nvmlDeviceSetAPIRestriction to change current permissions.
        ///  *
        ///  * For all fully supported products.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param apiType                              Target API type for this operation
        ///  * @param isRestricted                         Reference in which to return the current restriction 
        ///  *                                             NVML_FEATURE_ENABLED indicates that the API is root-only
        ///  *                                             NVML_FEATURE_DISABLED indicates that the API is accessible to all users
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if \a isRestricted has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, \a apiType incorrect or \a isRestricted is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if this query is not supported by the device or the device does not support
        ///  *                                                 the feature that is being queried (E.G. Enabling/disabling Auto Boosted clocks is
        ///  *                                                 not supported by the device)
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  *
        ///  * @see nvmlRestrictedAPI_t
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetAPIRestriction(nvmlDevice_t device, nvmlRestrictedAPI_t apiType, nvmlEnableState_t *isRestricted);
        /// 
        /// /**
        ///  * Gets recent samples for the GPU.
        ///  * 
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  * 
        ///  * Based on type, this method can be used to fetch the power, utilization or clock samples maintained in the buffer by 
        ///  * the driver.
        ///  * 
        ///  * Power, Utilization and Clock samples are returned as type "unsigned int" for the union nvmlValue_t.
        ///  * 
        ///  * To get the size of samples that user needs to allocate, the method is invoked with samples set to NULL. 
        ///  * The returned samplesCount will provide the number of samples that can be queried. The user needs to 
        ///  * allocate the buffer with size as samplesCount * sizeof(nvmlSample_t).
        ///  * 
        ///  * lastSeenTimeStamp represents CPU timestamp in microseconds. Set it to 0 to fetch all the samples maintained by the 
        ///  * underlying buffer. Set lastSeenTimeStamp to one of the timeStamps retrieved from the date of the previous query 
        ///  * to get more recent samples.
        ///  * 
        ///  * This method fetches the number of entries which can be accommodated in the provided samples array, and the 
        ///  * reference samplesCount is updated to indicate how many samples were actually retrieved. The advantage of using this 
        ///  * method for samples in contrast to polling via existing methods is to get get higher frequency data at lower polling cost.
        ///  * 
        ///  * @param device                        The identifier for the target device
        ///  * @param type                          Type of sampling event
        ///  * @param lastSeenTimeStamp             Return only samples with timestamp greater than lastSeenTimeStamp. 
        ///  * @param sampleValType                 Output parameter to represent the type of sample value as described in nvmlSampleVal_t
        ///  * @param sampleCount                   Reference to provide the number of elements which can be queried in samples array
        ///  * @param samples                       Reference in which samples are returned
        ///  
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if samples are successfully retrieved
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, \a samplesCount is NULL or 
        ///  *                                             reference to \a sampleCount is 0 for non null \a samples
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if this query is not supported by the device
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_NOT_FOUND         if sample entries are not found
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetSamples(nvmlDevice_t device, nvmlSamplingType_t type, unsigned long long lastSeenTimeStamp,
        ///         nvmlValueType_t *sampleValType, unsigned int *sampleCount, nvmlSample_t *samples);
        /// 
        /// /**
        ///  * Gets Total, Available and Used size of BAR1 memory.
        ///  * 
        ///  * BAR1 is used to map the FB (device memory) so that it can be directly accessed by the CPU or by 3rd party 
        ///  * devices (peer-to-peer on the PCIE bus). 
        ///  * 
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param bar1Memory                           Reference in which BAR1 memory
        ///  *                                             information is returned.
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if BAR1 memory is successfully retrieved
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, \a bar1Memory is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if this query is not supported by the device
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  *
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetBAR1MemoryInfo(nvmlDevice_t device, nvmlBAR1Memory_t *bar1Memory);
        /// 
        /// 
        /// /**
        ///  * Gets the duration of time during which the device was throttled (lower than requested clocks) due to power 
        ///  * or thermal constraints.
        ///  *
        ///  * The method is important to users who are tying to understand if their GPUs throttle at any point during their applications. The
        ///  * difference in violation times at two different reference times gives the indication of GPU throttling event. 
        ///  *
        ///  * Violation for thermal capping is not supported at this time.
        ///  * 
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param perfPolicyType                       Represents Performance policy which can trigger GPU throttling
        ///  * @param violTime                             Reference to which violation time related information is returned 
        ///  *                                         
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if violation time is successfully retrieved
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, \a perfPolicyType is invalid, or \a violTime is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if this query is not supported by the device
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetViolationStatus(nvmlDevice_t device, nvmlPerfPolicyType_t perfPolicyType, nvmlViolationTime_t *violTime);
        /// 
        /// /**
        ///  * @}
        ///  */
        /// 
        /// /** @addtogroup nvmlAccountingStats
        ///  *  @{
        ///  */
        /// 
        /// /**
        ///  * Queries the state of per process accounting mode.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * See \ref nvmlDeviceGetAccountingStats for more details.
        ///  * See \ref nvmlDeviceSetAccountingMode
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param mode                                 Reference in which to return the current accounting mode
        ///  *
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if the mode has been successfully retrieved 
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a mode are NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetAccountingMode(nvmlDevice_t device, nvmlEnableState_t *mode);
        /// 
        /// /**
        ///  * Queries process's accounting stats.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  * 
        ///  * Accounting stats capture GPU utilization and other statistics across the lifetime of a process.
        ///  * Accounting stats can be queried during life time of the process and after its termination.
        ///  * The time field in \ref nvmlAccountingStats_t is reported as 0 during the lifetime of the process and 
        ///  * updated to actual running time after its termination.
        ///  * Accounting stats are kept in a circular buffer, newly created processes overwrite information about old
        ///  * processes.
        ///  *
        ///  * See \ref nvmlAccountingStats_t for description of each returned metric.
        ///  * List of processes that can be queried can be retrieved from \ref nvmlDeviceGetAccountingPids.
        ///  *
        ///  * @note Accounting Mode needs to be on. See \ref nvmlDeviceGetAccountingMode.
        ///  * @note Only compute and graphics applications stats can be queried. Monitoring applications stats can't be
        ///  *         queried since they don't contribute to GPU utilization.
        ///  * @note In case of pid collision stats of only the latest process (that terminated last) will be reported
        ///  *
        ///  * @warning On Kepler devices per process statistics are accurate only if there's one process running on a GPU.
        ///  * 
        ///  * @param device                               The identifier of the target device
        ///  * @param pid                                  Process Id of the target process to query stats for
        ///  * @param stats                                Reference in which to return the process's accounting stats
        ///  *
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if stats have been successfully retrieved
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a stats are NULL
        ///  *         - \ref NVML_ERROR_NOT_FOUND         if process stats were not found
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature or accounting mode is disabled
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  *
        ///  * @see nvmlDeviceGetAccountingBufferSize
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetAccountingStats(nvmlDevice_t device, unsigned int pid, nvmlAccountingStats_t *stats);
        /// 
        /// /**
        ///  * Queries list of processes that can be queried for accounting stats. The list of processes returned 
        ///  * can be in running or terminated state.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * To just query the number of processes ready to be queried, call this function with *count = 0 and
        ///  * pids=NULL. The return code will be NVML_ERROR_INSUFFICIENT_SIZE, or NVML_SUCCESS if list is empty.
        ///  * 
        ///  * For more details see \ref nvmlDeviceGetAccountingStats.
        ///  *
        ///  * @note In case of PID collision some processes might not be accessible before the circular buffer is full.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param count                                Reference in which to provide the \a pids array size, and
        ///  *                                               to return the number of elements ready to be queried
        ///  * @param pids                                 Reference in which to return list of process ids
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if pids were successfully retrieved
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a count is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature or accounting mode is disabled
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE if \a count is too small (\a count is set to
        ///  *                                                 expected value)
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  *
        ///  * @see nvmlDeviceGetAccountingBufferSize
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetAccountingPids(nvmlDevice_t device, unsigned int *count, unsigned int *pids);
        /// 
        /// /**
        ///  * Returns the number of processes that the circular buffer with accounting pids can hold.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * This is the maximum number of processes that accounting information will be stored for before information
        ///  * about oldest processes will get overwritten by information about new processes.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param bufferSize                           Reference in which to provide the size (in number of elements)
        ///  *                                               of the circular buffer for accounting stats.
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if buffer size was successfully retrieved
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a bufferSize is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature or accounting mode is disabled
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  * 
        ///  * @see nvmlDeviceGetAccountingStats
        ///  * @see nvmlDeviceGetAccountingPids
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetAccountingBufferSize(nvmlDevice_t device, unsigned int *bufferSize);
        /// 
        /// /** @} */
        /// 
        /// /** @addtogroup nvmlDeviceQueries
        ///  *  @{
        ///  */
        /// 
        /// /**
        ///  * Returns the list of retired pages by source, including pages that are pending retirement
        ///  * The address information provided from this API is the hardware address of the page that was retired.  Note
        ///  * that this does not match the virtual address used in CUDA, but will match the address information in XID 63
        ///  * 
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                            The identifier of the target device
        ///  * @param cause                             Filter page addresses by cause of retirement
        ///  * @param pageCount                         Reference in which to provide the \a addresses buffer size, and
        ///  *                                          to return the number of retired pages that match \a cause
        ///  *                                          Set to 0 to query the size without allocating an \a addresses buffer
        ///  * @param addresses                         Buffer to write the page addresses into
        ///  * 
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if \a pageCount was populated and \a addresses was filled
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE if \a pageCount indicates the buffer is not large enough to store all the
        ///  *                                             matching page addresses.  \a pageCount is set to the needed size.
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, \a pageCount is NULL, \a cause is invalid, or 
        ///  *                                             \a addresses is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetRetiredPages(nvmlDevice_t device, nvmlPageRetirementCause_t cause,
        ///     unsigned int *pageCount, unsigned long long *addresses);
        /// 
        /// /**
        ///  * Returns the list of retired pages by source, including pages that are pending retirement
        ///  * The address information provided from this API is the hardware address of the page that was retired.  Note
        ///  * that this does not match the virtual address used in CUDA, but will match the address information in XID 63
        ///  *
        ///  * \note nvmlDeviceGetRetiredPages_v2 adds an additional timestamps paramter to return the time of each page's
        ///  *       retirement.
        ///  * 
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                            The identifier of the target device
        ///  * @param cause                             Filter page addresses by cause of retirement
        ///  * @param pageCount                         Reference in which to provide the \a addresses buffer size, and
        ///  *                                          to return the number of retired pages that match \a cause
        ///  *                                          Set to 0 to query the size without allocating an \a addresses buffer
        ///  * @param addresses                         Buffer to write the page addresses into
        ///  * @param timestamps                        Buffer to write the timestamps of page retirement, additional for _v2
        ///  * 
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if \a pageCount was populated and \a addresses was filled
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE if \a pageCount indicates the buffer is not large enough to store all the
        ///  *                                             matching page addresses.  \a pageCount is set to the needed size.
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, \a pageCount is NULL, \a cause is invalid, or 
        ///  *                                             \a addresses is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetRetiredPages_v2(nvmlDevice_t device, nvmlPageRetirementCause_t cause,
        ///     unsigned int *pageCount, unsigned long long *addresses, unsigned long long *timestamps);
        /// 
        /// /**
        ///  * Check if any pages are pending retirement and need a reboot to fully retire.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                            The identifier of the target device
        ///  * @param isPending                         Reference in which to return the pending status
        ///  * 
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if \a isPending was populated
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a isPending is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetRetiredPagesPendingStatus(nvmlDevice_t device, nvmlEnableState_t *isPending);
        /// 
        /// /** @} */
        /// 
        /// /***************************************************************************************************/
        /// /** @defgroup nvmlUnitCommands Unit Commands
        ///  *  This chapter describes NVML operations that change the state of the unit. For S-class products.
        ///  *  Each of these requires root/admin access. Non-admin users will see an NVML_ERROR_NO_PERMISSION
        ///  *  error code when invoking any of these methods.
        ///  *  @{
        ///  */
        /// /***************************************************************************************************/
        /// 
        /// /**
        ///  * Set the LED state for the unit. The LED can be either green (0) or amber (1).
        ///  *
        ///  * For S-class products.
        ///  * Requires root/admin permissions.
        ///  *
        ///  * This operation takes effect immediately.
        ///  * 
        ///  *
        ///  * &lt;b&gt;Current S-Class products don't provide unique LEDs for each unit. As such, both front 
        ///  * and back LEDs will be toggled in unison regardless of which unit is specified with this command.&lt;/b&gt;
        ///  *
        ///  * See \ref nvmlLedColor_t for available colors.
        ///  *
        ///  * @param unit                                 The identifier of the target unit
        ///  * @param color                                The target LED color
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if the LED color has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a unit or \a color is invalid
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if this is not an S-class product
        ///  *         - \ref NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  * 
        ///  * @see nvmlUnitGetLedState()
        ///  */
        /// nvmlReturn_t DECLDIR nvmlUnitSetLedState(nvmlUnit_t unit, nvmlLedColor_t color);
        /// 
        /// /** @} */
        /// 
        /// /***************************************************************************************************/
        /// /** @defgroup nvmlDeviceCommands Device Commands
        ///  *  This chapter describes NVML operations that change the state of the device.
        ///  *  Each of these requires root/admin access. Non-admin users will see an NVML_ERROR_NO_PERMISSION
        ///  *  error code when invoking any of these methods.
        ///  *  @{
        ///  */
        /// /***************************************************************************************************/
        /// 
        /// /**
        ///  * Set the persistence mode for the device.
        ///  *
        ///  * For all products.
        ///  * For Linux only.
        ///  * Requires root/admin permissions.
        ///  *
        ///  * The persistence mode determines whether the GPU driver software is torn down after the last client
        ///  * exits.
        ///  *
        ///  * This operation takes effect immediately. It is not persistent across reboots. After each reboot the
        ///  * persistence mode is reset to "Disabled".
        ///  *
        ///  * See \ref nvmlEnableState_t for available modes.
        ///  *
        ///  * After calling this API with mode set to NVML_FEATURE_DISABLED on a device that has its own NUMA
        ///  * memory, the given device handle will no longer be valid, and to continue to interact with this
        ///  * device, a new handle should be obtained from one of the nvmlDeviceGetHandleBy*() APIs. This
        ///  * limitation is currently only applicable to devices that have a coherent NVLink connection to
        ///  * system memory.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param mode                                 The target persistence mode
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if the persistence mode was set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a mode is invalid
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  *
        ///  * @see nvmlDeviceGetPersistenceMode()
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceSetPersistenceMode(nvmlDevice_t device, nvmlEnableState_t mode);
        /// 
        /// /**
        ///  * Set the compute mode for the device.
        ///  *
        ///  * For all products.
        ///  * Requires root/admin permissions.
        ///  *
        ///  * The compute mode determines whether a GPU can be used for compute operations and whether it can
        ///  * be shared across contexts.
        ///  *
        ///  * This operation takes effect immediately. Under Linux it is not persistent across reboots and
        ///  * always resets to "Default". Under windows it is persistent.
        ///  *
        ///  * Under windows compute mode may only be set to DEFAULT when running in WDDM
        ///  *
        ///  * See \ref nvmlComputeMode_t for details on available compute modes.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param mode                                 The target compute mode
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if the compute mode was set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a mode is invalid
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  *
        ///  * @see nvmlDeviceGetComputeMode()
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceSetComputeMode(nvmlDevice_t device, nvmlComputeMode_t mode);
        /// 
        /// /**
        ///  * Set the ECC mode for the device.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  * Only applicable to devices with ECC.
        ///  * Requires \a NVML_INFOROM_ECC version 1.0 or higher.
        ///  * Requires root/admin permissions.
        ///  *
        ///  * The ECC mode determines whether the GPU enables its ECC support.
        ///  *
        ///  * This operation takes effect after the next reboot.
        ///  *
        ///  * See \ref nvmlEnableState_t for details on available modes.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param ecc                                  The target ECC mode
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if the ECC mode was set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a ecc is invalid
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  *
        ///  * @see nvmlDeviceGetEccMode()
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceSetEccMode(nvmlDevice_t device, nvmlEnableState_t ecc);  
        /// 
        /// /**
        ///  * Clear the ECC error and other memory error counts for the device.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  * Only applicable to devices with ECC.
        ///  * Requires \a NVML_INFOROM_ECC version 2.0 or higher to clear aggregate location-based ECC counts.
        ///  * Requires \a NVML_INFOROM_ECC version 1.0 or higher to clear all other ECC counts.
        ///  * Requires root/admin permissions.
        ///  * Requires ECC Mode to be enabled.
        ///  *
        ///  * Sets all of the specified ECC counters to 0, including both detailed and total counts.
        ///  *
        ///  * This operation takes effect immediately.
        ///  *
        ///  * See \ref nvmlMemoryErrorType_t for details on available counter types.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param counterType                          Flag that indicates which type of errors should be cleared.
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if the error counts were cleared
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a counterType is invalid
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  *
        ///  * @see 
        ///  *      - nvmlDeviceGetDetailedEccErrors()
        ///  *      - nvmlDeviceGetTotalEccErrors()
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceClearEccErrorCounts(nvmlDevice_t device, nvmlEccCounterType_t counterType);
        /// 
        /// /**
        ///  * Set the driver model for the device.
        ///  *
        ///  * For Fermi &amp;tm; or newer fully supported devices.
        ///  * For windows only.
        ///  * Requires root/admin permissions.
        ///  *
        ///  * On Windows platforms the device driver can run in either WDDM or WDM (TCC) mode. If a display is attached
        ///  * to the device it must run in WDDM mode.  
        ///  *
        ///  * It is possible to force the change to WDM (TCC) while the display is still attached with a force flag (nvmlFlagForce).
        ///  * This should only be done if the host is subsequently powered down and the display is detached from the device
        ///  * before the next reboot. 
        ///  *
        ///  * This operation takes effect after the next reboot.
        ///  * 
        ///  * Windows driver model may only be set to WDDM when running in DEFAULT compute mode.
        ///  *
        ///  * Change driver model to WDDM is not supported when GPU doesn't support graphics acceleration or 
        ///  * will not support it after reboot. See \ref nvmlDeviceSetGpuOperationMode.
        ///  *
        ///  * See \ref nvmlDriverModel_t for details on available driver models.
        ///  * See \ref nvmlFlagDefault and \ref nvmlFlagForce
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param driverModel                          The target driver model
        ///  * @param flags                                Flags that change the default behavior
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if the driver model has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a driverModel is invalid
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the platform is not windows or the device does not support this feature
        ///  *         - \ref NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  * 
        ///  * @see nvmlDeviceGetDriverModel()
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceSetDriverModel(nvmlDevice_t device, nvmlDriverModel_t driverModel, unsigned int flags);
        /// 
        /// /**
        ///  * Set clocks that device will lock to.
        ///  *
        ///  * Sets the clocks that the device will be running at to the value in the range of minGpuClockMHz to maxGpuClockMHz.
        ///  * Setting this will supercede application clock values and take effect regardless if a cuda app is running.
        ///  * See /ref nvmlDeviceSetApplicationsClocks
        ///  *
        ///  * Can be used as a setting to request constant performance.
        ///  *
        ///  * Requires root/admin permissions.
        ///  *
        ///  * After system reboot or driver reload applications clocks go back to their default value.
        ///  * See \ref nvmlDeviceResetGpuLockedClocks.
        ///  *
        ///  * For newer than Pascal &amp;tm; fully supported devices.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param minGpuClockMHz                       Requested minimum gpu clock in MHz
        ///  * @param maxGpuClockMHz                       Requested maximum gpu clock in MHz
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if new settings were successfully set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a minGpuClockMHz and \a maxGpuClockMHz
        ///  *                                                 is not a valid clock combination
        ///  *         - \ref NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceSetGpuLockedClocks(nvmlDevice_t device, unsigned int minGpuClockMHz, unsigned int maxGpuClockMHz);
        /// 
        /// /**
        ///  * Resets the gpu clock to the default value
        ///  *
        ///  * This is the gpu clock that will be used after system reboot or driver reload.
        ///  * Default values are idle clocks, but the current values can be changed using \ref nvmlDeviceSetApplicationsClocks.
        ///  *
        ///  * @see nvmlDeviceSetGpuLockedClocks
        ///  *
        ///  * For newer than Pascal &amp;tm; fully supported devices.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if new settings were successfully set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceResetGpuLockedClocks(nvmlDevice_t device);
        /// 
        /// /**
        ///  * Set clocks that applications will lock to.
        ///  *
        ///  * Sets the clocks that compute and graphics applications will be running at.
        ///  * e.g. CUDA driver requests these clocks during context creation which means this property
        ///  * defines clocks at which CUDA applications will be running unless some overspec event
        ///  * occurs (e.g. over power, over thermal or external HW brake).
        ///  *
        ///  * Can be used as a setting to request constant performance.
        ///  *
        ///  * On Pascal and newer hardware, this will automatically disable automatic boosting of clocks.
        ///  *
        ///  * On K80 and newer Kepler and Maxwell GPUs, users desiring fixed performance should also call
        ///  * \ref nvmlDeviceSetAutoBoostedClocksEnabled to prevent clocks from automatically boosting
        ///  * above the clock value being set.
        ///  *
        ///  * For Kepler &amp;tm; or newer non-GeForce fully supported devices and Maxwell or newer GeForce devices.
        ///  * Requires root/admin permissions.
        ///  *
        ///  * See \ref nvmlDeviceGetSupportedMemoryClocks and \ref nvmlDeviceGetSupportedGraphicsClocks
        ///  * for details on how to list available clocks combinations.
        ///  *
        ///  * After system reboot or driver reload applications clocks go back to their default value.
        ///  * See \ref nvmlDeviceResetApplicationsClocks.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param memClockMHz                          Requested memory clock in MHz
        ///  * @param graphicsClockMHz                     Requested graphics clock in MHz
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if new settings were successfully set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a memClockMHz and \a graphicsClockMHz
        ///  *                                                 is not a valid clock combination
        ///  *         - \ref NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceSetApplicationsClocks(nvmlDevice_t device, unsigned int memClockMHz, unsigned int graphicsClockMHz);
        /// 
        /// /**
        ///  * Set new power limit of this device.
        ///  * 
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  * Requires root/admin permissions.
        ///  *
        ///  * See \ref nvmlDeviceGetPowerManagementLimitConstraints to check the allowed ranges of values.
        ///  *
        ///  * \note Limit is not persistent across reboots or driver unloads.
        ///  * Enable persistent mode to prevent driver from unloading when no application is using the device.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param limit                                Power management limit in milliwatts to set
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a limit has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a defaultLimit is out of range
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  *
        ///  * @see nvmlDeviceGetPowerManagementLimitConstraints
        ///  * @see nvmlDeviceGetPowerManagementDefaultLimit
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceSetPowerManagementLimit(nvmlDevice_t device, unsigned int limit);
        /// 
        /// /**
        ///  * Sets new GOM. See \a nvmlGpuOperationMode_t for details.
        ///  *
        ///  * For GK110 M-class and X-class Tesla &amp;tm; products from the Kepler family.
        ///  * Modes \ref NVML_GOM_LOW_DP and \ref NVML_GOM_ALL_ON are supported on fully supported GeForce products.
        ///  * Not supported on Quadro &amp;reg; and Tesla &amp;tm; C-class products.
        ///  * Requires root/admin permissions.
        ///  * 
        ///  * Changing GOMs requires a reboot. 
        ///  * The reboot requirement might be removed in the future.
        ///  *
        ///  * Compute only GOMs don't support graphics acceleration. Under windows switching to these GOMs when
        ///  * pending driver model is WDDM is not supported. See \ref nvmlDeviceSetDriverModel.
        ///  * 
        ///  * @param device                               The identifier of the target device
        ///  * @param mode                                 Target GOM
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a mode has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a mode incorrect
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support GOM or specific mode
        ///  *         - \ref NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  *
        ///  * @see nvmlGpuOperationMode_t
        ///  * @see nvmlDeviceGetGpuOperationMode
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceSetGpuOperationMode(nvmlDevice_t device, nvmlGpuOperationMode_t mode);
        /// 
        /// /**
        ///  * Changes the root/admin restructions on certain APIs. See \a nvmlRestrictedAPI_t for the list of supported APIs.
        ///  * This method can be used by a root/admin user to give non-root/admin access to certain otherwise-restricted APIs.
        ///  * The new setting lasts for the lifetime of the NVIDIA driver; it is not persistent. See \a nvmlDeviceGetAPIRestriction
        ///  * to query the current restriction settings.
        ///  * 
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  * Requires root/admin permissions.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param apiType                              Target API type for this operation
        ///  * @param isRestricted                         The target restriction
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if \a isRestricted has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a apiType incorrect
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support changing API restrictions or the device does not support
        ///  *                                                 the feature that api restrictions are being set for (E.G. Enabling/disabling auto 
        ///  *                                                 boosted clocks is not supported by the device)
        ///  *         - \ref NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  *
        ///  * @see nvmlRestrictedAPI_t
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceSetAPIRestriction(nvmlDevice_t device, nvmlRestrictedAPI_t apiType, nvmlEnableState_t isRestricted);
        /// 
        /// /**
        ///  * @}
        ///  */
        ///  
        /// /** @addtogroup nvmlAccountingStats
        ///  *  @{
        ///  */
        /// 
        /// /**
        ///  * Enables or disables per process accounting.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  * Requires root/admin permissions.
        ///  *
        ///  * @note This setting is not persistent and will default to disabled after driver unloads.
        ///  *       Enable persistence mode to be sure the setting doesn't switch off to disabled.
        ///  * 
        ///  * @note Enabling accounting mode has no negative impact on the GPU performance.
        ///  *
        ///  * @note Disabling accounting clears all accounting pids information.
        ///  *
        ///  * See \ref nvmlDeviceGetAccountingMode
        ///  * See \ref nvmlDeviceGetAccountingStats
        ///  * See \ref nvmlDeviceClearAccountingPids
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param mode                                 The target accounting mode
        ///  *
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if the new mode has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device or \a mode are invalid
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature
        ///  *         - \ref NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceSetAccountingMode(nvmlDevice_t device, nvmlEnableState_t mode);
        /// 
        /// /**
        ///  * Clears accounting information about all processes that have already terminated.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  * Requires root/admin permissions.
        ///  *
        ///  * See \ref nvmlDeviceGetAccountingMode
        ///  * See \ref nvmlDeviceGetAccountingStats
        ///  * See \ref nvmlDeviceSetAccountingMode
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  *
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if accounting information has been cleared 
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device are invalid
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature
        ///  *         - \ref NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceClearAccountingPids(nvmlDevice_t device);
        /// 
        /// /** @} */
        /// 
        /// /***************************************************************************************************/
        /// /** @defgroup NvLink NvLink Methods
        ///  * This chapter describes methods that NVML can perform on NVLINK enabled devices.
        ///  *  @{
        ///  */
        /// /***************************************************************************************************/
        /// 
        /// /**
        ///  * Retrieves the state of the device's NvLink for the link specified
        ///  *
        ///  * For Pascal &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param link                                 Specifies the NvLink link to be queried
        ///  * @param isActive                             \a nvmlEnableState_t where NVML_FEATURE_ENABLED indicates that
        ///  *                                             the link is active and NVML_FEATURE_DISABLED indicates it 
        ///  *                                             is inactive
        ///  *
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a isActive has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device or \a link is invalid or \a isActive is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetNvLinkState(nvmlDevice_t device, unsigned int link, nvmlEnableState_t *isActive);
        /// 
        /// /**
        ///  * Retrieves the version of the device's NvLink for the link specified
        ///  *
        ///  * For Pascal &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param link                                 Specifies the NvLink link to be queried
        ///  * @param version                              Requested NvLink version
        ///  *
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a version has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device or \a link is invalid or \a version is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetNvLinkVersion(nvmlDevice_t device, unsigned int link, unsigned int *version);
        /// 
        /// /**
        ///  * Retrieves the requested capability from the device's NvLink for the link specified
        ///  * Please refer to the \a nvmlNvLinkCapability_t structure for the specific caps that can be queried
        ///  * The return value should be treated as a boolean.
        ///  *
        ///  * For Pascal &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param link                                 Specifies the NvLink link to be queried
        ///  * @param capability                           Specifies the \a nvmlNvLinkCapability_t to be queried
        ///  * @param capResult                            A boolean for the queried capability indicating that feature is available
        ///  *
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a capResult has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device, \a link, or \a capability is invalid or \a capResult is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetNvLinkCapability(nvmlDevice_t device, unsigned int link,
        ///                                                    nvmlNvLinkCapability_t capability, unsigned int *capResult); 
        /// 
        /// /**
        ///  * Retrieves the PCI information for the remote node on a NvLink link 
        ///  * Note: pciSubSystemId is not filled in this function and is indeterminate
        ///  *
        ///  * For Pascal &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param link                                 Specifies the NvLink link to be queried
        ///  * @param pci                                  \a nvmlPciInfo_t of the remote node for the specified link                            
        ///  *
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a pci has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device or \a link is invalid or \a pci is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetNvLinkRemotePciInfo(nvmlDevice_t device, unsigned int link, nvmlPciInfo_t *pci);
        /// 
        /// /**
        ///  * Retrieves the specified error counter value
        ///  * Please refer to \a nvmlNvLinkErrorCounter_t for error counters that are available
        ///  *
        ///  * For Pascal &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param link                                 Specifies the NvLink link to be queried
        ///  * @param counter                              Specifies the NvLink counter to be queried
        ///  * @param counterValue                         Returned counter value
        ///  *
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a counter has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device, \a link, or \a counter is invalid or \a counterValue is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetNvLinkErrorCounter(nvmlDevice_t device, unsigned int link,
        ///                                                      nvmlNvLinkErrorCounter_t counter, unsigned long long *counterValue);
        /// 
        /// /**
        ///  * Resets all error counters to zero
        ///  * Please refer to \a nvmlNvLinkErrorCounter_t for the list of error counters that are reset
        ///  *
        ///  * For Pascal &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param link                                 Specifies the NvLink link to be queried
        ///  *
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if the reset is successful
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device or \a link is invalid
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceResetNvLinkErrorCounters(nvmlDevice_t device, unsigned int link);
        /// 
        /// /**
        ///  * Set the NVLINK utilization counter control information for the specified counter, 0 or 1.
        ///  * Please refer to \a nvmlNvLinkUtilizationControl_t for the structure definition.  Performs a reset
        ///  * of the counters if the reset parameter is non-zero.
        ///  *
        ///  * For Pascal &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param counter                              Specifies the counter that should be set (0 or 1).
        ///  * @param link                                 Specifies the NvLink link to be queried
        ///  * @param control                              A reference to the \a nvmlNvLinkUtilizationControl_t to set
        ///  * @param reset                                Resets the counters on set if non-zero
        ///  *
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if the control has been set successfully
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device, \a counter, \a link, or \a control is invalid 
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceSetNvLinkUtilizationControl(nvmlDevice_t device, unsigned int link, unsigned int counter,
        ///                                                            nvmlNvLinkUtilizationControl_t *control, unsigned int reset);
        /// 
        /// /**
        ///  * Get the NVLINK utilization counter control information for the specified counter, 0 or 1.
        ///  * Please refer to \a nvmlNvLinkUtilizationControl_t for the structure definition
        ///  *
        ///  * For Pascal &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param counter                              Specifies the counter that should be set (0 or 1).
        ///  * @param link                                 Specifies the NvLink link to be queried
        ///  * @param control                              A reference to the \a nvmlNvLinkUtilizationControl_t to place information
        ///  *
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if the control has been set successfully
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device, \a counter, \a link, or \a control is invalid 
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetNvLinkUtilizationControl(nvmlDevice_t device, unsigned int link, unsigned int counter,
        ///                                                            nvmlNvLinkUtilizationControl_t *control);
        /// 
        /// 
        /// /**
        ///  * Retrieve the NVLINK utilization counter based on the current control for a specified counter.
        ///  * In general it is good practice to use \a nvmlDeviceSetNvLinkUtilizationControl
        ///  *  before reading the utilization counters as they have no default state
        ///  *
        ///  * For Pascal &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param link                                 Specifies the NvLink link to be queried
        ///  * @param counter                              Specifies the counter that should be read (0 or 1).
        ///  * @param rxcounter                            Receive counter return value
        ///  * @param txcounter                            Transmit counter return value
        ///  *
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a rxcounter and \a txcounter have been successfully set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device, \a counter, or \a link is invalid or \a rxcounter or \a txcounter are NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetNvLinkUtilizationCounter(nvmlDevice_t device, unsigned int link, unsigned int counter, 
        ///                                                            unsigned long long *rxcounter, unsigned long long *txcounter);
        /// 
        /// /**
        ///  * Freeze the NVLINK utilization counters 
        ///  * Both the receive and transmit counters are operated on by this function
        ///  *
        ///  * For Pascal &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param link                                 Specifies the NvLink link to be queried
        ///  * @param counter                              Specifies the counter that should be frozen (0 or 1).
        ///  * @param freeze                               NVML_FEATURE_ENABLED = freeze the receive and transmit counters
        ///  *                                             NVML_FEATURE_DISABLED = unfreeze the receive and transmit counters
        ///  *
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if counters were successfully frozen or unfrozen
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device, \a link, \a counter, or \a freeze is invalid
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceFreezeNvLinkUtilizationCounter (nvmlDevice_t device, unsigned int link, 
        ///                                             unsigned int counter, nvmlEnableState_t freeze);
        /// 
        /// /**
        ///  * Reset the NVLINK utilization counters 
        ///  * Both the receive and transmit counters are operated on by this function
        ///  *
        ///  * For Pascal &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param link                                 Specifies the NvLink link to be reset
        ///  * @param counter                              Specifies the counter that should be reset (0 or 1)
        ///  *
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if counters were successfully reset
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device, \a link, or \a counter is invalid
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceResetNvLinkUtilizationCounter (nvmlDevice_t device, unsigned int link, unsigned int counter);
        /// 
        /// /** @} */
        /// 
        /// /***************************************************************************************************/
        /// /** @defgroup nvmlEvents Event Handling Methods
        ///  * This chapter describes methods that NVML can perform against each device to register and wait for 
        ///  * some event to occur.
        ///  *  @{
        ///  */
        /// /***************************************************************************************************/
        /// 
        /// /**
        ///  * Create an empty set of events.
        ///  * Event set should be freed by \ref nvmlEventSetFree
        ///  *
        ///  * For Fermi &amp;tm; or newer fully supported devices.
        ///  * @param set                                  Reference in which to return the event handle
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if the event has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a set is NULL
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  * 
        ///  * @see nvmlEventSetFree
        ///  */
        /// nvmlReturn_t DECLDIR nvmlEventSetCreate(nvmlEventSet_t *set);
        /// 
        /// /**
        ///  * Starts recording of events on a specified devices and add the events to specified \ref nvmlEventSet_t
        ///  *
        ///  * For Fermi &amp;tm; or newer fully supported devices.
        ///  * Ecc events are available only on ECC enabled devices (see \ref nvmlDeviceGetTotalEccErrors)
        ///  * Power capping events are available only on Power Management enabled devices (see \ref nvmlDeviceGetPowerManagementMode)
        ///  *
        ///  * For Linux only.
        ///  *
        ///  * \b IMPORTANT: Operations on \a set are not thread safe
        ///  *
        ///  * This call starts recording of events on specific device.
        ///  * All events that occurred before this call are not recorded.
        ///  * Checking if some event occurred can be done with \ref nvmlEventSetWait
        ///  *
        ///  * If function reports NVML_ERROR_UNKNOWN, event set is in undefined state and should be freed.
        ///  * If function reports NVML_ERROR_NOT_SUPPORTED, event set can still be used. None of the requested eventTypes
        ///  *     are registered in that case.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param eventTypes                           Bitmask of \ref nvmlEventType to record
        ///  * @param set                                  Set to which add new event types
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if the event has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a eventTypes is invalid or \a set is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the platform does not support this feature or some of requested event types
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  * 
        ///  * @see nvmlEventType
        ///  * @see nvmlDeviceGetSupportedEventTypes
        ///  * @see nvmlEventSetWait
        ///  * @see nvmlEventSetFree
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceRegisterEvents(nvmlDevice_t device, unsigned long long eventTypes, nvmlEventSet_t set);
        /// 
        /// /**
        ///  * Returns information about events supported on device
        ///  *
        ///  * For Fermi &amp;tm; or newer fully supported devices.
        ///  *
        ///  * Events are not supported on Windows. So this function returns an empty mask in \a eventTypes on Windows.
        ///  *
        ///  * @param device                               The identifier of the target device
        ///  * @param eventTypes                           Reference in which to return bitmask of supported events
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if the eventTypes has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a eventType is NULL
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  * 
        ///  * @see nvmlEventType
        ///  * @see nvmlDeviceRegisterEvents
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetSupportedEventTypes(nvmlDevice_t device, unsigned long long *eventTypes);
        /// 
        /// /**
        ///  * Waits on events and delivers events
        ///  *
        ///  * For Fermi &amp;tm; or newer fully supported devices.
        ///  *
        ///  * If some events are ready to be delivered at the time of the call, function returns immediately.
        ///  * If there are no events ready to be delivered, function sleeps till event arrives 
        ///  * but not longer than specified timeout. This function in certain conditions can return before
        ///  * specified timeout passes (e.g. when interrupt arrives)
        ///  * 
        ///  * In case of xid error, the function returns the most recent xid error type seen by the system. If there are multiple
        ///  * xid errors generated before nvmlEventSetWait is invoked then the last seen xid error type is returned for all
        ///  * xid error events.
        ///  * 
        ///  * @param set                                  Reference to set of events to wait on
        ///  * @param data                                 Reference in which to return event data
        ///  * @param timeoutms                            Maximum amount of wait time in milliseconds for registered event
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if the data has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a data is NULL
        ///  *         - \ref NVML_ERROR_TIMEOUT           if no event arrived in specified timeout or interrupt arrived
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if a GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  * 
        ///  * @see nvmlEventType
        ///  * @see nvmlDeviceRegisterEvents
        ///  */
        /// nvmlReturn_t DECLDIR nvmlEventSetWait(nvmlEventSet_t set, nvmlEventData_t * data, unsigned int timeoutms);
        /// 
        /// /**
        ///  * Releases events in the set
        ///  *
        ///  * For Fermi &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param set                                  Reference to events to be released 
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if the event has been successfully released
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  * 
        ///  * @see nvmlDeviceRegisterEvents
        ///  */
        /// nvmlReturn_t DECLDIR nvmlEventSetFree(nvmlEventSet_t set);
        /// 
        /// /** @} */
        /// 
        /// /***************************************************************************************************/
        /// /** @defgroup nvmlZPI Drain states 
        ///  * This chapter describes methods that NVML can perform against each device to control their drain state
        ///  * and recognition by NVML and NVIDIA kernel driver. These methods can be used with out-of-band tools to
        ///  * power on/off GPUs, enable robust reset scenarios, etc.
        ///  *  @{
        ///  */
        /// /***************************************************************************************************/
        /// 
        /// /**
        ///  * Modify the drain state of a GPU.  This method forces a GPU to no longer accept new incoming requests.
        ///  * Any new NVML process will no longer see this GPU.  Persistence mode for this GPU must be turned off before
        ///  * this call is made.
        ///  * Must be called as administrator.
        ///  * For Linux only.
        ///  * 
        ///  * For Pascal &amp;tm; or newer fully supported devices.
        ///  * Some Kepler devices supported.
        ///  *
        ///  * @param pciInfo                              The PCI address of the GPU drain state to be modified
        ///  * @param newState                             The drain state that should be entered, see \ref nvmlEnableState_t
        ///  *
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if counters were successfully reset
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a nvmlIndex or \a newState is invalid
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature
        ///  *         - \ref NVML_ERROR_NO_PERMISSION     if the calling process has insufficient permissions to perform operation
        ///  *         - \ref NVML_ERROR_IN_USE            if the device has persistence mode turned on
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceModifyDrainState (nvmlPciInfo_t *pciInfo, nvmlEnableState_t newState);
        /// 
        /// /**
        ///  * Query the drain state of a GPU.  This method is used to check if a GPU is in a currently draining
        ///  * state.
        ///  * For Linux only.
        ///  * 
        ///  * For Pascal &amp;tm; or newer fully supported devices.
        ///  * Some Kepler devices supported.
        ///  *
        ///  * @param pciInfo                              The PCI address of the GPU drain state to be queried
        ///  * @param currentState                         The current drain state for this GPU, see \ref nvmlEnableState_t
        ///  *
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if counters were successfully reset
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a nvmlIndex or \a currentState is invalid
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceQueryDrainState (nvmlPciInfo_t *pciInfo, nvmlEnableState_t *currentState);
        /// 
        /// /**
        ///  * This method will remove the specified GPU from the view of both NVML and the NVIDIA kernel driver
        ///  * as long as no other processes are attached. If other processes are attached, this call will return
        ///  * NVML_ERROR_IN_USE and the GPU will be returned to its original "draining" state. Note: the
        ///  * only situation where a process can still be attached after nvmlDeviceModifyDrainState() is called
        ///  * to initiate the draining state is if that process was using, and is still using, a GPU before the 
        ///  * call was made. Also note, persistence mode counts as an attachment to the GPU thus it must be disabled
        ///  * prior to this call.
        ///  *
        ///  * For long-running NVML processes please note that this will change the enumeration of current GPUs.
        ///  * For example, if there are four GPUs present and GPU1 is removed, the new enumeration will be 0-2.
        ///  * Also, device handles after the removed GPU will not be valid and must be re-established.
        ///  * Must be run as administrator. 
        ///  * For Linux only.
        ///  *
        ///  * For Pascal &amp;tm; or newer fully supported devices.
        ///  * Some Kepler devices supported.
        ///  *
        ///  * @param pciInfo                              The PCI address of the GPU to be removed
        ///  * @param gpuState                             Whether the GPU is to be removed, from the OS
        ///  *                                             see \ref nvmlDetachGpuState_t
        ///  * @param linkState                            Requested upstream PCIe link state, see \ref nvmlPcieLinkState_t
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if counters were successfully reset
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a nvmlIndex is invalid
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature
        ///  *         - \ref NVML_ERROR_IN_USE            if the device is still in use and cannot be removed
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceRemoveGpu (nvmlPciInfo_t *pciInfo, nvmlDetachGpuState_t gpuState, nvmlPcieLinkState_t linkState);
        /// 
        /// /**
        ///  * Request the OS and the NVIDIA kernel driver to rediscover a portion of the PCI subsystem looking for GPUs that
        ///  * were previously removed. The portion of the PCI tree can be narrowed by specifying a domain, bus, and device.  
        ///  * If all are zeroes then the entire PCI tree will be searched.  Please note that for long-running NVML processes
        ///  * the enumeration will change based on how many GPUs are discovered and where they are inserted in bus order.
        ///  *
        ///  * In addition, all newly discovered GPUs will be initialized and their ECC scrubbed which may take several seconds
        ///  * per GPU. Also, all device handles are no longer guaranteed to be valid post discovery.
        ///  *
        ///  * Must be run as administrator.
        ///  * For Linux only.
        ///  * 
        ///  * For Pascal &amp;tm; or newer fully supported devices.
        ///  * Some Kepler devices supported.
        ///  *
        ///  * @param pciInfo                              The PCI tree to be searched.  Only the domain, bus, and device
        ///  *                                             fields are used in this call.
        ///  *
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if counters were successfully reset
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a pciInfo is invalid
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the operating system does not support this feature
        ///  *         - \ref NVML_ERROR_OPERATING_SYSTEM  if the operating system is denying this feature
        ///  *         - \ref NVML_ERROR_NO_PERMISSION     if the calling process has insufficient permissions to perform operation
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceDiscoverGpus (nvmlPciInfo_t *pciInfo);
        /// 
        /// /** @} */
        /// 
        /// /***************************************************************************************************/
        /// /** @defgroup nvmlFieldValueQueries Field Value Queries
        ///  *  This chapter describes NVML operations that are associated with retrieving Field Values from NVML
        ///  *  @{
        ///  */
        /// /***************************************************************************************************/
        /// 
        /// /**
        ///  * Request values for a list of fields for a device. This API allows multiple fields to be queried at once.
        ///  * If any of the underlying fieldIds are populated by the same driver call, the results for those field IDs
        ///  * will be populated from a single call rather than making a driver call for each fieldId.
        ///  *
        ///  * @param device                               The device handle of the GPU to request field values for
        ///  * @param valuesCount                          Number of entries in values that should be retrieved
        ///  * @param values                               Array of \a valuesCount structures to hold field values.
        ///  *                                             Each value's fieldId must be populated prior to this call
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if any values in \a values were populated. Note that you must
        ///  *                                             check the nvmlReturn field of each value for each individual
        ///  *                                             status
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a values is NULL
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetFieldValues(nvmlDevice_t device, int valuesCount, nvmlFieldValue_t *values);
        /// 
        /// 
        /// /** @} */
        /// 
        /// /***************************************************************************************************/
        /// /** @defgroup nvmlGridQueries Grid Queries
        ///  *  This chapter describes NVML operations that are associated with NVIDIA GRID products.
        ///  *  @{
        ///  */
        /// /***************************************************************************************************/
        /// 
        /// /**
        ///  * This method is used to get the virtualization mode corresponding to the GPU.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                    Identifier of the target device
        ///  * @param pVirtualMode              Reference to virtualization mode. One of NVML_GPU_VIRTUALIZATION_?
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                  if \a pVirtualMode is fetched
        ///  *         - \ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT   if \a device is invalid or \a pVirtualMode is NULL
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST        if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN            on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetVirtualizationMode(nvmlDevice_t device, nvmlGpuVirtualizationMode_t *pVirtualMode);
        /// 
        /// /** @} */
        /// 
        /// /***************************************************************************************************/
        /// /** @defgroup nvmlGridCommands Grid Commands
        ///  *  This chapter describes NVML operations that are associated with NVIDIA GRID products.
        ///  *  @{
        ///  */
        /// /***************************************************************************************************/
        /// 
        /// /**
        ///  * This method is used to set the virtualization mode corresponding to the GPU.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                    Identifier of the target device
        ///  * @param virtualMode               virtualization mode. One of NVML_GPU_VIRTUALIZATION_?
        ///  *
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                  if \a pVirtualMode is set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT   if \a device is invalid or \a pVirtualMode is NULL
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST        if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED      if setting of virtualization mode is not supported.
        ///  *         - \ref NVML_ERROR_NO_PERMISSION      if setting of virtualization mode is not allowed for this client.
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceSetVirtualizationMode(nvmlDevice_t device, nvmlGpuVirtualizationMode_t virtualMode);
        /// 
        /// /** @} */
        /// 
        /// /***************************************************************************************************/
        /// /** @defgroup nvmlVgpu vGPU Management
        ///  * @{
        ///  *
        ///  * Set of APIs supporting GRID vGPU
        ///  */
        /// /***************************************************************************************************/
        /// 
        /// /**
        ///  * Retrieve the supported vGPU types on a physical GPU (device).
        ///  *
        ///  * An array of supported vGPU types for the physical GPU indicated by \a device is returned in the caller-supplied buffer
        ///  * pointed at by \a vgpuTypeIds. The element count of nvmlVgpuTypeId_t array is passed in \a vgpuCount, and \a vgpuCount
        ///  * is used to return the number of vGPU types written to the buffer.
        ///  *
        ///  * If the supplied buffer is not large enough to accomodate the vGPU type array, the function returns
        ///  * NVML_ERROR_INSUFFICIENT_SIZE, with the element count of nvmlVgpuTypeId_t array required in \a vgpuCount.
        ///  * To query the number of vGPU types supported for the GPU, call this function with *vgpuCount = 0.
        ///  * The code will return NVML_ERROR_INSUFFICIENT_SIZE, or NVML_SUCCESS if no vGPU types are supported.
        ///  *
        ///  * @param device                   The identifier of the target device
        ///  * @param vgpuCount                Pointer to caller-supplied array size, and returns number of vGPU types
        ///  * @param vgpuTypeIds              Pointer to caller-supplied array in which to return list of vGPU types
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                      successful completion
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE      \a vgpuTypeIds buffer is too small, array element count is returned in \a vgpuCount
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT       if \a vgpuCount is NULL or \a device is invalid
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED          if vGPU is not supported by the device
        ///  *         - \ref NVML_ERROR_VGPU_ECC_NOT_SUPPORTED if ECC is enabled on the device
        ///  *         - \ref NVML_ERROR_UNKNOWN                on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetSupportedVgpus(nvmlDevice_t device, unsigned int *vgpuCount, nvmlVgpuTypeId_t *vgpuTypeIds);
        /// 
        /// /**
        ///  * Retrieve the currently creatable vGPU types on a physical GPU (device).
        ///  *
        ///  * An array of creatable vGPU types for the physical GPU indicated by \a device is returned in the caller-supplied buffer
        ///  * pointed at by \a vgpuTypeIds. The element count of nvmlVgpuTypeId_t array is passed in \a vgpuCount, and \a vgpuCount
        ///  * is used to return the number of vGPU types written to the buffer.
        ///  *
        ///  * The creatable vGPU types for a device may differ over time, as there may be restrictions on what type of vGPU types
        ///  * can concurrently run on a device.  For example, if only one vGPU type is allowed at a time on a device, then the creatable
        ///  * list will be restricted to whatever vGPU type is already running on the device.
        ///  *
        ///  * If the supplied buffer is not large enough to accomodate the vGPU type array, the function returns
        ///  * NVML_ERROR_INSUFFICIENT_SIZE, with the element count of nvmlVgpuTypeId_t array required in \a vgpuCount.
        ///  * To query the number of vGPU types createable for the GPU, call this function with *vgpuCount = 0.
        ///  * The code will return NVML_ERROR_INSUFFICIENT_SIZE, or NVML_SUCCESS if no vGPU types are creatable.
        ///  *
        ///  * @param device                   The identifier of the target device
        ///  * @param vgpuCount                Pointer to caller-supplied array size, and returns number of vGPU types
        ///  * @param vgpuTypeIds              Pointer to caller-supplied array in which to return list of vGPU types
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                      successful completion
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE      \a vgpuTypeIds buffer is too small, array element count is returned in \a vgpuCount
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT       if \a vgpuCount is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED          if vGPU is not supported by the device
        ///  *         - \ref NVML_ERROR_VGPU_ECC_NOT_SUPPORTED if ECC is enabled on the device
        ///  *         - \ref NVML_ERROR_UNKNOWN                on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetCreatableVgpus(nvmlDevice_t device, unsigned int *vgpuCount, nvmlVgpuTypeId_t *vgpuTypeIds);
        /// 
        /// /**
        ///  * Retrieve the class of a vGPU type. It will not exceed 64 characters in length (including the NUL terminator).
        ///  * See \ref nvmlConstants::NVML_DEVICE_NAME_BUFFER_SIZE.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param vgpuTypeId               Handle to vGPU type
        ///  * @param vgpuTypeClass            Pointer to string array to return class in
        ///  * @param size                     Size of string
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                   successful completion
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT    if \a vgpuTypeId is invalid, or \a vgpuTypeClass is NULL
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE   if \a size is too small
        ///  *         - \ref NVML_ERROR_UNKNOWN             on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuTypeGetClass(nvmlVgpuTypeId_t vgpuTypeId, char *vgpuTypeClass, unsigned int *size);
        /// 
        /// /**
        ///  * Retrieve the vGPU type name.
        ///  *
        ///  * The name is an alphanumeric string that denotes a particular vGPU, e.g. GRID M60-2Q. It will not
        ///  * exceed 64 characters in length (including the NUL terminator).  See \ref
        ///  * nvmlConstants::NVML_DEVICE_NAME_BUFFER_SIZE.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param vgpuTypeId               Handle to vGPU type
        ///  * @param vgpuTypeName             Pointer to buffer to return name
        ///  * @param size                     Size of buffer
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 successful completion
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a vgpuTypeId is invalid, or \a name is NULL
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE if \a size is too small
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuTypeGetName(nvmlVgpuTypeId_t vgpuTypeId, char *vgpuTypeName, unsigned int *size);
        /// 
        /// /**
        ///  * Retrieve the device ID of a vGPU type.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param vgpuTypeId               Handle to vGPU type
        ///  * @param deviceID                 Device ID and vendor ID of the device contained in single 32 bit value
        ///  * @param subsystemID              Subsytem ID and subsytem vendor ID of the device contained in single 32 bit value
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 successful completion
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a vgpuTypeId is invalid, or \a deviceId or \a subsystemID are NULL
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuTypeGetDeviceID(nvmlVgpuTypeId_t vgpuTypeId, unsigned long long *deviceID, unsigned long long *subsystemID);
        /// 
        /// /**
        ///  * Retrieve the vGPU framebuffer size in bytes.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param vgpuTypeId               Handle to vGPU type
        ///  * @param fbSize                   Pointer to framebuffer size in bytes
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 successful completion
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a vgpuTypeId is invalid, or \a fbSize is NULL
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuTypeGetFramebufferSize(nvmlVgpuTypeId_t vgpuTypeId, unsigned long long *fbSize);
        /// 
        /// /**
        ///  * Retrieve count of vGPU's supported display heads.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param vgpuTypeId               Handle to vGPU type
        ///  * @param numDisplayHeads          Pointer to number of display heads
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 successful completion
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a vgpuTypeId is invalid, or \a numDisplayHeads is NULL
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuTypeGetNumDisplayHeads(nvmlVgpuTypeId_t vgpuTypeId, unsigned int *numDisplayHeads);
        /// 
        /// /**
        ///  * Retrieve vGPU display head's maximum supported resolution.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param vgpuTypeId               Handle to vGPU type
        ///  * @param displayIndex             Zero-based index of display head
        ///  * @param xdim                     Pointer to maximum number of pixels in X dimension
        ///  * @param ydim                     Pointer to maximum number of pixels in Y dimension
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 successful completion
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a vgpuTypeId is invalid, or \a xdim or \a ydim are NULL, or \a displayIndex
        ///  *                                             is out of range.
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuTypeGetResolution(nvmlVgpuTypeId_t vgpuTypeId, unsigned int displayIndex, unsigned int *xdim, unsigned int *ydim);
        /// 
        /// /**
        ///  * Retrieve license requirements for a vGPU type
        ///  *
        ///  * The license type and version required to run the specified vGPU type is returned as an alphanumeric string, in the form
        ///  * "&lt;license name&gt;,&lt;version&gt;", for example "GRID-Virtual-PC,2.0". If a vGPU is runnable with* more than one type of license,
        ///  * the licenses are delimited by a semicolon, for example "GRID-Virtual-PC,2.0;GRID-Virtual-WS,2.0;GRID-Virtual-WS-Ext,2.0".
        ///  *
        ///  * The total length of the returned string will not exceed 128 characters, including the NUL terminator.
        ///  * See \ref nvmlVgpuConstants::NVML_GRID_LICENSE_BUFFER_SIZE.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param vgpuTypeId               Handle to vGPU type
        ///  * @param vgpuTypeLicenseString    Pointer to buffer to return license info
        ///  * @param size                     Size of \a vgpuTypeLicenseString buffer
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 successful completion
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a vgpuTypeId is invalid, or \a vgpuTypeLicenseString is NULL
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE if \a size is too small
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuTypeGetLicense(nvmlVgpuTypeId_t vgpuTypeId, char *vgpuTypeLicenseString, unsigned int size);
        /// 
        /// /**
        ///  * Retrieve the static frame rate limit value of the vGPU type
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param vgpuTypeId               Handle to vGPU type
        ///  * @param frameRateLimit           Reference to return the frame rate limit value
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 successful completion
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if frame rate limiter is turned off for the vGPU type
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a vgpuTypeId is invalid, or \a frameRateLimit is NULL
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuTypeGetFrameRateLimit(nvmlVgpuTypeId_t vgpuTypeId, unsigned int *frameRateLimit);
        /// 
        /// /**
        ///  * Retrieve the maximum number of vGPU instances creatable on a device for given vGPU type
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                   The identifier of the target device
        ///  * @param vgpuTypeId               Handle to vGPU type
        ///  * @param vgpuInstanceCount        Pointer to get the max number of vGPU instances
        ///  *                                 that can be created on a deicve for given vgpuTypeId
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 successful completion
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a vgpuTypeId is invalid or is not supported on target device,
        ///  *                                             or \a vgpuInstanceCount is NULL
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuTypeGetMaxInstances(nvmlDevice_t device, nvmlVgpuTypeId_t vgpuTypeId, unsigned int *vgpuInstanceCount);
        /// 
        /// /**
        ///  * Retrieve the maximum number of vGPU instances supported per VM for given vGPU type
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param vgpuTypeId               Handle to vGPU type
        ///  * @param vgpuInstanceCountPerVm   Pointer to get the max number of vGPU instances supported per VM for given \a vgpuTypeId
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 successful completion
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a vgpuTypeId is invalid, or \a vgpuInstanceCountPerVm is NULL
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuTypeGetMaxInstancesPerVm(nvmlVgpuTypeId_t vgpuTypeId, unsigned int *vgpuInstanceCountPerVm);
        /// 
        /// /**
        ///  * Retrieve the active vGPU instances on a device.
        ///  *
        ///  * An array of active vGPU instances is returned in the caller-supplied buffer pointed at by \a vgpuInstances. The
        ///  * array elememt count is passed in \a vgpuCount, and \a vgpuCount is used to return the number of vGPU instances
        ///  * written to the buffer.
        ///  *
        ///  * If the supplied buffer is not large enough to accomodate the vGPU instance array, the function returns
        ///  * NVML_ERROR_INSUFFICIENT_SIZE, with the element count of nvmlVgpuInstance_t array required in \a vgpuCount.
        ///  * To query the number of active vGPU instances, call this function with *vgpuCount = 0.  The code will return
        ///  * NVML_ERROR_INSUFFICIENT_SIZE, or NVML_SUCCESS if no vGPU Types are supported.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                   The identifier of the target device
        ///  * @param vgpuCount                Pointer which passes in the array size as well as get
        ///  *                                 back the number of types
        ///  * @param vgpuInstances            Pointer to array in which to return list of vGPU instances
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                  successful completion
        ///  *         - \ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT   if \a device is invalid, or \a vgpuCount is NULL
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE  if \a size is too small
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED      if vGPU is not supported by the device
        ///  *         - \ref NVML_ERROR_UNKNOWN            on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetActiveVgpus(nvmlDevice_t device, unsigned int *vgpuCount, nvmlVgpuInstance_t *vgpuInstances);
        /// 
        /// /**
        ///  * Retrieve the VM ID associated with a vGPU instance.
        ///  *
        ///  * The VM ID is returned as a string, not exceeding 80 characters in length (including the NUL terminator).
        ///  * See \ref nvmlConstants::NVML_DEVICE_UUID_BUFFER_SIZE.
        ///  *
        ///  * The format of the VM ID varies by platform, and is indicated by the type identifier returned in \a vmIdType.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param vgpuInstance             Identifier of the target vGPU instance
        ///  * @param vmId                     Pointer to caller-supplied buffer to hold VM ID
        ///  * @param size                     Size of buffer in bytes
        ///  * @param vmIdType                 Pointer to hold VM ID type
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 successful completion
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a vmId or \a vmIdType is NULL, or \a vgpuInstance is 0
        ///  *         - \ref NVML_ERROR_NOT_FOUND         if \a vgpuInstance does not match a valid active vGPU instance on the system
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE if \a size is too small
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuInstanceGetVmID(nvmlVgpuInstance_t vgpuInstance, char *vmId, unsigned int size, nvmlVgpuVmIdType_t *vmIdType);
        /// 
        /// /**
        ///  * Retrieve the UUID of a vGPU instance.
        ///  *
        ///  * The UUID is a globally unique identifier associated with the vGPU, and is returned as a 5-part hexadecimal string,
        ///  * not exceeding 80 characters in length (including the NULL terminator).
        ///  * See \ref nvmlConstants::NVML_DEVICE_UUID_BUFFER_SIZE.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param vgpuInstance             Identifier of the target vGPU instance
        ///  * @param uuid                     Pointer to caller-supplied buffer to hold vGPU UUID
        ///  * @param size                     Size of buffer in bytes
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 successful completion
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a vgpuInstance is 0, or \a uuid is NULL
        ///  *         - \ref NVML_ERROR_NOT_FOUND         if \a vgpuInstance does not match a valid active vGPU instance on the system
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE if \a size is too small
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuInstanceGetUUID(nvmlVgpuInstance_t vgpuInstance, char *uuid, unsigned int size);
        /// 
        /// /**
        ///  * Retrieve the NVIDIA driver version installed in the VM associated with a vGPU.
        ///  *
        ///  * The version is returned as an alphanumeric string in the caller-supplied buffer \a version. The length of the version
        ///  * string will not exceed 80 characters in length (including the NUL terminator).
        ///  * See \ref nvmlConstants::NVML_SYSTEM_DRIVER_VERSION_BUFFER_SIZE.
        ///  *
        ///  * nvmlVgpuInstanceGetVmDriverVersion() may be called at any time for a vGPU instance. The guest VM driver version is
        ///  * returned as "Unknown" if no NVIDIA driver is installed in the VM, or the VM has not yet booted to the point where the
        ///  * NVIDIA driver is loaded and initialized.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param vgpuInstance             Identifier of the target vGPU instance
        ///  * @param version                  Caller-supplied buffer to return driver version string
        ///  * @param length                   Size of \a version buffer
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if \a version has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a vgpuInstance is 0
        ///  *         - \ref NVML_ERROR_NOT_FOUND         if \a vgpuInstance does not match a valid active vGPU instance on the system
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE if \a length is too small
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuInstanceGetVmDriverVersion(nvmlVgpuInstance_t vgpuInstance, char* version, unsigned int length);
        /// 
        /// /**
        ///  * Retrieve the framebuffer usage in bytes.
        ///  *
        ///  * Framebuffer usage is the amont of vGPU framebuffer memory that is currently in use by the VM.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param vgpuInstance             The identifier of the target instance
        ///  * @param fbUsage                  Pointer to framebuffer usage in bytes
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 successful completion
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a vgpuInstance is 0, or \a fbUsage is NULL
        ///  *         - \ref NVML_ERROR_NOT_FOUND         if \a vgpuInstance does not match a valid active vGPU instance on the system
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuInstanceGetFbUsage(nvmlVgpuInstance_t vgpuInstance, unsigned long long *fbUsage);
        /// 
        /// /**
        ///  * Retrieve the current licensing state of the vGPU instance.
        ///  *
        ///  * If the vGPU is currently licensed, \a licensed is set to 1, otherwise it is set to 0.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param vgpuInstance             Identifier of the target vGPU instance
        ///  * @param licensed                 Reference to return the licensing status
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if \a licensed has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a vgpuInstance is 0, or \a licensed is NULL
        ///  *         - \ref NVML_ERROR_NOT_FOUND         if \a vgpuInstance does not match a valid active vGPU instance on the system
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuInstanceGetLicenseStatus(nvmlVgpuInstance_t vgpuInstance, unsigned int *licensed);
        /// 
        /// /**
        ///  * Retrieve the vGPU type of a vGPU instance.
        ///  *
        ///  * Returns the vGPU type ID of vgpu assigned to the vGPU instance.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param vgpuInstance             Identifier of the target vGPU instance
        ///  * @param vgpuTypeId               Reference to return the vgpuTypeId
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if \a vgpuTypeId has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a vgpuInstance is 0, or \a vgpuTypeId is NULL
        ///  *         - \ref NVML_ERROR_NOT_FOUND         if \a vgpuInstance does not match a valid active vGPU instance on the system
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuInstanceGetType(nvmlVgpuInstance_t vgpuInstance, nvmlVgpuTypeId_t *vgpuTypeId);
        /// 
        /// /**
        ///  * Retrieve the frame rate limit set for the vGPU instance.
        ///  *
        ///  * Returns the value of the frame rate limit set for the vGPU instance
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param vgpuInstance             Identifier of the target vGPU instance
        ///  * @param frameRateLimit           Reference to return the frame rate limit
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if \a frameRateLimit has been set
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if frame rate limiter is turned off for the vGPU type
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a vgpuInstance is 0, or \a frameRateLimit is NULL
        ///  *         - \ref NVML_ERROR_NOT_FOUND         if \a vgpuInstance does not match a valid active vGPU instance on the system
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuInstanceGetFrameRateLimit(nvmlVgpuInstance_t vgpuInstance, unsigned int *frameRateLimit);
        /// 
        /// /**
        ///  * Retrieve the encoder capacity of a vGPU instance, as a percentage of maximum encoder capacity with valid values in the range 0-100.
        ///  *
        ///  * For Maxwell &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param vgpuInstance             Identifier of the target vGPU instance
        ///  * @param encoderCapacity          Reference to an unsigned int for the encoder capacity
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if \a encoderCapacity has been retrived
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a vgpuInstance is 0, or \a encoderQueryType is invalid
        ///  *         - \ref NVML_ERROR_NOT_FOUND         if \a vgpuInstance does not match a valid active vGPU instance on the system
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuInstanceGetEncoderCapacity(nvmlVgpuInstance_t vgpuInstance, unsigned int *encoderCapacity);
        /// 
        /// /**
        ///  * Set the encoder capacity of a vGPU instance, as a percentage of maximum encoder capacity with valid values in the range 0-100.
        ///  *
        ///  * For Maxwell &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param vgpuInstance             Identifier of the target vGPU instance
        ///  * @param encoderCapacity          Unsigned int for the encoder capacity value
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if \a encoderCapacity has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a vgpuInstance is 0, or \a encoderCapacity is out of range of 0-100.
        ///  *         - \ref NVML_ERROR_NOT_FOUND         if \a vgpuInstance does not match a valid active vGPU instance on the system
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuInstanceSetEncoderCapacity(nvmlVgpuInstance_t vgpuInstance, unsigned int  encoderCapacity);
        /// 
        /// /**
        ///  * Retrieves current utilization for vGPUs on a physical GPU (device).
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * Reads recent utilization of GPU SM (3D/Compute), framebuffer, video encoder, and video decoder for vGPU instances running
        ///  * on a device. Utilization values are returned as an array of utilization sample structures in the caller-supplied buffer
        ///  * pointed at by \a utilizationSamples. One utilization sample structure is returned per vGPU instance, and includes the
        ///  * CPU timestamp at which the samples were recorded. Individual utilization values are returned as "unsigned int" values
        ///  * in nvmlValue_t unions. The function sets the caller-supplied \a sampleValType to NVML_VALUE_TYPE_UNSIGNED_INT to
        ///  * indicate the returned value type.
        ///  *
        ///  * To read utilization values, first determine the size of buffer required to hold the samples by invoking the function with
        ///  * \a utilizationSamples set to NULL. The function will return NVML_ERROR_INSUFFICIENT_SIZE, with the current vGPU instance
        ///  * count in \a vgpuInstanceSamplesCount, or NVML_SUCCESS if the current vGPU instance count is zero. The caller should allocate
        ///  * a buffer of size vgpuInstanceSamplesCount * sizeof(nvmlVgpuInstanceUtilizationSample_t). Invoke the function again with
        ///  * the allocated buffer passed in \a utilizationSamples, and \a vgpuInstanceSamplesCount set to the number of entries the
        ///  * buffer is sized for.
        ///  *
        ///  * On successful return, the function updates \a vgpuInstanceSampleCount with the number of vGPU utilization sample
        ///  * structures that were actually written. This may differ from a previously read value as vGPU instances are created or
        ///  * destroyed.
        ///  *
        ///  * lastSeenTimeStamp represents the CPU timestamp in microseconds at which utilization samples were last read. Set it to 0
        ///  * to read utilization based on all the samples maintained by the driver's internal sample buffer. Set lastSeenTimeStamp
        ///  * to a timeStamp retrieved from a previous query to read utilization since the previous query.
        ///  *
        ///  * @param device                        The identifier for the target device
        ///  * @param lastSeenTimeStamp             Return only samples with timestamp greater than lastSeenTimeStamp.
        ///  * @param sampleValType                 Pointer to caller-supplied buffer to hold the type of returned sample values
        ///  * @param vgpuInstanceSamplesCount      Pointer to caller-supplied array size, and returns number of vGPU instances
        ///  * @param utilizationSamples            Pointer to caller-supplied buffer in which vGPU utilization samples are returned
        /// 
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if utilization samples are successfully retrieved
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, \a vgpuInstanceSamplesCount or \a sampleValType is
        ///  *                                             NULL, or a sample count of 0 is passed with a non-NULL \a utilizationSamples
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE if supplied \a vgpuInstanceSamplesCount is too small to return samples for all
        ///  *                                             vGPU instances currently executing on the device
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if vGPU is not supported by the device
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_NOT_FOUND         if sample entries are not found
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetVgpuUtilization(nvmlDevice_t device, unsigned long long lastSeenTimeStamp,
        ///                                                   nvmlValueType_t *sampleValType, unsigned int *vgpuInstanceSamplesCount,
        ///                                                   nvmlVgpuInstanceUtilizationSample_t *utilizationSamples);
        /// 
        /// /**
        ///  * Retrieves current utilization for processes running on vGPUs on a physical GPU (device).
        ///  *
        ///  * For Maxwell &amp;tm; or newer fully supported devices.
        ///  *
        ///  * Reads recent utilization of GPU SM (3D/Compute), framebuffer, video encoder, and video decoder for processes running on
        ///  * vGPU instances active on a device. Utilization values are returned as an array of utilization sample structures in the
        ///  * caller-supplied buffer pointed at by \a utilizationSamples. One utilization sample structure is returned per process running
        ///  * on vGPU instances, that had some non-zero utilization during the last sample period. It includes the CPU timestamp at which
        ///  * the samples were recorded. Individual utilization values are returned as "unsigned int" values.
        ///  *
        ///  * To read utilization values, first determine the size of buffer required to hold the samples by invoking the function with
        ///  * \a utilizationSamples set to NULL. The function will return NVML_ERROR_INSUFFICIENT_SIZE, with the current vGPU instance
        ///  * count in \a vgpuProcessSamplesCount. The caller should allocate a buffer of size
        ///  * vgpuProcessSamplesCount * sizeof(nvmlVgpuProcessUtilizationSample_t). Invoke the function again with
        ///  * the allocated buffer passed in \a utilizationSamples, and \a vgpuProcessSamplesCount set to the number of entries the
        ///  * buffer is sized for.
        ///  *
        ///  * On successful return, the function updates \a vgpuSubProcessSampleCount with the number of vGPU sub process utilization sample
        ///  * structures that were actually written. This may differ from a previously read value depending on the number of processes that are active
        ///  * in any given sample period.
        ///  *
        ///  * lastSeenTimeStamp represents the CPU timestamp in microseconds at which utilization samples were last read. Set it to 0
        ///  * to read utilization based on all the samples maintained by the driver's internal sample buffer. Set lastSeenTimeStamp
        ///  * to a timeStamp retrieved from a previous query to read utilization since the previous query.
        ///  *
        ///  * @param device                        The identifier for the target device
        ///  * @param lastSeenTimeStamp             Return only samples with timestamp greater than lastSeenTimeStamp.
        ///  * @param vgpuProcessSamplesCount       Pointer to caller-supplied array size, and returns number of processes running on vGPU instances
        ///  * @param utilizationSamples            Pointer to caller-supplied buffer in which vGPU sub process utilization samples are returned
        /// 
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if utilization samples are successfully retrieved
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, \a vgpuProcessSamplesCount or a sample count of 0 is
        ///  *                                             passed with a non-NULL \a utilizationSamples
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE if supplied \a vgpuProcessSamplesCount is too small to return samples for all
        ///  *                                             vGPU instances currently executing on the device
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if vGPU is not supported by the device
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_NOT_FOUND         if sample entries are not found
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetVgpuProcessUtilization(nvmlDevice_t device, unsigned long long lastSeenTimeStamp,
        ///                                                          unsigned int *vgpuProcessSamplesCount,
        ///                                                          nvmlVgpuProcessUtilizationSample_t *utilizationSamples);
        /// /**
        ///  * Retrieve the GRID licensable features.
        ///  *
        ///  * Identifies whether the system supports GRID Software Licensing. If it does, return the list of licensable feature(s)
        ///  * and their current license status.
        ///  *
        ///  * @param device                    Identifier of the target device
        ///  * @param pGridLicensableFeatures   Pointer to structure in which GRID licensable features are returned
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if licensable features are successfully retrieved
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a pGridLicensableFeatures is NULL
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetGridLicensableFeatures(nvmlDevice_t device, nvmlGridLicensableFeatures_t *pGridLicensableFeatures);
        /// 
        /// /**
        ///  * Retrieves the current encoder statistics of a vGPU Instance
        ///  *
        ///  * For Maxwell &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param vgpuInstance                      Identifier of the target vGPU instance
        ///  * @param sessionCount                      Reference to an unsigned int for count of active encoder sessions
        ///  * @param averageFps                        Reference to an unsigned int for trailing average FPS of all active sessions
        ///  * @param averageLatency                    Reference to an unsigned int for encode latency in microseconds
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                  if \a sessionCount, \a averageFps and \a averageLatency is fetched
        ///  *         - \ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT   if \a sessionCount , or \a averageFps or \a averageLatency is NULL
        ///  *                                              or \a vgpuInstance is 0.
        ///  *         - \ref NVML_ERROR_NOT_FOUND          if \a vgpuInstance does not match a valid active vGPU instance on the system
        ///  *         - \ref NVML_ERROR_UNKNOWN            on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuInstanceGetEncoderStats(nvmlVgpuInstance_t vgpuInstance, unsigned int *sessionCount,
        ///                                                      unsigned int *averageFps, unsigned int *averageLatency);
        /// 
        /// /**
        ///  * Retrieves information about all active encoder sessions on a vGPU Instance.
        ///  *
        ///  * An array of active encoder sessions is returned in the caller-supplied buffer pointed at by \a sessionInfo. The
        ///  * array element count is passed in \a sessionCount, and \a sessionCount is used to return the number of sessions
        ///  * written to the buffer.
        ///  *
        ///  * If the supplied buffer is not large enough to accomodate the active session array, the function returns
        ///  * NVML_ERROR_INSUFFICIENT_SIZE, with the element count of nvmlEncoderSessionInfo_t array required in \a sessionCount.
        ///  * To query the number of active encoder sessions, call this function with *sessionCount = 0. The code will return
        ///  * NVML_SUCCESS with number of active encoder sessions updated in *sessionCount.
        ///  *
        ///  * For Maxwell &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param vgpuInstance                      Identifier of the target vGPU instance
        ///  * @param sessionCount                      Reference to caller supplied array size, and returns
        ///  *                                          the number of sessions.
        ///  * @param sessionInfo                       Reference to caller supplied array in which the list
        ///  *                                          of session information us returned.
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                  if \a sessionInfo is fetched
        ///  *         - \ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE  if \a sessionCount is too small, array element count is
        ///                                                 returned in \a sessionCount
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT   if \a sessionCount is NULL, or \a vgpuInstance is 0.
        ///  *         - \ref NVML_ERROR_NOT_FOUND          if \a vgpuInstance does not match a valid active vGPU instance on the system
        ///  *         - \ref NVML_ERROR_UNKNOWN            on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuInstanceGetEncoderSessions(nvmlVgpuInstance_t vgpuInstance, unsigned int *sessionCount, nvmlEncoderSessionInfo_t *sessionInfo);
        /// 
        /// /**
        /// * Retrieves the active frame buffer capture sessions statistics of a vGPU Instance
        /// *
        /// * For Maxwell &amp;tm; or newer fully supported devices.
        /// *
        /// * @param vgpuInstance                      Identifier of the target vGPU instance
        /// * @param fbcStats                          Reference to nvmlFBCStats_t structure contianing NvFBC stats
        /// *
        /// * @return
        /// *         - \ref NVML_SUCCESS                  if \a fbcStats is fetched
        /// *         - \ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized
        /// *         - \ref NVML_ERROR_INVALID_ARGUMENT   if \a vgpuInstance is 0, or \a fbcStats is NULL
        /// *         - \ref NVML_ERROR_NOT_FOUND          if \a vgpuInstance does not match a valid active vGPU instance on the system
        /// *         - \ref NVML_ERROR_UNKNOWN            on any unexpected error
        /// */
        /// nvmlReturn_t DECLDIR nvmlVgpuInstanceGetFBCStats(nvmlVgpuInstance_t vgpuInstance, nvmlFBCStats_t *fbcStats);
        /// 
        /// /**
        /// * Retrieves information about active frame buffer capture sessions on a vGPU Instance.
        /// *
        /// * An array of active FBC sessions is returned in the caller-supplied buffer pointed at by \a sessionInfo. The
        /// * array element count is passed in \a sessionCount, and \a sessionCount is used to return the number of sessions
        /// * written to the buffer.
        /// *
        /// * If the supplied buffer is not large enough to accomodate the active session array, the function returns
        /// * NVML_ERROR_INSUFFICIENT_SIZE, with the element count of nvmlFBCSessionInfo_t array required in \a sessionCount.
        /// * To query the number of active FBC sessions, call this function with *sessionCount = 0.  The code will return
        /// * NVML_SUCCESS with number of active FBC sessions updated in *sessionCount.
        /// *
        /// * For Maxwell &amp;tm; or newer fully supported devices.
        /// *
        /// * @note hResolution, vResolution, averageFPS and averageLatency data for a FBC session returned in \a sessionInfo may
        /// *       be zero if there are no new frames captured since the session started.
        /// *
        /// * @param vgpuInstance                      Identifier of the target vGPU instance
        /// * @param sessionCount                      Reference to caller supplied array size, and returns the number of sessions.
        /// * @param sessionInfo                       Reference in which to return the session information
        /// *
        /// * @return
        /// *         - \ref NVML_SUCCESS                  if \a sessionInfo is fetched
        /// *         - \ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized
        /// *         - \ref NVML_ERROR_INVALID_ARGUMENT   if \a vgpuInstance is 0, or \a sessionCount is NULL.
        /// *         - \ref NVML_ERROR_NOT_FOUND          if \a vgpuInstance does not match a valid active vGPU instance on the system
        /// *         - \ref NVML_ERROR_INSUFFICIENT_SIZE  if \a sessionCount is too small, array element count is returned in \a sessionCount
        /// *         - \ref NVML_ERROR_UNKNOWN            on any unexpected error
        /// */
        /// nvmlReturn_t DECLDIR nvmlVgpuInstanceGetFBCSessions(nvmlVgpuInstance_t vgpuInstance, unsigned int *sessionCount, nvmlFBCSessionInfo_t *sessionInfo);
        /// 
        /// /**
        ///  * Retrieves the current utilization and process ID
        ///  *
        ///  * For Maxwell &amp;tm; or newer fully supported devices.
        ///  *
        ///  * Reads recent utilization of GPU SM (3D/Compute), framebuffer, video encoder, and video decoder for processes running.
        ///  * Utilization values are returned as an array of utilization sample structures in the caller-supplied buffer pointed at
        ///  * by \a utilization. One utilization sample structure is returned per process running, that had some non-zero utilization
        ///  * during the last sample period. It includes the CPU timestamp at which  the samples were recorded. Individual utilization values
        ///  * are returned as "unsigned int" values.
        ///  *
        ///  * To read utilization values, first determine the size of buffer required to hold the samples by invoking the function with
        ///  * \a utilization set to NULL. The caller should allocate a buffer of size
        ///  * processSamplesCount * sizeof(nvmlProcessUtilizationSample_t). Invoke the function again with the allocated buffer passed
        ///  * in \a utilization, and \a processSamplesCount set to the number of entries the buffer is sized for.
        ///  *
        ///  * On successful return, the function updates \a processSamplesCount with the number of process utilization sample
        ///  * structures that were actually written. This may differ from a previously read value as instances are created or
        ///  * destroyed.
        ///  *
        ///  * lastSeenTimeStamp represents the CPU timestamp in microseconds at which utilization samples were last read. Set it to 0
        ///  * to read utilization based on all the samples maintained by the driver's internal sample buffer. Set lastSeenTimeStamp
        ///  * to a timeStamp retrieved from a previous query to read utilization since the previous query.
        ///  *
        ///  * @param device                    The identifier of the target device
        ///  * @param utilization               Pointer to caller-supplied buffer in which guest process utilization samples are returned
        ///  * @param processSamplesCount       Pointer to caller-supplied array size, and returns number of processes running
        ///  * @param lastSeenTimeStamp         Return only samples with timestamp greater than lastSeenTimeStamp.
        /// 
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if \a utilization has been populated
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, \a utilization is NULL, or \a samplingPeriodUs is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetProcessUtilization(nvmlDevice_t device, nvmlProcessUtilizationSample_t *utilization,
        ///                                               unsigned int *processSamplesCount, unsigned long long lastSeenTimeStamp);
        /// 
        /// /**
        ///  * Queries the state of per process accounting mode on vGPU.
        ///  *
        ///  * For Maxwell &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param vgpuInstance            The identifier of the target vGPU VM
        ///  * @param mode                    Reference in which to return the current accounting mode
        ///  *
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if the mode has been successfully retrieved 
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a vgpuInstance is 0, or \a mode is NULL
        ///  *         - \ref NVML_ERROR_NOT_FOUND         if \a vgpuInstance does not match a valid active vGPU instance on the system
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the vGPU doesn't support this feature
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuInstanceGetAccountingMode(nvmlVgpuInstance_t vgpuInstance, nvmlEnableState_t *mode);
        /// 
        /// /**
        ///  * Queries list of processes running on vGPU that can be queried for accounting stats. The list of processes 
        ///  * returned can be in running or terminated state.
        ///  *
        ///  * For Maxwell &amp;tm; or newer fully supported devices.
        ///  * 
        ///  * To just query the maximum number of processes that can be queried, call this function with *count = 0 and
        ///  * pids=NULL. The return code will be NVML_ERROR_INSUFFICIENT_SIZE, or NVML_SUCCESS if list is empty.
        ///  * 
        ///  * For more details see \ref nvmlVgpuInstanceGetAccountingStats.
        ///  *
        ///  * @note In case of PID collision some processes might not be accessible before the circular buffer is full.
        ///  *
        ///  * @param vgpuInstance            The identifier of the target vGPU VM
        ///  * @param count                   Reference in which to provide the \a pids array size, and
        ///  *                                to return the number of elements ready to be queried
        ///  * @param pids                    Reference in which to return list of process ids
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if pids were successfully retrieved
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a vgpuInstance is 0, or \a count is NULL
        ///  *         - \ref NVML_ERROR_NOT_FOUND         if \a vgpuInstance does not match a valid active vGPU instance on the system
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the vGPU doesn't support this feature or accounting mode is disabled
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE if \a count is too small (\a count is set to expected value)
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  *
        ///  * @see nvmlVgpuInstanceGetAccountingPids
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuInstanceGetAccountingPids(nvmlVgpuInstance_t vgpuInstance, unsigned int *count, unsigned int *pids);
        /// 
        /// /**
        ///  * Queries process's accounting stats.
        ///  *
        ///  * For Maxwell &amp;tm; or newer fully supported devices.
        ///  * 
        ///  * Accounting stats capture GPU utilization and other statistics across the lifetime of a process, and
        ///  * can be queried during life time of the process or after its termination.
        ///  * The time field in \ref nvmlAccountingStats_t is reported as 0 during the lifetime of the process and 
        ///  * updated to actual running time after its termination.
        ///  * Accounting stats are kept in a circular buffer, newly created processes overwrite information about old
        ///  * processes.
        ///  *
        ///  * See \ref nvmlAccountingStats_t for description of each returned metric.
        ///  * List of processes that can be queried can be retrieved from \ref nvmlVgpuInstanceGetAccountingPids.
        ///  *
        ///  * @note Accounting Mode needs to be on. See \ref nvmlVgpuInstanceGetAccountingMode.
        ///  * @note Only compute and graphics applications stats can be queried. Monitoring applications stats can't be
        ///  *         queried since they don't contribute to GPU utilization.
        ///  * @note In case of pid collision stats of only the latest process (that terminated last) will be reported
        ///  *
        ///  * @param vgpuInstance            The identifier of the target vGPU VM
        ///  * @param pid                     Process Id of the target process to query stats for
        ///  * @param stats                   Reference in which to return the process's accounting stats
        ///  *
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if stats have been successfully retrieved
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a vgpuInstance is 0, or \a stats is NULL
        ///  *         - \ref NVML_ERROR_NOT_FOUND         if \a vgpuInstance does not match a valid active vGPU instance on the system
        ///  *                                             or \a stats is not found
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the vGPU doesn't support this feature or accounting mode is disabled
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuInstanceGetAccountingStats(nvmlVgpuInstance_t vgpuInstance, unsigned int pid, nvmlAccountingStats_t *stats);
        /// 
        /// /** @} */
        /// 
        /// /***************************************************************************************************/
        /// /** @defgroup nvml vGPU Migration
        ///  * This chapter describes NVML operations that are associated with vGPU Migration.
        ///  *  @{
        ///  */
        /// /***************************************************************************************************/
        /// 
        /// /**
        ///  * Structure representing range of vGPU versions.
        ///  */
        /// typedef struct nvmlVgpuVersion_st
        /// {
        ///     unsigned int minVersion; //!&lt; Minimum vGPU version.
        ///     unsigned int maxVersion; //!&lt; Maximum vGPU version.
        /// } nvmlVgpuVersion_t;
        /// 
        /// /**
        ///  * vGPU metadata structure.
        ///  */
        /// typedef struct nvmlVgpuMetadata_st
        /// {
        ///     unsigned int             version;                                                    //!&lt; Current version of the structure
        ///     unsigned int             revision;                                                   //!&lt; Current revision of the structure
        ///     nvmlVgpuGuestInfoState_t guestInfoState;                                             //!&lt; Current state of Guest-dependent fields
        ///     char                     guestDriverVersion[NVML_SYSTEM_DRIVER_VERSION_BUFFER_SIZE]; //!&lt; Version of driver installed in guest
        ///     char                     hostDriverVersion[NVML_SYSTEM_DRIVER_VERSION_BUFFER_SIZE];  //!&lt; Version of driver installed in host
        ///     unsigned int             reserved[7];                                                //!&lt; Reserved for internal use
        ///     unsigned int             guestVgpuVersion;                                           //!&lt; vGPU version of guest driver
        ///     unsigned int             opaqueDataSize;                                             //!&lt; Size of opaque data field in bytes
        ///     char                     opaqueData[4];                                              //!&lt; Opaque data
        /// } nvmlVgpuMetadata_t;
        /// 
        /// /**
        ///  * Physical GPU metadata structure
        ///  */
        /// typedef struct nvmlVgpuPgpuMetadata_st
        /// {
        ///     unsigned int            version;                                                    //!&lt; Current version of the structure
        ///     unsigned int            revision;                                                   //!&lt; Current revision of the structure
        ///     char                    hostDriverVersion[NVML_SYSTEM_DRIVER_VERSION_BUFFER_SIZE];  //!&lt; Host driver version
        ///     unsigned int            pgpuVirtualizationCaps;                                     //!&lt; Pgpu virtualizaion capabilities bitfileld
        ///     unsigned int            reserved[5];                                                //!&lt; Reserved for internal use
        ///     nvmlVgpuVersion_t       hostSupportedVgpuRange;                                     //!&lt; vGPU version range supported by host driver
        ///     unsigned int            opaqueDataSize;                                             //!&lt; Size of opaque data field in bytes
        ///     char                    opaqueData[4];                                              //!&lt; Opaque data
        /// } nvmlVgpuPgpuMetadata_t;
        /// 
        /// /**
        ///  * vGPU VM compatibility codes
        ///  */
        /// typedef enum nvmlVgpuVmCompatibility_enum
        /// {
        ///     NVML_VGPU_VM_COMPATIBILITY_NONE         = 0x0,    //!&lt; vGPU is not runnable
        ///     NVML_VGPU_VM_COMPATIBILITY_COLD         = 0x1,    //!&lt; vGPU is runnable from a cold / powered-off state (ACPI S5)
        ///     NVML_VGPU_VM_COMPATIBILITY_HIBERNATE    = 0x2,    //!&lt; vGPU is runnable from a hibernated state (ACPI S4)
        ///     NVML_VGPU_VM_COMPATIBILITY_SLEEP        = 0x4,    //!&lt; vGPU is runnable from a sleeped state (ACPI S3)
        ///     NVML_VGPU_VM_COMPATIBILITY_LIVE         = 0x8,    //!&lt; vGPU is runnable from a live/paused (ACPI S0)
        /// } nvmlVgpuVmCompatibility_t;
        /// 
        /// /**
        ///  *  vGPU-pGPU compatibility limit codes
        ///  */
        /// typedef enum nvmlVgpuPgpuCompatibilityLimitCode_enum
        /// {
        ///     NVML_VGPU_COMPATIBILITY_LIMIT_NONE          = 0x0,           //!&lt; Compatibility is not limited.
        ///     NVML_VGPU_COMPATIBILITY_LIMIT_HOST_DRIVER   = 0x1,           //!&lt; ompatibility is limited by host driver version.
        ///     NVML_VGPU_COMPATIBILITY_LIMIT_GUEST_DRIVER  = 0x2,           //!&lt; Compatibility is limited by guest driver version.
        ///     NVML_VGPU_COMPATIBILITY_LIMIT_GPU           = 0x4,           //!&lt; Compatibility is limited by GPU hardware.
        ///     NVML_VGPU_COMPATIBILITY_LIMIT_OTHER         = 0x80000000,    //!&lt; Compatibility is limited by an undefined factor.
        /// } nvmlVgpuPgpuCompatibilityLimitCode_t;
        /// 
        /// /**
        ///  * vGPU-pGPU compatibility structure
        ///  */
        /// typedef struct nvmlVgpuPgpuCompatibility_st
        /// {
        ///     nvmlVgpuVmCompatibility_t               vgpuVmCompatibility;    //!&lt; Compatibility of vGPU VM. See \ref nvmlVgpuVmCompatibility_t
        ///     nvmlVgpuPgpuCompatibilityLimitCode_t    compatibilityLimitCode; //!&lt; Limiting factor for vGPU-pGPU compatibility. See \ref nvmlVgpuPgpuCompatibilityLimitCode_t
        /// } nvmlVgpuPgpuCompatibility_t;
        /// 
        /// /**
        ///  * Returns vGPU metadata structure for a running vGPU. The structure contains information about the vGPU and its associated VM
        ///  * such as the currently installed NVIDIA guest driver version, together with host driver version and an opaque data section
        ///  * containing internal state.
        ///  *
        ///  * nvmlVgpuInstanceGetMetadata() may be called at any time for a vGPU instance. Some fields in the returned structure are
        ///  * dependent on information obtained from the guest VM, which may not yet have reached a state where that information
        ///  * is available. The current state of these dependent fields is reflected in the info structure's \ref nvmlVgpuGuestInfoState_t field.
        ///  *
        ///  * The VMM may choose to read and save the vGPU's VM info as persistent metadata associated with the VM, and provide
        ///  * it to GRID Virtual GPU Manager when creating a vGPU for subsequent instances of the VM.
        ///  *
        ///  * The caller passes in a buffer via \a vgpuMetadata, with the size of the buffer in \a bufferSize. If the vGPU Metadata structure
        ///  * is too large to fit in the supplied buffer, the function returns NVML_ERROR_INSUFFICIENT_SIZE with the size needed
        ///  * in \a bufferSize.
        ///  *
        ///  * @param vgpuInstance             vGPU instance handle
        ///  * @param vgpuMetadata             Pointer to caller-supplied buffer into which vGPU metadata is written
        ///  * @param bufferSize               Size of vgpuMetadata buffer
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                   vGPU metadata structure was successfully returned
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE   vgpuMetadata buffer is too small, required size is returned in \a bufferSize
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT    if \a bufferSize is NULL or \a vgpuInstance is 0; if \a vgpuMetadata is NULL and the value of \a bufferSize is not 0.
        ///  *         - \ref NVML_ERROR_NOT_FOUND           if \a vgpuInstance does not match a valid active vGPU instance on the system
        ///  *         - \ref NVML_ERROR_UNKNOWN             on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuInstanceGetMetadata(nvmlVgpuInstance_t vgpuInstance, nvmlVgpuMetadata_t *vgpuMetadata, unsigned int *bufferSize);
        /// 
        /// /**
        ///  * Returns a vGPU metadata structure for the physical GPU indicated by \a device. The structure contains information about
        ///  * the GPU and the currently installed NVIDIA host driver version that's controlling it, together with an opaque data section
        ///  * containing internal state.
        ///  *
        ///  * The caller passes in a buffer via \a pgpuMetadata, with the size of the buffer in \a bufferSize. If the \a pgpuMetadata
        ///  * structure is too large to fit in the supplied buffer, the function returns NVML_ERROR_INSUFFICIENT_SIZE with the size needed
        ///  * in \a bufferSize.
        ///  *
        ///  * @param device                The identifier of the target device
        ///  * @param pgpuMetadata          Pointer to caller-supplied buffer into which \a pgpuMetadata is written
        ///  * @param bufferSize            Pointer to size of \a pgpuMetadata buffer
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                   GPU metadata structure was successfully returned
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE   pgpuMetadata buffer is too small, required size is returned in \a bufferSize
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT    if \a bufferSize is NULL or \a device is invalid; if \a pgpuMetadata is NULL and the value of \a bufferSize is not 0.
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED       vGPU is not supported by the system
        ///  *         - \ref NVML_ERROR_UNKNOWN             on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetVgpuMetadata(nvmlDevice_t device, nvmlVgpuPgpuMetadata_t *pgpuMetadata, unsigned int *bufferSize);
        /// 
        /// /**
        ///  * Takes a vGPU instance metadata structure read from \ref nvmlVgpuInstanceGetMetadata(), and a vGPU metadata structure for a
        ///  * physical GPU read from \ref nvmlDeviceGetVgpuMetadata(), and returns compatibility information of the vGPU instance and the
        ///  * physical GPU.
        ///  *
        ///  * The caller passes in a buffer via \a compatibilityInfo, into which a compatibility information structure is written. The
        ///  * structure defines the states in which the vGPU / VM may be booted on the physical GPU. If the vGPU / VM compatibility
        ///  * with the physical GPU is limited, a limit code indicates the factor limiting compability.
        ///  * (see \ref nvmlVgpuPgpuCompatibilityLimitCode_t for details).
        ///  *
        ///  * Note: vGPU compatibility does not take into account dynamic capacity conditions that may limit a system's ability to
        ///  *       boot a given vGPU or associated VM.
        ///  *
        ///  * @param vgpuMetadata          Pointer to caller-supplied vGPU metadata structure
        ///  * @param pgpuMetadata          Pointer to caller-supplied GPU metadata structure
        ///  * @param compatibilityInfo     Pointer to caller-supplied buffer to hold compatibility info
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                   vGPU metadata structure was successfully returned
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT    if \a vgpuMetadata or \a pgpuMetadata or \a bufferSize are NULL
        ///  *         - \ref NVML_ERROR_UNKNOWN             on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlGetVgpuCompatibility(nvmlVgpuMetadata_t *vgpuMetadata, nvmlVgpuPgpuMetadata_t *pgpuMetadata, nvmlVgpuPgpuCompatibility_t *compatibilityInfo);
        /// 
        /// /*
        ///  * Virtual GPU (vGPU) version
        ///  *
        ///  * The NVIDIA vGPU Manager and the guest drivers are tagged with a range of supported vGPU versions. This determines the range of NVIDIA guest driver versions that
        ///  * are compatible for vGPU feature support with a given NVIDIA vGPU Manager. For vGPU feature support, the range of supported versions for the NVIDIA vGPU Manager 
        ///  * and the guest driver must overlap. Otherwise, the guest driver fails to load in the VM.
        ///  *
        ///  * When the NVIDIA guest driver loads, either when the VM is booted or when the driver is installed or upgraded, a negotiation occurs between the guest driver
        ///  * and the NVIDIA vGPU Manager to select the highest mutually compatible vGPU version. The negotiated vGPU version stays the same across VM migration.
        ///  */
        /// 
        /// /**
        ///  * Query the ranges of supported vGPU versions.
        ///  *
        ///  * This function gets the linear range of supported vGPU versions that is preset for the NVIDIA vGPU Manager and the range set by an administrator.
        ///  * If the preset range has not been overridden by \ref nvmlSetVgpuVersion, both ranges are the same.
        ///  *
        ///  * The caller passes pointers to the following \ref nvmlVgpuVersion_t structures, into which the NVIDIA vGPU Manager writes the ranges:
        ///  * 1. \a supported structure that represents the preset range of vGPU versions supported by the NVIDIA vGPU Manager.
        ///  * 2. \a current structure that represents the range of supported vGPU versions set by an administrator. By default, this range is the same as the preset range.
        ///  *
        ///  * @param supported  Pointer to the structure in which the preset range of vGPU versions supported by the NVIDIA vGPU Manager is written
        ///  * @param current    Pointer to the structure in which the range of supported vGPU versions set by an administrator is written
        ///  *
        ///  * @return
        ///  * - \ref NVML_SUCCESS                 The vGPU version range structures were successfully obtained.
        ///  * - \ref NVML_ERROR_NOT_SUPPORTED     The API is not supported.
        ///  * - \ref NVML_ERROR_INVALID_ARGUMENT  The \a supported parameter or the \a current parameter is NULL.
        ///  * - \ref NVML_ERROR_UNKNOWN           An error occurred while the data was being fetched.
        ///  */
        /// nvmlReturn_t DECLDIR nvmlGetVgpuVersion(nvmlVgpuVersion_t *supported, nvmlVgpuVersion_t *current);
        /// 
        /// /**
        ///  * Override the preset range of vGPU versions supported by the NVIDIA vGPU Manager with a range set by an administrator.
        ///  *
        ///  * This function configures the NVIDIA vGPU Manager with a range of supported vGPU versions set by an administrator. This range must be a subset of the
        ///  * preset range that the NVIDIA vGPU Manager supports. The custom range set by an administrator takes precedence over the preset range and is advertised to
        ///  * the guest VM for negotiating the vGPU version. See \ref nvmlGetVgpuVersion for details of how to query the preset range of versions supported.
        ///  *
        ///  * This function takes a pointer to vGPU version range structure \ref nvmlVgpuVersion_t as input to override the preset vGPU version range that the NVIDIA vGPU Manager supports.
        ///  *
        ///  * After host system reboot or driver reload, the range of supported versions reverts to the range that is preset for the NVIDIA vGPU Manager.
        ///  *
        ///  * @note 1. The range set by the administrator must be a subset of the preset range that the NVIDIA vGPU Manager supports. Otherwise, an error is returned.
        ///  *       2. If the range of supported guest driver versions does not overlap the range set by the administrator, the guest driver fails to load.
        ///  *       3. If the range of supported guest driver versions overlaps the range set by the administrator, the guest driver will load with a negotiated 
        ///  *          vGPU version that is the maximum value in the overlapping range.
        ///  *       4. No VMs must be running on the host when this function is called. If a VM is running on the host, the call to this function fails.
        ///  *
        ///  * @param vgpuVersion   Pointer to a caller-supplied range of supported vGPU versions.
        ///  *
        ///  * @return
        ///  * - \ref NVML_SUCCESS                 The preset range of supported vGPU versions was successfully overridden.
        ///  * - \ref NVML_ERROR_NOT_SUPPORTED     The API is not supported.
        ///  * - \ref NVML_ERROR_IN_USE            The range was not overridden because a VM is running on the host.
        ///  * - \ref NVML_ERROR_INVALID_ARGUMENT  The \a vgpuVersion parameter specifies a range that is outside the range supported by the NVIDIA vGPU Manager or if \a vgpuVersion is NULL.
        ///  */
        /// nvmlReturn_t DECLDIR nvmlSetVgpuVersion(nvmlVgpuVersion_t *vgpuVersion);
        /// 
        /// /** @} */
        /// 
        /// /***************************************************************************************************/
        /// /** @defgroup nvmlGpuBlacklistQueries GPU Blacklist Queries
        ///  * This chapter describes NVML operations that are associated with blacklisted GPUs.
        ///  *  @{
        ///  */
        /// /***************************************************************************************************/
        /// 
        /// /**
        ///  * Blacklist GPU device information
        ///  **/
        /// typedef struct nvmlBlacklistDeviceInfo_st
        /// {
        ///     nvmlPciInfo_t pciInfo;                   //!&lt; The PCI information for the blacklisted GPU
        ///     char uuid[NVML_DEVICE_UUID_BUFFER_SIZE]; //!&lt; The ASCII string UUID for the blacklisted GPU
        /// } nvmlBlacklistDeviceInfo_t;
        /// 
        ///  /**
        ///  * Retrieves the number of blacklisted GPU devices in the system.
        ///  * 
        ///  * For all products.
        ///  *
        ///  * @param deviceCount                          Reference in which to return the number of blacklisted devices
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a deviceCount has been set
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a deviceCount is NULL
        ///  */
        /// nvmlReturn_t DECLDIR nvmlGetBlacklistDeviceCount(unsigned int *deviceCount);
        /// 
        /// /**
        ///  * Acquire the device information for a blacklisted device, based on its index.
        ///  * 
        ///  * For all products.
        ///  *
        ///  * Valid indices are derived from the \a deviceCount returned by 
        ///  *   \ref nvmlGetBlacklistDeviceCount(). For example, if \a deviceCount is 2 the valid indices  
        ///  *   are 0 and 1, corresponding to GPU 0 and GPU 1.
        ///  *
        ///  * @param index                                The index of the target GPU, &gt;= 0 and &lt; \a deviceCount
        ///  * @param info                                 Reference in which to return the device information
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                  if \a device has been set
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT   if \a index is invalid or \a info is NULL
        ///  *
        ///  * @see nvmlGetBlacklistDeviceCount
        ///  */
        /// nvmlReturn_t DECLDIR nvmlGetBlacklistDeviceInfoByIndex(unsigned int index, nvmlBlacklistDeviceInfo_t *info);
        /// 
        /// /** @} */
        /// 
        /// /**
        ///  * NVML API versioning support
        ///  */
        /// #if defined(__NVML_API_VERSION_INTERNAL)
        /// #undef nvmlDeviceGetGridLicensableFeatures
        /// #undef nvmlDeviceRemoveGpu
        /// #undef nvmlDeviceGetNvLinkRemotePciInfo
        /// #undef nvmlDeviceGetPciInfo
        /// #undef nvmlDeviceGetCount
        /// #undef nvmlDeviceGetHandleByIndex
        /// #undef nvmlDeviceGetHandleByPciBusId
        /// #undef nvmlInit
        /// #endif
        /// 
        /// #ifdef __cplusplus
        /// }
        /// #endif
        /// 
        /// #endifnvmlConstants::NVML_DEVICE_SERIAL_BUFFER_SIZE. NVML_SUCCESS                 if \a serial has been set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, or \a serial is NULL- NVML_ERROR_INSUFFICIENT_SIZE if \a length is too small- NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetSerial(nvmlDevice_st device, IntPtr serial, uint length);
        
        /// <summary>
        /// Retrieves an array of unsigned ints (sized to cpuSetSize) of bitmasks with the ideal CPU affinity for the device
        /// For example, if processors 0, 1, 32, and 33 are ideal for the device and cpuSetSize == 2,
        /// result[0] = 0x3, result[1] = 0x3
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="cpuSetSize">The size of the cpuSet array that is safe to access</param>
        /// <param name="cpuSet">Array reference in which to return a bitmask of CPUs, 64 CPUs per 
        /// unsigned long on 64-bit machines, 32 on 32-bit machines</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For Kepler 
        /// &amp;tm;
        /// or newer fully supported devices.
        /// Supported on Linux only. NVML_SUCCESS                 if \a cpuAffinity has been filled- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, cpuSetSize == 0, or cpuSet is NULL- NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetCpuAffinity(nvmlDevice_st device, uint cpuSetSize, ref uint cpuSet);
        
        /// <summary>
        /// Sets the ideal affinity for the calling thread and device using the guidelines 
        /// given in nvmlDeviceGetCpuAffinity().  Note, this is a change as of version 8.0.  
        /// Older versions set the affinity for a calling process and all children.
        /// Currently supports up to 64 processors.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For Kepler 
        /// &amp;tm;
        /// or newer fully supported devices.
        /// Supported on Linux only. NVML_SUCCESS                 if the calling process has been successfully bound- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid- NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceSetCpuAffinity(nvmlDevice_st device);
        
        /// <summary>
        /// Clear all affinity bindings for the calling thread.  Note, this is a change as of version
        /// 8.0 as older versions cleared the affinity for a calling process and all children.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For Kepler 
        /// &amp;tm;
        /// or newer fully supported devices.
        /// Supported on Linux only. NVML_SUCCESS                 if the calling process has been successfully unbound- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceClearCpuAffinity(nvmlDevice_st device);
        
        /// <summary>
        /// Retrieve the common ancestor for two devices
        /// For all products.
        /// Supported on Linux only.
        /// </summary>
        /// <param name="device1">The identifier of the first device</param>
        /// <param name="device2">The identifier of the second device</param>
        /// <param name="pathInfo">A</param>
        /// <returns>-</returns>
        /// <remarks>
        ///  nvmlGpuTopologyLevel_t that gives the path type NVML_SUCCESS                 if \a pathInfo has been set- NVML_ERROR_INVALID_ARGUMENT  if \a device1, or \a device2 is invalid, or \a pathInfo is NULL- NVML_ERROR_NOT_SUPPORTED     if the device or OS does not support this feature- NVML_ERROR_UNKNOWN           an error has occurred in underlying topology discovery
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetTopologyCommonAncestor(nvmlDevice_st device1, nvmlDevice_st device2, ref nvmlGpuLevel_enum pathInfo);
        
        /// <summary>
        /// Retrieve the set of GPUs that are nearest to a given device at a specific interconnectivity level
        /// For all products.
        /// Supported on Linux only.
        /// </summary>
        /// <param name="device">The identifier of the first device</param>
        /// <param name="level">The</param>
        /// <param name="count">When zero, is set to the number of matching GPUs such that @a deviceArray can be malloc'd.  When non-zero, @a deviceArray will be filled with @a count number of device handles.</param>
        /// <param name="deviceArray">An array of device handles for GPUs found at @a level</param>
        /// <returns>-</returns>
        /// <remarks>
        ///  nvmlGpuTopologyLevel_t level to search for other GPUs NVML_SUCCESS                 if \a deviceArray or \a count (if initially zero) has been set- NVML_ERROR_INVALID_ARGUMENT  if \a device, \a level, or \a count is invalid, or \a deviceArray is NULL with a non-zero \a count- NVML_ERROR_NOT_SUPPORTED     if the device or OS does not support this feature- NVML_ERROR_UNKNOWN           an error has occurred in underlying topology discovery
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetTopologyNearestGpus(nvmlDevice_st device, nvmlGpuLevel_enum level, ref uint count, ref nvmlDevice_st deviceArray);
        
        /// <summary>
        /// Retrieve the set of GPUs that have a CPU affinity with the given CPU number
        /// For all products.
        /// Supported on Linux only.
        /// </summary>
        /// <param name="cpuNumber">The CPU number</param>
        /// <param name="count">When zero, is set to the number of matching GPUs such that @a deviceArray can be malloc'd.  When non-zero, @a deviceArray will be filled with @a count number of device handles.</param>
        /// <param name="deviceArray">An array of device handles for GPUs found with affinity to @a cpuNumber</param>
        /// <returns>-</returns>
        /// <remarks>
        ///  NVML_SUCCESS                 if \a deviceArray or \a count (if initially zero) has been set- NVML_ERROR_INVALID_ARGUMENT  if \a cpuNumber, or \a count is invalid, or \a deviceArray is NULL with a non-zero \a count- NVML_ERROR_NOT_SUPPORTED     if the device or OS does not support this feature- NVML_ERROR_UNKNOWN           an error has occurred in underlying topology discovery
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlSystemGetTopologyGpuSet(uint cpuNumber, ref uint count, ref nvmlDevice_st deviceArray);
        
        /// <summary>
        /// Retrieve the status for a given p2p capability index between a given pair of GPU
        /// </summary>
        /// <param name="device1">The first device</param>
        /// <param name="device2">The second device</param>
        /// <param name="p2pIndex">p2p Capability Index being looked for between @a device1 and @a device2</param>
        /// <param name="p2pStatus">Reference in which to return the status of the @a p2pIndex between @a device1 and @a device2</param>
        /// <returns>-</returns>
        /// <remarks>
        ///  NVML_SUCCESS         if \a p2pStatus has been populated- NVML_ERROR_INVALID_ARGUMENT     if \a device1 or \a device2 or \a p2pIndex is invalid or \a p2pStatus is NULL- NVML_ERROR_UNKNOWN              on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetP2PStatus(nvmlDevice_st device1, nvmlDevice_st device2, nvmlGpuP2PCapsIndex_enum p2pIndex, ref nvmlGpuP2PStatus_enum p2pStatus);
        
        /// <summary>
        /// Retrieves the globally unique immutable UUID associated with this device, as a 5 part hexadecimal string,
        /// that augments the immutable, board serial identifier.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="uuid">Reference in which to return the GPU UUID</param>
        /// <param name="length">The maximum allowed length of the string returned in @a uuid</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For all products.The UUID is a globally unique identifier. It is the only available identifier for pre-Fermi-architecture products.
        /// It does NOT correspond to any identifier printed on the board.  It will not exceed 80 characters in length
        /// (including the NULL terminator).  See nvmlConstants::NVML_DEVICE_UUID_BUFFER_SIZE. NVML_SUCCESS                 if \a uuid has been set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, or \a uuid is NULL- NVML_ERROR_INSUFFICIENT_SIZE if \a length is too small- NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetUUID(nvmlDevice_st device, IntPtr uuid, uint length);
        
        /// <summary>
        /// Retrieves minor number for the device. The minor number for the device is such that the Nvidia device node file for 
        /// each GPU will have the form /dev/nvidia[minor number].
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="minorNumber">Reference in which to return the minor number for the device</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For all products.
        /// Supported only for Linux NVML_SUCCESS                 if the minor number is successfully retrieved- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a minorNumber is NULL- NVML_ERROR_NOT_SUPPORTED     if this query is not supported by the device- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetMinorNumber(nvmlDevice_st device, ref uint minorNumber);
        
        /// <summary>
        /// Retrieves the the device board part number which is programmed into the board's InfoROM
        /// </summary>
        /// <param name="device">Identifier of the target device</param>
        /// <param name="partNumber">Reference to the buffer to return</param>
        /// <param name="length">Length of the buffer reference</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For all products. NVML_SUCCESS                  if \a partNumber has been set- NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized- NVML_ERROR_NOT_SUPPORTED      if the needed VBIOS fields have not been filled- NVML_ERROR_INVALID_ARGUMENT   if \a device is invalid or \a serial is NULL- NVML_ERROR_GPU_IS_LOST        if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN            on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetBoardPartNumber(nvmlDevice_st device, IntPtr partNumber, uint length);
        
        /// <summary>
        /// Retrieves the version information for the device's infoROM object.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="object">The target infoROM object</param>
        /// <param name="version">Reference in which to return the infoROM version</param>
        /// <param name="length">The maximum allowed length of the string returned in @a version</param>
        /// <returns>-</returns>
        /// <seealso cref="nvmlDeviceGetInforomImageVersion"/>
        /// 
        /// <remarks>
        /// For all products with an inforom.Fermi and higher parts have non-volatile on-board memory for persisting device info, such as aggregate 
        /// ECC counts. The version of the data structures in this memory may change from time to time. It will not
        /// exceed 16 characters in length (including the NULL terminator).
        /// See nvmlConstants::NVML_DEVICE_INFOROM_VERSION_BUFFER_SIZE.See nvmlInforomObject_t for details on the available infoROM objects. NVML_SUCCESS                 if \a version has been set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a version is NULL- NVML_ERROR_INSUFFICIENT_SIZE if \a length is too small- NVML_ERROR_NOT_SUPPORTED     if the device does not have an infoROM- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetInforomVersion(nvmlDevice_st device, nvmlInforomObject_enum @object, IntPtr version, uint length);
        
        /// <summary>
        /// Retrieves the global infoROM image version
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="version">Reference in which to return the infoROM image version</param>
        /// <param name="length">The maximum allowed length of the string returned in @a version</param>
        /// <returns>-</returns>
        /// <seealso cref="nvmlDeviceGetInforomVersion"/>
        /// 
        /// <remarks>
        /// For all products with an inforom.Image version just like VBIOS version uniquely describes the exact version of the infoROM flashed on the board 
        /// in contrast to infoROM object version which is only an indicator of supported features.
        /// Version string will not exceed 16 characters in length (including the NULL terminator).
        /// See nvmlConstants::NVML_DEVICE_INFOROM_VERSION_BUFFER_SIZE. NVML_SUCCESS                 if \a version has been set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a version is NULL- NVML_ERROR_INSUFFICIENT_SIZE if \a length is too small- NVML_ERROR_NOT_SUPPORTED     if the device does not have an infoROM- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetInforomImageVersion(nvmlDevice_st device, IntPtr version, uint length);
        
        /// <summary>
        /// Retrieves the checksum of the configuration stored in the device's infoROM.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="checksum">Reference in which to return the infoROM configuration checksum</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For all products with an inforom.Can be used to make sure that two GPUs have the exact same configuration.
        /// Current checksum takes into account configuration stored in PWR and ECC infoROM objects.
        /// Checksum can change between driver releases or when user changes configuration (e.g. disable/enable ECC) NVML_SUCCESS                 if \a checksum has been set- NVML_ERROR_CORRUPTED_INFOROM if the device's checksum couldn't be retrieved due to infoROM corruption- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a checksum is NULL- NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetInforomConfigurationChecksum(nvmlDevice_st device, ref uint checksum);
        
        /// <summary>
        /// Reads the infoROM from the flash and verifies the checksums.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For all products with an inforom. NVML_SUCCESS                 if infoROM is not corrupted- NVML_ERROR_CORRUPTED_INFOROM if the device's infoROM is corrupted- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceValidateInforom(nvmlDevice_st device);
        
        /// <summary>
        /// Retrieves the display mode for the device.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="display">Reference in which to return the display mode</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For all products.This method indicates whether a physical display (e.g. monitor) is currently connected to
        /// any of the device's connectors.See nvmlEnableState_t for details on allowed modes. NVML_SUCCESS                 if \a display has been set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a display is NULL- NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetDisplayMode(nvmlDevice_st device, ref nvmlEnableState_enum display);
        
        /// <summary>
        /// Retrieves the display active state for the device.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="isActive">Reference in which to return the display active state</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For all products.This method indicates whether a display is initialized on the device.
        /// For example whether X Server is attached to this device and has allocated memory for the screen.Display can be active even when no monitor is physically attached.See nvmlEnableState_t for details on allowed modes. NVML_SUCCESS                 if \a isActive has been set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a isActive is NULL- NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetDisplayActive(nvmlDevice_st device, ref nvmlEnableState_enum isActive);
        
        /// <summary>
        /// Retrieves the persistence mode associated with this device.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="mode">Reference in which to return the current driver persistence mode</param>
        /// <returns>-</returns>
        /// <seealso cref="nvmlDeviceSetPersistenceMode()"/>
        /// 
        /// <remarks>
        /// For all products.
        /// For Linux only.When driver persistence mode is enabled the driver software state is not torn down when the last 
        /// client disconnects. By default this feature is disabled.See nvmlEnableState_t for details on allowed modes. NVML_SUCCESS                 if \a mode has been set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a mode is NULL- NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetPersistenceMode(nvmlDevice_st device, ref nvmlEnableState_enum mode);
        
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetPciInfo_v3(nvmlDevice_st device, ref nvmlPciInfo_st pci);
        
        /// <summary>
        /// Retrieves the maximum PCIe link generation possible with this device and system
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="maxLinkGen">Reference in which to return the max PCIe link generation</param>
        /// <returns>-</returns>
        /// <remarks>
        /// I.E. for a generation 2 PCIe device attached to a generation 1 PCIe bus the max link generation this function will
        /// report is generation 1.For Fermi 
        /// &amp;tm;
        /// or newer fully supported devices. NVML_SUCCESS                 if \a maxLinkGen has been populated- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a maxLinkGen is null- NVML_ERROR_NOT_SUPPORTED     if PCIe link information is not available- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetMaxPcieLinkGeneration(nvmlDevice_st device, ref uint maxLinkGen);
        
        /// <summary>
        /// Retrieves the maximum PCIe link width possible with this device and system
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="maxLinkWidth">Reference in which to return the max PCIe link generation</param>
        /// <returns>-</returns>
        /// <remarks>
        /// I.E. for a device with a 16x PCIe bus width attached to a 8x PCIe system bus this function will report
        /// a max link width of 8.For Fermi 
        /// &amp;tm;
        /// or newer fully supported devices. NVML_SUCCESS                 if \a maxLinkWidth has been populated- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a maxLinkWidth is null- NVML_ERROR_NOT_SUPPORTED     if PCIe link information is not available- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetMaxPcieLinkWidth(nvmlDevice_st device, ref uint maxLinkWidth);
        
        /// <summary>
        /// Retrieves the current PCIe link generation
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="currLinkGen">Reference in which to return the current PCIe link generation</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For Fermi 
        /// &amp;tm;
        /// or newer fully supported devices. NVML_SUCCESS                 if \a currLinkGen has been populated- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a currLinkGen is null- NVML_ERROR_NOT_SUPPORTED     if PCIe link information is not available- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetCurrPcieLinkGeneration(nvmlDevice_st device, ref uint currLinkGen);
        
        /// <summary>
        /// Retrieves the current PCIe link width
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="currLinkWidth">Reference in which to return the current PCIe link generation</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For Fermi 
        /// &amp;tm;
        /// or newer fully supported devices. NVML_SUCCESS                 if \a currLinkWidth has been populated- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a currLinkWidth is null- NVML_ERROR_NOT_SUPPORTED     if PCIe link information is not available- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetCurrPcieLinkWidth(nvmlDevice_st device, ref uint currLinkWidth);
        
        /// <summary>
        /// Retrieve PCIe utilization information.
        /// This function is querying a byte counter over a 20ms interval and thus is the 
        /// PCIe throughput over that interval.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="counter">The specific counter that should be queried</param>
        /// <param name="value">Reference in which to return throughput in KB/s</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For Maxwell 
        /// &amp;tm;
        /// or newer fully supported devices.This method is not supported in virtual machines running virtual GPU (vGPU). nvmlPcieUtilCounter_t NVML_SUCCESS                 if \a value has been set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device or \a counter is invalid, or \a value is NULL- NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetPcieThroughput(nvmlDevice_st device, nvmlPcieUtilCounter_enum counter, ref uint value);
        
        /// <summary>
        /// Retrieve the PCIe replay counter.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="value">Reference in which to return the counter's value</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For Kepler 
        /// &amp;tm;
        /// or newer fully supported devices. NVML_SUCCESS                 if \a value has been set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, or \a value is NULL- NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetPcieReplayCounter(nvmlDevice_st device, ref uint value);
        
        /// <summary>
        /// Retrieves the current clock speeds for the device.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="type">Identify which clock domain to query</param>
        /// <param name="clock">Reference in which to return the clock speed in MHz</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For Fermi 
        /// &amp;tm;
        /// or newer fully supported devices.See nvmlClockType_t for details on available clock information. NVML_SUCCESS                 if \a clock has been set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a clock is NULL- NVML_ERROR_NOT_SUPPORTED     if the device cannot report the specified clock- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetClockInfo(nvmlDevice_st device, nvmlClockType_enum type, ref uint clock);
        
        /// <summary>
        /// Retrieves the maximum clock speeds for the device.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="type">Identify which clock domain to query</param>
        /// <param name="clock">Reference in which to return the clock speed in MHz</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For Fermi 
        /// &amp;tm;
        /// or newer fully supported devices.See nvmlClockType_t for details on available clock information.@note On GPUs from Fermi family current P0 clocks (reported by nvmlDeviceGetClockInfo) can differ from max clocksby few MHz. NVML_SUCCESS                 if \a clock has been set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a clock is NULL- NVML_ERROR_NOT_SUPPORTED     if the device cannot report the specified clock- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetMaxClockInfo(nvmlDevice_st device, nvmlClockType_enum type, ref uint clock);
        
        /// <summary>
        /// Retrieves the current setting of a clock that applications will use unless an overspec situation occurs.
        /// Can be changed using
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="clockType">Identify which clock domain to query</param>
        /// <param name="clockMHz">Reference in which to return the clock in MHz</param>
        /// <returns>-</returns>
        /// <remarks>
        ///  nvmlDeviceSetApplicationsClocks.For Kepler 
        /// &amp;tm;
        /// or newer fully supported devices. NVML_SUCCESS                 if \a clockMHz has been set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a clockMHz is NULL or \a clockType is invalid- NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetApplicationsClock(nvmlDevice_st device, nvmlClockType_enum clockType, ref uint clockMHz);
        
        /// <summary>
        /// Retrieves the default applications clock that GPU boots with or 
        /// defaults to after
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="clockType">Identify which clock domain to query</param>
        /// <param name="clockMHz">Reference in which to return the default clock in MHz</param>
        /// <returns>-</returns>
        /// <seealso cref="nvmlDeviceGetApplicationsClock"/>
        /// 
        /// <remarks>
        ///  nvmlDeviceResetApplicationsClocks call.For Kepler 
        /// &amp;tm;
        /// or newer fully supported devices. NVML_SUCCESS                 if \a clockMHz has been set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a clockMHz is NULL or \a clockType is invalid- NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetDefaultApplicationsClock(nvmlDevice_st device, nvmlClockType_enum clockType, ref uint clockMHz);
        
        /// <summary>
        /// Resets the application clock to the default value
        /// </summary>
        /// <seealso cref="nvmlDeviceGetApplicationsClock"/>
        /// 
        /// <seealso cref="nvmlDeviceSetApplicationsClocks"/>
        /// 
        /// <param name="device">The identifier of the target device</param>
        /// <returns>-</returns>
        /// <remarks>
        /// This is the applications clock that will be used after system reboot or driver reload.
        /// Default value is constant, but the current value an be changed using nvmlDeviceSetApplicationsClocks.On Pascal and newer hardware, if clocks were previously locked with nvmlDeviceSetApplicationsClocks,this call will unlock clocks. This returns clocks their default behavior ofautomatically boosting above
        /// base clocks as thermal limits allow.For Fermi 
        /// &amp;tm;
        /// or newer non-GeForce fully supported devices and Maxwell or newer GeForce devices. NVML_SUCCESS                 if new settings were successfully set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid- NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceResetApplicationsClocks(nvmlDevice_st device);
        
        /// <summary>
        /// Retrieves the clock speed for the clock specified by the clock type and clock ID.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="clockType">Identify which clock domain to query</param>
        /// <param name="clockId">Identify which clock in the domain to query</param>
        /// <param name="clockMHz">Reference in which to return the clock in MHz</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For Kepler 
        /// &amp;tm;
        /// or newer fully supported devices. NVML_SUCCESS                 if \a clockMHz has been set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a clockMHz is NULL or \a clockType is invalid- NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetClock(nvmlDevice_st device, nvmlClockType_enum clockType, nvmlClockId_enum clockId, ref uint clockMHz);
        
        /// <summary>
        /// Retrieves the customer defined maximum boost clock speed specified by the given clock type.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="clockType">Identify which clock domain to query</param>
        /// <param name="clockMHz">Reference in which to return the clock in MHz</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For Pascal 
        /// &amp;tm;
        /// or newer fully supported devices. NVML_SUCCESS                 if \a clockMHz has been set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a clockMHz is NULL or \a clockType is invalid- NVML_ERROR_NOT_SUPPORTED     if the device or the \a clockType on this device does not support this feature- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetMaxCustomerBoostClock(nvmlDevice_st device, nvmlClockType_enum clockType, ref uint clockMHz);
        
        /// <summary>
        /// Retrieves the list of possible memory clocks that can be used as an argument for
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="count">Reference in which to provide the @a clocksMHz array size, and
        /// to return the number of elements</param>
        /// <param name="clocksMHz">Reference in which to return the clock in MHz</param>
        /// <returns>-</returns>
        /// <seealso cref="nvmlDeviceSetApplicationsClocks"/>
        /// 
        /// <seealso cref="nvmlDeviceGetSupportedGraphicsClocks"/>
        /// 
        /// <remarks>
        ///  nvmlDeviceSetApplicationsClocks.For Kepler 
        /// &amp;tm;
        /// or newer fully supported devices. NVML_SUCCESS                 if \a count and \a clocksMHz have been populated- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a count is NULL- NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature- NVML_ERROR_INSUFFICIENT_SIZE if \a count is too small (\a count is set to the number ofrequired elements)
        /// - NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetSupportedMemoryClocks(nvmlDevice_st device, ref uint count, ref uint clocksMHz);
        
        /// <summary>
        /// Retrieves the list of possible graphics clocks that can be used as an argument for
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="memoryClockMHz">Memory clock for which to return possible graphics clocks</param>
        /// <param name="count">Reference in which to provide the @a clocksMHz array size, and
        /// to return the number of elements</param>
        /// <param name="clocksMHz">Reference in which to return the clocks in MHz</param>
        /// <returns>-</returns>
        /// <seealso cref="nvmlDeviceSetApplicationsClocks"/>
        /// 
        /// <seealso cref="nvmlDeviceGetSupportedMemoryClocks"/>
        /// 
        /// <remarks>
        ///  nvmlDeviceSetApplicationsClocks.For Kepler 
        /// &amp;tm;
        /// or newer fully supported devices. NVML_SUCCESS                 if \a count and \a clocksMHz have been populated- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_NOT_FOUND         if the specified \a memoryClockMHz is not a supported frequency- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a clock is NULL- NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature- NVML_ERROR_INSUFFICIENT_SIZE if \a count is too small- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetSupportedGraphicsClocks(nvmlDevice_st device, uint memoryClockMHz, ref uint count, ref uint clocksMHz);
        
        /// <summary>
        /// Retrieve the current state of Auto Boosted clocks on a device and store it in @a isEnabled
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="isEnabled">Where to store the current state of Auto Boosted clocks of the target device</param>
        /// <param name="defaultIsEnabled">Where to store the default Auto Boosted clocks behavior of the target device that the device will
        /// revert to when no applications are using the GPU</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For Kepler 
        /// &amp;tm;
        /// or newer fully supported devices.Auto Boosted clocks are enabled by default on some hardware, allowing the GPU to run at higher clock rates
        /// to maximize performance as thermal limits allow.On Pascal and newer hardware, Auto Aoosted clocks are controlled through application clocks.
        /// Use nvmlDeviceSetApplicationsClocks and \ref nvmlDeviceResetApplicationsClocks to control Auto Boostbehavior. NVML_SUCCESS                 If \a isEnabled has been been set with the Auto Boosted clocks state of \a device- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a isEnabled is NULL- NVML_ERROR_NOT_SUPPORTED     if the device does not support Auto Boosted clocks- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetAutoBoostedClocksEnabled(nvmlDevice_st device, ref nvmlEnableState_enum isEnabled, ref nvmlEnableState_enum defaultIsEnabled);
        
        /// <summary>
        /// Try to set the current state of Auto Boosted clocks on a device.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="enabled">What state to try to set Auto Boosted clocks of the target device to</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For Kepler 
        /// &amp;tm;
        /// or newer fully supported devices.Auto Boosted clocks are enabled by default on some hardware, allowing the GPU to run at higher clock rates
        /// to maximize performance as thermal limits allow. Auto Boosted clocks should be disabled if fixed clock
        /// rates are desired.Non-root users may use this API by default but can be restricted by root from using this API by calling nvmlDeviceSetAPIRestriction with apiType=NVML_RESTRICTED_API_SET_AUTO_BOOSTED_CLOCKS.Note: Persistence Mode is required to modify current Auto Boost settings, therefore, it must be enabled.On Pascal and newer hardware, Auto Boosted clocks are controlled through application clocks.
        /// Use nvmlDeviceSetApplicationsClocks and \ref nvmlDeviceResetApplicationsClocks to control Auto Boostbehavior. NVML_SUCCESS                 If the Auto Boosted clocks were successfully set to the state specified by \a enabled- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid- NVML_ERROR_NOT_SUPPORTED     if the device does not support Auto Boosted clocks- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceSetAutoBoostedClocksEnabled(nvmlDevice_st device, nvmlEnableState_enum enabled);
        
        /// <summary>
        /// Try to set the default state of Auto Boosted clocks on a device. This is the default state that Auto Boosted clocks will
        /// return to when no compute running processes (e.g. CUDA application which have an active context) are running
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="enabled">What state to try to set default Auto Boosted clocks of the target device to</param>
        /// <param name="flags">Flags that change the default behavior. Currently Unused.</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For Kepler 
        /// &amp;tm;
        /// or newer non-GeForce fully supported devices and Maxwell or newer GeForce devices.
        /// Requires root/admin permissions.Auto Boosted clocks are enabled by default on some hardware, allowing the GPU to run at higher clock rates
        /// to maximize performance as thermal limits allow. Auto Boosted clocks should be disabled if fixed clock
        /// rates are desired.On Pascal and newer hardware, Auto Boosted clocks are controlled through application clocks.
        /// Use nvmlDeviceSetApplicationsClocks and \ref nvmlDeviceResetApplicationsClocks to control Auto Boostbehavior. NVML_SUCCESS                 If the Auto Boosted clock's default state was successfully set to the state specified by \a enabled- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_NO_PERMISSION     If the calling user does not have permission to change Auto Boosted clock's default state.- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid- NVML_ERROR_NOT_SUPPORTED     if the device does not support Auto Boosted clocks- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceSetDefaultAutoBoostedClocksEnabled(nvmlDevice_st device, nvmlEnableState_enum enabled, uint flags);
        
        /// <summary>
        /// Retrieves the intended operating speed of the device's fan.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="speed">Reference in which to return the fan speed percentage</param>
        /// <returns>-</returns>
        /// <remarks>
        /// Note: The reported speed is the intended fan speed.  If the fan is physically blocked and unable to spin, the
        /// output will not match the actual fan speed.For all discrete products with dedicated fans.The fan speed is expressed as a percent of the maximum, i.e. full speed is 100%. NVML_SUCCESS                 if \a speed has been set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a speed is NULL- NVML_ERROR_NOT_SUPPORTED     if the device does not have a fan- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetFanSpeed(nvmlDevice_st device, ref uint speed);
        
        /// <summary>
        /// Retrieves the intended operating speed of the device's specified fan.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="fan">The index of the target fan, zero indexed.</param>
        /// <param name="speed">Reference in which to return the fan speed percentage</param>
        /// <returns>-</returns>
        /// <remarks>
        /// Note: The reported speed is the intended fan speed. If the fan is physically blocked and unable to spin, the
        /// output will not match the actual fan speed.For all discrete products with dedicated fans.The fan speed is expressed as a percentage of the maximum, i.e. full speed is 100% NVML_SUCCESS                   if \a speed has been set- NVML_ERROR_UNINITIALIZED       if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT    if \a device is invalid, \a fan is not an acceptable index, or \a speed is NULL- NVML_ERROR_NOT_SUPPORTED       if the device does not have a fan or is newer than Maxwell- NVML_ERROR_GPU_IS_LOST         if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN             on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetFanSpeed_v2(nvmlDevice_st device, uint fan, ref uint speed);
        
        /// <summary>
        /// Retrieves the current temperature readings for the device, in degrees C.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="sensorType">Flag that indicates which sensor reading to retrieve</param>
        /// <param name="temp">Reference in which to return the temperature reading</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For all products.See nvmlTemperatureSensors_t for details on available temperature sensors. NVML_SUCCESS                 if \a temp has been set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, \a sensorType is invalid or \a temp is NULL- NVML_ERROR_NOT_SUPPORTED     if the device does not have the specified sensor- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetTemperature(nvmlDevice_st device, nvmlTemperatureSensors_enum sensorType, ref uint temp);
        
        /// <summary>
        /// Retrieves the temperature threshold for the GPU with the specified threshold type in degrees C.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="thresholdType">The type of threshold value queried</param>
        /// <param name="temp">Reference in which to return the temperature reading</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For Kepler 
        /// &amp;tm;
        /// or newer fully supported devices.See nvmlTemperatureThresholds_t for details on available temperature thresholds. NVML_SUCCESS                 if \a temp has been set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, \a thresholdType is invalid or \a temp is NULL- NVML_ERROR_NOT_SUPPORTED     if the device does not have a temperature sensor or is unsupported- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetTemperatureThreshold(nvmlDevice_st device, nvmlTemperatureThresholds_enum thresholdType, ref uint temp);
        
        /// <summary>
        /// Retrieves the current performance state for the device.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="pState">Reference in which to return the performance state reading</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For Fermi 
        /// &amp;tm;
        /// or newer fully supported devices.See nvmlPstates_t for details on allowed performance states. NVML_SUCCESS                 if \a pState has been set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a pState is NULL- NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetPerformanceState(nvmlDevice_st device, ref nvmlPStates_enum pState);
        
        /// <summary>
        /// Retrieves current clocks throttling reasons.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="clocksThrottleReasons">Reference in which to return bitmask of active clocks throttle
        /// reasons</param>
        /// <returns>-</returns>
        /// <seealso cref="nvmlClocksThrottleReasons"/>
        /// 
        /// <seealso cref="nvmlDeviceGetSupportedClocksThrottleReasons"/>
        /// 
        /// <remarks>
        /// For all fully supported products.@note More than one bit can be enabled at the same time. Multiple reasons can be affecting clocks at once. NVML_SUCCESS                 if \a clocksThrottleReasons has been set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a clocksThrottleReasons is NULL- NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetCurrentClocksThrottleReasons(nvmlDevice_st device, ref ulong clocksThrottleReasons);
        
        /// <summary>
        /// Retrieves bitmask of supported clocks throttle reasons that can be returned by
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="supportedClocksThrottleReasons">Reference in which to return bitmask of supported
        /// clocks throttle reasons</param>
        /// <returns>-</returns>
        /// <seealso cref="nvmlClocksThrottleReasons"/>
        /// 
        /// <seealso cref="nvmlDeviceGetCurrentClocksThrottleReasons"/>
        /// 
        /// <remarks>
        ///  nvmlDeviceGetCurrentClocksThrottleReasonsFor all fully supported products.This method is not supported in virtual machines running virtual GPU (vGPU). NVML_SUCCESS                 if \a supportedClocksThrottleReasons has been set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a supportedClocksThrottleReasons is NULL- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetSupportedClocksThrottleReasons(nvmlDevice_st device, ref ulong supportedClocksThrottleReasons);
        
        /// <summary>
        /// Deprecated: Use
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="pState">Reference in which to return the performance state reading</param>
        /// <returns>-</returns>
        /// <remarks>
        ///  nvmlDeviceGetPerformanceState. This function exposes an incorrect generalization.Retrieve the current performance state for the device.For Fermi 
        /// &amp;tm;
        /// or newer fully supported devices.See nvmlPstates_t for details on allowed performance states. NVML_SUCCESS                 if \a pState has been set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a pState is NULL- NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetPowerState(nvmlDevice_st device, ref nvmlPStates_enum pState);
        
        /// <summary>
        /// This API has been deprecated.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="mode">Reference in which to return the current power management mode</param>
        /// <returns>-</returns>
        /// <remarks>
        /// Retrieves the power management mode associated with this device.For products from the Fermi family.
        /// - Requires @a NVML_INFOROM_POWER version 3.0 or higher.For from the Kepler or newer families.
        /// - Does not require @a NVML_INFOROM_POWER object.This flag indicates whether any power management algorithm is currently active on the device. An 
        /// enabled state does not necessarily mean the device is being actively throttled -- only that 
        /// that the driver will do so if the appropriate conditions are met.See nvmlEnableState_t for details on allowed modes. NVML_SUCCESS                 if \a mode has been set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a mode is NULL- NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetPowerManagementMode(nvmlDevice_st device, ref nvmlEnableState_enum mode);
        
        /// <summary>
        /// Retrieves the power management limit associated with this device.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="limit">Reference in which to return the power management limit in milliwatts</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For Fermi 
        /// &amp;tm;
        /// or newer fully supported devices.The power limit defines the upper boundary for the card's power draw. If
        /// the card's total power draw reaches this limit the power management algorithm kicks in.This reading is only available if power management mode is supported. 
        /// See nvmlDeviceGetPowerManagementMode. NVML_SUCCESS                 if \a limit has been set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a limit is NULL- NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetPowerManagementLimit(nvmlDevice_st device, ref uint limit);
        
        /// <summary>
        /// Retrieves information about possible values of power management limits on this device.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="minLimit">Reference in which to return the minimum power management limit in milliwatts</param>
        /// <param name="maxLimit">Reference in which to return the maximum power management limit in milliwatts</param>
        /// <returns>-</returns>
        /// <seealso cref="nvmlDeviceSetPowerManagementLimit"/>
        /// 
        /// <remarks>
        /// For Kepler 
        /// &amp;tm;
        /// or newer fully supported devices. NVML_SUCCESS                 if \a minLimit and \a maxLimit have been set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a minLimit or \a maxLimit is NULL- NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetPowerManagementLimitConstraints(nvmlDevice_st device, ref uint minLimit, ref uint maxLimit);
        
        /// <summary>
        /// Retrieves default power management limit on this device, in milliwatts.
        /// Default power management limit is a power management limit that the device boots with.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="defaultLimit">Reference in which to return the default power management limit in milliwatts</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For Kepler 
        /// &amp;tm;
        /// or newer fully supported devices. NVML_SUCCESS                 if \a defaultLimit has been set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a defaultLimit is NULL- NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetPowerManagementDefaultLimit(nvmlDevice_st device, ref uint defaultLimit);
        
        /// <summary>
        /// Retrieves power usage for this GPU in milliwatts and its associated circuitry (e.g. memory)
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="power">Reference in which to return the power usage information</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For Fermi 
        /// &amp;tm;
        /// or newer fully supported devices.On Fermi and Kepler GPUs the reading is accurate to within +/- 5% of current power draw.It is only available if power management mode is supported. See nvmlDeviceGetPowerManagementMode. NVML_SUCCESS                 if \a power has been populated- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a power is NULL- NVML_ERROR_NOT_SUPPORTED     if the device does not support power readings- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetPowerUsage(nvmlDevice_st device, ref uint power);
        
        /// <summary>
        /// Retrieves total energy consumption for this GPU in millijoules (mJ) since the driver was last reloaded
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="energy">Reference in which to return the energy consumption information</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For newer than Pascal 
        /// &amp;tm;
        /// fully supported devices. NVML_SUCCESS                 if \a energy has been populated- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a energy is NULL- NVML_ERROR_NOT_SUPPORTED     if the device does not support energy readings- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetTotalEnergyConsumption(nvmlDevice_st device, ref ulong energy);
        
        /// <summary>
        /// Get the effective power limit that the driver enforces after taking into account all limiters
        /// </summary>
        /// <param name="device">The device to communicate with</param>
        /// <param name="limit">Reference in which to return the power management limit in milliwatts</param>
        /// <returns>-</returns>
        /// <remarks>
        /// Note: This can be different from the nvmlDeviceGetPowerManagementLimit if other limits are set elsewhereThis includes the out of band power limit interfaceFor Kepler 
        /// &amp;tm;
        /// or newer fully supported devices. NVML_SUCCESS                 if \a limit has been set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a limit is NULL- NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetEnforcedPowerLimit(nvmlDevice_st device, ref uint limit);
        
        /// <summary>
        /// Retrieves the current GOM and pending GOM (the one that GPU will switch to after reboot).
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="current">Reference in which to return the current GOM</param>
        /// <param name="pending">Reference in which to return the pending GOM</param>
        /// <returns>-</returns>
        /// <seealso cref="nvmlGpuOperationMode_t"/>
        /// 
        /// <seealso cref="nvmlDeviceSetGpuOperationMode"/>
        /// 
        /// <remarks>
        /// For GK110 M-class and X-class Tesla 
        /// &amp;tm;
        /// products from the Kepler family.
        /// Modes NVML_GOM_LOW_DP and \ref NVML_GOM_ALL_ON are supported on fully supported GeForce products.Not supported on Quadro 
        /// ®
        /// and Tesla 
        /// &amp;tm;
        /// C-class products. NVML_SUCCESS                 if \a mode has been populated- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a current or \a pending is NULL- NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetGpuOperationMode(nvmlDevice_st device, ref nvmlGom_enum current, ref nvmlGom_enum pending);
        
        /// <summary>
        /// Retrieves the amount of used, free and total memory available on the device, in bytes.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="memory">Reference in which to return the memory information</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For all products.Enabling ECC reduces the amount of total available memory, due to the extra required parity bits.
        /// Under WDDM most device memory is allocated and managed on startup by Windows.Under Linux and Windows TCC, the reported amount of used memory is equal to the sum of memory allocated 
        /// by all active channels on the device.See nvmlMemory_t for details on available memory info. NVML_SUCCESS                 if \a memory has been populated- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a memory is NULL- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetMemoryInfo(nvmlDevice_st device, ref nvmlMemory_st memory);
        
        /// <summary>
        /// Retrieves the current compute mode for the device.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="mode">Reference in which to return the current compute mode</param>
        /// <returns>-</returns>
        /// <seealso cref="nvmlDeviceSetComputeMode()"/>
        /// 
        /// <remarks>
        /// For all products.See nvmlComputeMode_t for details on allowed compute modes. NVML_SUCCESS                 if \a mode has been set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a mode is NULL- NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetComputeMode(nvmlDevice_st device, ref nvmlComputeMode_enum mode);
        
        /// <summary>
        /// Retrieves the CUDA compute capability of the device.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="major">Reference in which to return the major CUDA compute capability</param>
        /// <param name="minor">Reference in which to return the minor CUDA compute capability</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For all products.Returns the major and minor compute capability version numbers of the
        /// device.  The major and minor versions are equivalent to the
        /// CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MINOR and
        /// CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MAJOR attributes that would be
        /// returned by CUDA's cuDeviceGetAttribute(). NVML_SUCCESS                 if \a major and \a minor have been set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a major or \a minor are NULL- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetCudaComputeCapability(nvmlDevice_st device, ref int major, ref int minor);
        
        /// <summary>
        /// Retrieves the current and pending ECC modes for the device.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="current">Reference in which to return the current ECC mode</param>
        /// <param name="pending">Reference in which to return the pending ECC mode</param>
        /// <returns>-</returns>
        /// <seealso cref="nvmlDeviceSetEccMode()"/>
        /// 
        /// <remarks>
        /// For Fermi 
        /// &amp;tm;
        /// or newer fully supported devices.
        /// Only applicable to devices with ECC.
        /// Requires @a NVML_INFOROM_ECC version 1.0 or higher.Changing ECC modes requires a reboot. The "pending" ECC mode refers to the target mode following
        /// the next reboot.See nvmlEnableState_t for details on allowed modes. NVML_SUCCESS                 if \a current and \a pending have been set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or either \a current or \a pending is NULL- NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetEccMode(nvmlDevice_st device, ref nvmlEnableState_enum current, ref nvmlEnableState_enum pending);
        
        /// <summary>
        /// Retrieves the device boardId from 0-N.
        /// Devices with the same boardId indicate GPUs connected to the same PLX.  Use in conjunction with
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="boardId">Reference in which to return the device's board ID</param>
        /// <returns>-</returns>
        /// <remarks>
        ///  nvmlDeviceGetMultiGpuBoard() to decide if they are on the same board as well.The boardId returned is a unique ID for the current configuration.  Uniqueness and ordering across 
        /// reboots and system configurations is not guaranteed (i.e. if a Tesla K40c returns 0x100 and
        /// the two GPUs on a Tesla K10 in the same system returns 0x200 it is not guaranteed they will 
        /// always return those values but they will always be different from each other).For Fermi 
        /// &amp;tm;
        /// or newer fully supported devices. NVML_SUCCESS                 if \a boardId has been set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a boardId is NULL- NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetBoardId(nvmlDevice_st device, ref uint boardId);
        
        /// <summary>
        /// Retrieves whether the device is on a Multi-GPU Board
        /// Devices that are on multi-GPU boards will set @a multiGpuBool to a non-zero value.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="multiGpuBool">Reference in which to return a zero or non-zero value
        /// to indicate whether the device is on a multi GPU board</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For Fermi 
        /// &amp;tm;
        /// or newer fully supported devices. NVML_SUCCESS                 if \a multiGpuBool has been set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a multiGpuBool is NULL- NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetMultiGpuBoard(nvmlDevice_st device, ref uint multiGpuBool);
        
        /// <summary>
        /// Retrieves the total ECC error counts for the device.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="errorType">Flag that specifies the type of the errors.</param>
        /// <param name="counterType">Flag that specifies the counter-type of the errors.</param>
        /// <param name="eccCounts">Reference in which to return the specified ECC errors</param>
        /// <returns>-</returns>
        /// <seealso cref="nvmlDeviceClearEccErrorCounts()"/>
        /// 
        /// <remarks>
        /// For Fermi 
        /// &amp;tm;
        /// or newer fully supported devices.
        /// Only applicable to devices with ECC.
        /// Requires @a NVML_INFOROM_ECC version 1.0 or higher.
        /// Requires ECC Mode to be enabled.The total error count is the sum of errors across each of the separate memory systems, i.e. the total set of 
        /// errors across the entire device.See nvmlMemoryErrorType_t for a description of available error types.\nSee nvmlEccCounterType_t for a description of available counter types. NVML_SUCCESS                 if \a eccCounts has been set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device, \a errorType or \a counterType is invalid, or \a eccCounts is NULL- NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetTotalEccErrors(nvmlDevice_st device, nvmlMemoryErrorType_enum errorType, nvmlEccCounterType_enum counterType, ref ulong eccCounts);
        
        /// <summary>
        /// Retrieves the detailed ECC error counts for the device.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="errorType">Flag that specifies the type of the errors.</param>
        /// <param name="counterType">Flag that specifies the counter-type of the errors.</param>
        /// <param name="eccCounts">Reference in which to return the specified ECC errors</param>
        /// <returns>-</returns>
        /// <seealso cref="nvmlDeviceClearEccErrorCounts()"/>
        /// 
        /// <remarks>
        /// @deprecated This API supports only a fixed set of ECC error locations
        /// On different GPU architectures different locations are supported
        /// See nvmlDeviceGetMemoryErrorCounterFor Fermi 
        /// &amp;tm;
        /// or newer fully supported devices.
        /// Only applicable to devices with ECC.
        /// Requires @a NVML_INFOROM_ECC version 2.0 or higher to report aggregate location-based ECC counts.
        /// Requires @a NVML_INFOROM_ECC version 1.0 or higher to report all other ECC counts.
        /// Requires ECC Mode to be enabled.Detailed errors provide separate ECC counts for specific parts of the memory system.Reports zero for unsupported ECC error counters when a subset of ECC error counters are supported.See nvmlMemoryErrorType_t for a description of available bit types.\nSee nvmlEccCounterType_t for a description of available counter types.\nSee nvmlEccErrorCounts_t for a description of provided detailed ECC counts. NVML_SUCCESS                 if \a eccCounts has been populated- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device, \a errorType or \a counterType is invalid, or \a eccCounts is NULL- NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetDetailedEccErrors(nvmlDevice_st device, nvmlMemoryErrorType_enum errorType, nvmlEccCounterType_enum counterType, ref nvmlEccErrorCounts_st eccCounts);
        
        /// <summary>
        /// Retrieves the requested memory error counter for the device.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="errorType">Flag that specifies the type of error.</param>
        /// <param name="counterType">Flag that specifies the counter-type of the errors.</param>
        /// <param name="locationType">Specifies the location of the counter.</param>
        /// <param name="count">Reference in which to return the ECC counter</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For Fermi 
        /// &amp;tm;
        /// or newer fully supported devices.
        /// Requires @a NVML_INFOROM_ECC version 2.0 or higher to report aggregate location-based memory error counts.
        /// Requires @a NVML_INFOROM_ECC version 1.0 or higher to report all other memory error counts.Only applicable to devices with ECC.Requires ECC Mode to be enabled.See nvmlMemoryErrorType_t for a description of available memory error types.\nSee nvmlEccCounterType_t for a description of available counter types.\nSee nvmlMemoryLocation_t for a description of available counter locations.\n NVML_SUCCESS                 if \a count has been populated- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device, \a bitTyp,e \a counterType or \a locationType isinvalid, or @a count is NULL
        /// - NVML_ERROR_NOT_SUPPORTED     if the device does not support ECC error reporting in the specified memory- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetMemoryErrorCounter(nvmlDevice_st device, nvmlMemoryErrorType_enum errorType, nvmlEccCounterType_enum counterType, nvmlMemoryLocation_enum locationType, ref ulong count);
        
        /// <summary>
        /// Retrieves the current utilization rates for the device's major subsystems.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="utilization">Reference in which to return the utilization information</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For Fermi 
        /// &amp;tm;
        /// or newer fully supported devices.See nvmlUtilization_t for details on available utilization rates.@note During driver initialization when ECC is enabled one can see high GPU and Memory Utilization readings.
        /// This is caused by ECC Memory Scrubbing mechanism that is performed during driver initialization. NVML_SUCCESS                 if \a utilization has been populated- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a utilization is NULL- NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetUtilizationRates(nvmlDevice_st device, ref nvmlUtilization_st utilization);
        
        /// <summary>
        /// Retrieves the current utilization and sampling size in microseconds for the Encoder
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="utilization">Reference to an unsigned int for encoder utilization info</param>
        /// <param name="samplingPeriodUs">Reference to an unsigned int for the sampling period in US</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For Kepler 
        /// &amp;tm;
        /// or newer fully supported devices. NVML_SUCCESS                 if \a utilization has been populated- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, \a utilization is NULL, or \a samplingPeriodUs is NULL- NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetEncoderUtilization(nvmlDevice_st device, ref uint utilization, ref uint samplingPeriodUs);
        
        /// <summary>
        /// Retrieves the current capacity of the device's encoder, as a percentage of maximum encoder capacity with valid values in the range 0-100.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="encoderQueryType">Type of encoder to query</param>
        /// <param name="encoderCapacity">Reference to an unsigned int for the encoder capacity</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For Maxwell 
        /// &amp;tm;
        /// or newer fully supported devices. NVML_SUCCESS                  if \a encoderCapacity is fetched- NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT   if \a encoderCapacity is NULL, or \a device or \a encoderQueryTypeare invalid
        /// - NVML_ERROR_NOT_SUPPORTED      if device does not support the encoder specified in \a encodeQueryType- NVML_ERROR_GPU_IS_LOST        if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN            on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetEncoderCapacity(nvmlDevice_st device, nvmlEncoderQueryType_enum encoderQueryType, ref uint encoderCapacity);
        
        /// <summary>
        /// Retrieves the current encoder statistics for a given device.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="sessionCount">Reference to an unsigned int for count of active encoder sessions</param>
        /// <param name="averageFps">Reference to an unsigned int for trailing average FPS of all active sessions</param>
        /// <param name="averageLatency">Reference to an unsigned int for encode latency in microseconds</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For Maxwell 
        /// &amp;tm;
        /// or newer fully supported devices. NVML_SUCCESS                  if \a sessionCount, \a averageFps and \a averageLatency is fetched- NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT   if \a sessionCount, or \a device or \a averageFps,or @a averageLatency is NULL
        /// - NVML_ERROR_GPU_IS_LOST        if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN            on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetEncoderStats(nvmlDevice_st device, ref uint sessionCount, ref uint averageFps, ref uint averageLatency);
        
        /// <summary>
        /// Retrieves information about active encoder sessions on a target device.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="sessionCount">Reference to caller supplied array size, and returns the number of sessions.</param>
        /// <param name="sessionInfos">Reference in which to return the session information</param>
        /// <returns>-</returns>
        /// <remarks>
        /// An array of active encoder sessions is returned in the caller-supplied buffer pointed at by @a sessionInfos. The
        /// array elememt count is passed in @a sessionCount, and @a sessionCount is used to return the number of sessions
        /// written to the buffer.If the supplied buffer is not large enough to accomodate the active session array, the function returns
        /// NVML_ERROR_INSUFFICIENT_SIZE, with the element count of nvmlEncoderSessionInfo_t array required in @a sessionCount. To query the number of active encoder sessions, call this function with *sessionCount = 0.  The code will return
        /// NVML_SUCCESS with number of active encoder sessions updated in *sessionCount.For Maxwell 
        /// &amp;tm;
        /// or newer fully supported devices. NVML_SUCCESS                  if \a sessionInfos is fetched- NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized- NVML_ERROR_INSUFFICIENT_SIZE  if \a sessionCount is too small, array element count is returned in \a sessionCount- NVML_ERROR_INVALID_ARGUMENT   if \a sessionCount is NULL.- NVML_ERROR_GPU_IS_LOST        if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN            on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetEncoderSessions(nvmlDevice_st device, ref uint sessionCount, ref nvmlEncoderSessionInfo_st sessionInfos);
        
        /// <summary>
        /// Retrieves the current utilization and sampling size in microseconds for the Decoder
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="utilization">Reference to an unsigned int for decoder utilization info</param>
        /// <param name="samplingPeriodUs">Reference to an unsigned int for the sampling period in US</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For Kepler 
        /// &amp;tm;
        /// or newer fully supported devices. NVML_SUCCESS                 if \a utilization has been populated- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, \a utilization is NULL, or \a samplingPeriodUs is NULL- NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetDecoderUtilization(nvmlDevice_st device, ref uint utilization, ref uint samplingPeriodUs);
        
        /// <summary>
        /// Retrieves the active frame buffer capture sessions statistics for a given device.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="fbcStats">Reference to nvmlFBCStats_t structure contianing NvFBC stats</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For Maxwell 
        /// &amp;tm;
        /// or newer fully supported devices. NVML_SUCCESS                  if \a fbcStats is fetched- NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT   if \a fbcStats is NULL- NVML_ERROR_GPU_IS_LOST        if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN            on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetFBCStats(nvmlDevice_st device, ref nvmlFBCStats_st fbcStats);
        
        /// <summary>
        /// Retrieves information about active frame buffer capture sessions on a target device.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="sessionCount">Reference to caller supplied array size, and returns the number of sessions.</param>
        /// <param name="sessionInfo">Reference in which to return the session information</param>
        /// <returns>-</returns>
        /// <remarks>
        /// An array of active FBC sessions is returned in the caller-supplied buffer pointed at by @a sessionInfo. The
        /// array element count is passed in @a sessionCount, and @a sessionCount is used to return the number of sessions
        /// written to the buffer.If the supplied buffer is not large enough to accomodate the active session array, the function returns
        /// NVML_ERROR_INSUFFICIENT_SIZE, with the element count of nvmlFBCSessionInfo_t array required in @a sessionCount. To query the number of active FBC sessions, call this function with *sessionCount = 0.  The code will return
        /// NVML_SUCCESS with number of active FBC sessions updated in *sessionCount.For Maxwell 
        /// &amp;tm;
        /// or newer fully supported devices.@note hResolution, vResolution, averageFPS and averageLatency data for a FBC session returned in @a sessionInfo may
        /// be zero if there are no new frames captured since the session started. NVML_SUCCESS                  if \a sessionInfo is fetched- NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized- NVML_ERROR_INSUFFICIENT_SIZE  if \a sessionCount is too small, array element count is returned in \a sessionCount- NVML_ERROR_INVALID_ARGUMENT   if \a sessionCount is NULL.- NVML_ERROR_GPU_IS_LOST        if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN            on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetFBCSessions(nvmlDevice_st device, ref uint sessionCount, ref nvmlFBCSessionInfo_st sessionInfo);
        
        /// <summary>
        /// Retrieves the current and pending driver model for the device.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="current">Reference in which to return the current driver model</param>
        /// <param name="pending">Reference in which to return the pending driver model</param>
        /// <returns>-</returns>
        /// <seealso cref="nvmlDeviceSetDriverModel()"/>
        /// 
        /// <remarks>
        /// For Fermi 
        /// &amp;tm;
        /// or newer fully supported devices.
        /// For windows only.On Windows platforms the device driver can run in either WDDM or WDM (TCC) mode. If a display is attached
        /// to the device it must run in WDDM mode. TCC mode is preferred if a display is not attached.See nvmlDriverModel_t for details on available driver models. NVML_SUCCESS                 if either \a current and/or \a pending have been set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or both \a current and \a pending are NULL- NVML_ERROR_NOT_SUPPORTED     if the platform is not windows- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetDriverModel(nvmlDevice_st device, ref nvmlDriverModel_enum current, ref nvmlDriverModel_enum pending);
        
        /// <summary>
        /// Get VBIOS version of the device.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="version">Reference to which to return the VBIOS version</param>
        /// <param name="length">The maximum allowed length of the string returned in @a version</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For all products.The VBIOS version may change from time to time. It will not exceed 32 characters in length 
        /// (including the NULL terminator).  See nvmlConstants::NVML_DEVICE_VBIOS_VERSION_BUFFER_SIZE. NVML_SUCCESS                 if \a version has been set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, or \a version is NULL- NVML_ERROR_INSUFFICIENT_SIZE if \a length is too small- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetVbiosVersion(nvmlDevice_st device, IntPtr version, uint length);
        
        /// <summary>
        /// Get Bridge Chip Information for all the bridge chips on the board.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="bridgeHierarchy">Reference to the returned bridge chip Hierarchy</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For all fully supported products.
        /// Only applicable to multi-GPU products. NVML_SUCCESS                 if bridge chip exists- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, or \a bridgeInfo is NULL- NVML_ERROR_NOT_SUPPORTED     if bridge chip not supported on the device- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetBridgeChipInfo(nvmlDevice_st device, ref nvmlBridgeChipHierarchy_st bridgeHierarchy);
        
        /// <summary>
        /// Get information about processes with a compute context on a device
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="infoCount">Reference in which to provide the @a infos array size, and
        /// to return the number of returned elements</param>
        /// <param name="infos">Reference in which to return the process information</param>
        /// <returns>-</returns>
        /// <seealso cref=""/>
        /// 
        /// <remarks>
        /// For Fermi 
        /// &amp;tm;
        /// or newer fully supported devices.This function returns information only about compute running processes (e.g. CUDA application which have
        /// active context). Any graphics applications (e.g. using OpenGL, DirectX) won't be listed by this function.To query the current number of running compute processes, call this function with *infoCount = 0. The
        /// return code will be NVML_ERROR_INSUFFICIENT_SIZE, or NVML_SUCCESS if none are running. For this call
        /// @a infos is allowed to be NULL.The usedGpuMemory field returned is all of the memory used by the application.Keep in mind that information returned by this call is dynamic and the number of elements might change in
        /// time. Allocate more space for @a infos table in case new compute processes are spawned. NVML_SUCCESS                 if \a infoCount and \a infos have been populated- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INSUFFICIENT_SIZE if \a infoCount indicates that the \a infos array is too small@a infoCount will contain minimal amount of space necessary for
        /// the call to complete
        /// - NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, either of \a infoCount or \a infos is NULL- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error nvmlSystemGetProcessName
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetComputeRunningProcesses(nvmlDevice_st device, ref uint infoCount, ref nvmlProcessInfo_st infos);
        
        /// <summary>
        /// Get information about processes with a graphics context on a device
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="infoCount">Reference in which to provide the @a infos array size, and
        /// to return the number of returned elements</param>
        /// <param name="infos">Reference in which to return the process information</param>
        /// <returns>-</returns>
        /// <seealso cref=""/>
        /// 
        /// <remarks>
        /// For Kepler 
        /// &amp;tm;
        /// or newer fully supported devices.This function returns information only about graphics based processes 
        /// (eg. applications using OpenGL, DirectX)To query the current number of running graphics processes, call this function with *infoCount = 0. The
        /// return code will be NVML_ERROR_INSUFFICIENT_SIZE, or NVML_SUCCESS if none are running. For this call
        /// @a infos is allowed to be NULL.The usedGpuMemory field returned is all of the memory used by the application.Keep in mind that information returned by this call is dynamic and the number of elements might change in
        /// time. Allocate more space for @a infos table in case new graphics processes are spawned. NVML_SUCCESS                 if \a infoCount and \a infos have been populated- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INSUFFICIENT_SIZE if \a infoCount indicates that the \a infos array is too small@a infoCount will contain minimal amount of space necessary for
        /// the call to complete
        /// - NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, either of \a infoCount or \a infos is NULL- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error nvmlSystemGetProcessName
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetGraphicsRunningProcesses(nvmlDevice_st device, ref uint infoCount, ref nvmlProcessInfo_st infos);
        
        /// <summary>
        /// Check if the GPU devices are on the same physical board.
        /// </summary>
        /// <param name="device1">The first GPU device</param>
        /// <param name="device2">The second GPU device</param>
        /// <param name="onSameBoard">Reference in which to return the status.
        /// Non-zero indicates that the GPUs are on the same board.</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For all fully supported products. NVML_SUCCESS                 if \a onSameBoard has been set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a dev1 or \a dev2 are invalid or \a onSameBoard is NULL- NVML_ERROR_NOT_SUPPORTED     if this check is not supported by the device- NVML_ERROR_GPU_IS_LOST       if the either GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceOnSameBoard(nvmlDevice_st device1, nvmlDevice_st device2, ref int onSameBoard);
        
        /// <summary>
        /// Retrieves the root/admin permissions on the target API. See @a nvmlRestrictedAPI_t for the list of supported APIs.
        /// If an API is restricted only root users can call that API. See @a nvmlDeviceSetAPIRestriction to change current permissions.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="apiType">Target API type for this operation</param>
        /// <param name="isRestricted">Reference in which to return the current restriction 
        /// NVML_FEATURE_ENABLED indicates that the API is root-only
        /// NVML_FEATURE_DISABLED indicates that the API is accessible to all users</param>
        /// <returns>-</returns>
        /// <seealso cref="nvmlRestrictedAPI_t"/>
        /// 
        /// <remarks>
        /// For all fully supported products. NVML_SUCCESS                 if \a isRestricted has been set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, \a apiType incorrect or \a isRestricted is NULL- NVML_ERROR_NOT_SUPPORTED     if this query is not supported by the device or the device does not supportthe feature that is being queried (E.G. Enabling/disabling Auto Boosted clocks is
        /// not supported by the device)
        /// - NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetAPIRestriction(nvmlDevice_st device, nvmlRestrictedAPI_enum apiType, ref nvmlEnableState_enum isRestricted);
        
        /// <summary>
        /// Gets recent samples for the GPU.
        /// </summary>
        /// <param name="device">The identifier for the target device</param>
        /// <param name="type">Type of sampling event</param>
        /// <param name="lastSeenTimeStamp">Return only samples with timestamp greater than lastSeenTimeStamp.</param>
        /// <param name="sampleValType">Output parameter to represent the type of sample value as described in nvmlSampleVal_t</param>
        /// <param name="sampleCount">Reference to provide the number of elements which can be queried in samples array</param>
        /// <param name="samples">Reference in which samples are returned</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For Kepler 
        /// &amp;tm;
        /// or newer fully supported devices.Based on type, this method can be used to fetch the power, utilization or clock samples maintained in the buffer by 
        /// the driver.Power, Utilization and Clock samples are returned as type "unsigned int" for the union nvmlValue_t.To get the size of samples that user needs to allocate, the method is invoked with samples set to NULL. 
        /// The returned samplesCount will provide the number of samples that can be queried. The user needs to 
        /// allocate the buffer with size as samplesCount * sizeof(nvmlSample_t).lastSeenTimeStamp represents CPU timestamp in microseconds. Set it to 0 to fetch all the samples maintained by the 
        /// underlying buffer. Set lastSeenTimeStamp to one of the timeStamps retrieved from the date of the previous query 
        /// to get more recent samples.This method fetches the number of entries which can be accommodated in the provided samples array, and the 
        /// reference samplesCount is updated to indicate how many samples were actually retrieved. The advantage of using this 
        /// method for samples in contrast to polling via existing methods is to get get higher frequency data at lower polling cost. NVML_SUCCESS                 if samples are successfully retrieved- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, \a samplesCount is NULL orreference to @a sampleCount is 0 for non null @a samples - NVML_ERROR_NOT_SUPPORTED     if this query is not supported by the device- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_NOT_FOUND         if sample entries are not found- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetSamples(nvmlDevice_st device, nvmlSamplingType_enum type, ulong lastSeenTimeStamp, ref nvmlValueType_enum sampleValType, ref uint sampleCount, ref nvmlSample_st samples);
        
        /// <summary>
        /// Gets Total, Available and Used size of BAR1 memory.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="bar1Memory">Reference in which BAR1 memory
        /// information is returned.</param>
        /// <returns>-</returns>
        /// <remarks>
        /// BAR1 is used to map the FB (device memory) so that it can be directly accessed by the CPU or by 3rd party 
        /// devices (peer-to-peer on the PCIE bus).For Kepler 
        /// &amp;tm;
        /// or newer fully supported devices. NVML_SUCCESS                 if BAR1 memory is successfully retrieved- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, \a bar1Memory is NULL- NVML_ERROR_NOT_SUPPORTED     if this query is not supported by the device- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetBAR1MemoryInfo(nvmlDevice_st device, ref nvmlBAR1Memory_st bar1Memory);
        
        /// <summary>
        /// Gets the duration of time during which the device was throttled (lower than requested clocks) due to power 
        /// or thermal constraints.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="perfPolicyType">Represents Performance policy which can trigger GPU throttling</param>
        /// <param name="violTime">Reference to which violation time related information is returned</param>
        /// <returns>-</returns>
        /// <remarks>
        /// The method is important to users who are tying to understand if their GPUs throttle at any point during their applications. The
        /// difference in violation times at two different reference times gives the indication of GPU throttling event.Violation for thermal capping is not supported at this time.For Kepler 
        /// &amp;tm;
        /// or newer fully supported devices. NVML_SUCCESS                 if violation time is successfully retrieved- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, \a perfPolicyType is invalid, or \a violTime is NULL- NVML_ERROR_NOT_SUPPORTED     if this query is not supported by the device- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetViolationStatus(nvmlDevice_st device, nvmlPerfPolicyType_enum perfPolicyType, ref nvmlViolationTime_st violTime);
        
        /// <summary>
        /// Queries the state of per process accounting mode.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="mode">Reference in which to return the current accounting mode</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For Kepler 
        /// &amp;tm;
        /// or newer fully supported devices.See nvmlDeviceGetAccountingStats for more details.See nvmlDeviceSetAccountingMode NVML_SUCCESS                 if the mode has been successfully retrieved- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a mode are NULL- NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetAccountingMode(nvmlDevice_st device, ref nvmlEnableState_enum mode);
        
        /// <summary>
        /// Queries process's accounting stats.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="pid">Process Id of the target process to query stats for</param>
        /// <param name="stats">Reference in which to return the process's accounting stats</param>
        /// <returns>-</returns>
        /// <seealso cref="nvmlDeviceGetAccountingBufferSize"/>
        /// 
        /// <remarks>
        /// For Kepler 
        /// &amp;tm;
        /// or newer fully supported devices.Accounting stats capture GPU utilization and other statistics across the lifetime of a process.
        /// Accounting stats can be queried during life time of the process and after its termination.
        /// The time field in nvmlAccountingStats_t is reported as 0 during the lifetime of the process andupdated to actual running time after its termination.
        /// Accounting stats are kept in a circular buffer, newly created processes overwrite information about old
        /// processes.See nvmlAccountingStats_t for description of each returned metric.List of processes that can be queried can be retrieved from nvmlDeviceGetAccountingPids.@note Accounting Mode needs to be on. See nvmlDeviceGetAccountingMode.@note Only compute and graphics applications stats can be queried. Monitoring applications stats can't be
        /// queried since they don't contribute to GPU utilization.@note In case of pid collision stats of only the latest process (that terminated last) will be reported@warning On Kepler devices per process statistics are accurate only if there's one process running on a GPU. NVML_SUCCESS                 if stats have been successfully retrieved- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a stats are NULL- NVML_ERROR_NOT_FOUND         if process stats were not found- NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature or accounting mode is disabled- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetAccountingStats(nvmlDevice_st device, uint pid, ref nvmlAccountingStats_st stats);
        
        /// <summary>
        /// Queries list of processes that can be queried for accounting stats. The list of processes returned 
        /// can be in running or terminated state.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="count">Reference in which to provide the @a pids array size, and
        /// to return the number of elements ready to be queried</param>
        /// <param name="pids">Reference in which to return list of process ids</param>
        /// <returns>-</returns>
        /// <seealso cref="nvmlDeviceGetAccountingBufferSize"/>
        /// 
        /// <remarks>
        /// For Kepler 
        /// &amp;tm;
        /// or newer fully supported devices.To just query the number of processes ready to be queried, call this function with *count = 0 and
        /// pids=NULL. The return code will be NVML_ERROR_INSUFFICIENT_SIZE, or NVML_SUCCESS if list is empty.For more details see nvmlDeviceGetAccountingStats.@note In case of PID collision some processes might not be accessible before the circular buffer is full. NVML_SUCCESS                 if pids were successfully retrieved- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a count is NULL- NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature or accounting mode is disabled- NVML_ERROR_INSUFFICIENT_SIZE if \a count is too small (\a count is set toexpected value)
        /// - NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetAccountingPids(nvmlDevice_st device, ref uint count, ref uint pids);
        
        /// <summary>
        /// Returns the number of processes that the circular buffer with accounting pids can hold.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="bufferSize">Reference in which to provide the size (in number of elements)
        /// of the circular buffer for accounting stats.</param>
        /// <returns>-</returns>
        /// <seealso cref="nvmlDeviceGetAccountingStats"/>
        /// 
        /// <seealso cref="nvmlDeviceGetAccountingPids"/>
        /// 
        /// <remarks>
        /// For Kepler 
        /// &amp;tm;
        /// or newer fully supported devices.This is the maximum number of processes that accounting information will be stored for before information
        /// about oldest processes will get overwritten by information about new processes. NVML_SUCCESS                 if buffer size was successfully retrieved- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a bufferSize is NULL- NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature or accounting mode is disabled- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetAccountingBufferSize(nvmlDevice_st device, ref uint bufferSize);
        
        /// <summary>
        /// Returns the list of retired pages by source, including pages that are pending retirement
        /// The address information provided from this API is the hardware address of the page that was retired.  Note
        /// that this does not match the virtual address used in CUDA, but will match the address information in XID 63
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="cause">Filter page addresses by cause of retirement</param>
        /// <param name="pageCount">Reference in which to provide the @a addresses buffer size, and
        /// to return the number of retired pages that match @a cause Set to 0 to query the size without allocating an @a addresses buffer</param>
        /// <param name="addresses">Buffer to write the page addresses into</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For Kepler 
        /// &amp;tm;
        /// or newer fully supported devices. NVML_SUCCESS                 if \a pageCount was populated and \a addresses was filled- NVML_ERROR_INSUFFICIENT_SIZE if \a pageCount indicates the buffer is not large enough to store all thematching page addresses.  @a pageCount is set to the needed size.
        /// - NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, \a pageCount is NULL, \a cause is invalid, or@a addresses is NULL
        /// - NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetRetiredPages(nvmlDevice_st device, nvmlPageRetirementCause_enum cause, ref uint pageCount, ref ulong addresses);
        
        /// <summary>
        /// Returns the list of retired pages by source, including pages that are pending retirement
        /// The address information provided from this API is the hardware address of the page that was retired.  Note
        /// that this does not match the virtual address used in CUDA, but will match the address information in XID 63
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="cause">Filter page addresses by cause of retirement</param>
        /// <param name="pageCount">Reference in which to provide the @a addresses buffer size, and
        /// to return the number of retired pages that match @a cause Set to 0 to query the size without allocating an @a addresses buffer</param>
        /// <param name="addresses">Buffer to write the page addresses into</param>
        /// <param name="timestamps">Buffer to write the timestamps of page retirement, additional for _v2</param>
        /// <returns>-</returns>
        /// <remarks>
        /// @note nvmlDeviceGetRetiredPages_v2 adds an additional timestamps paramter to return the time of each page's
        /// retirement.For Kepler 
        /// &amp;tm;
        /// or newer fully supported devices. NVML_SUCCESS                 if \a pageCount was populated and \a addresses was filled- NVML_ERROR_INSUFFICIENT_SIZE if \a pageCount indicates the buffer is not large enough to store all thematching page addresses.  @a pageCount is set to the needed size.
        /// - NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, \a pageCount is NULL, \a cause is invalid, or@a addresses is NULL
        /// - NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetRetiredPages_v2(nvmlDevice_st device, nvmlPageRetirementCause_enum cause, ref uint pageCount, ref ulong addresses, ref ulong timestamps);
        
        /// <summary>
        /// Check if any pages are pending retirement and need a reboot to fully retire.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="isPending">Reference in which to return the pending status</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For Kepler 
        /// &amp;tm;
        /// or newer fully supported devices. NVML_SUCCESS                 if \a isPending was populated- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a isPending is NULL- NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetRetiredPagesPendingStatus(nvmlDevice_st device, ref nvmlEnableState_enum isPending);
        
        /// <summary>
        /// Set the LED state for the unit. The LED can be either green (0) or amber (1).
        /// </summary>
        /// <param name="unit">The identifier of the target unit</param>
        /// <param name="color">The target LED color</param>
        /// <returns>-</returns>
        /// <seealso cref="nvmlUnitGetLedState()"/>
        /// 
        /// <remarks>
        /// For S-class products.
        /// Requires root/admin permissions.This operation takes effect immediately.&lt;b&gt;Current S-Class products don't provide unique LEDs for each unit. As such, both front 
        /// and back LEDs will be toggled in unison regardless of which unit is specified with this command.&lt;/b&gt;See nvmlLedColor_t for available colors. NVML_SUCCESS                 if the LED color has been set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a unit or \a color is invalid- NVML_ERROR_NOT_SUPPORTED     if this is not an S-class product- NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlUnitSetLedState(nvmlUnit_st unit, nvmlLedColor_enum color);
        
        /// <summary>
        /// Set the persistence mode for the device.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="mode">The target persistence mode</param>
        /// <returns>-</returns>
        /// <seealso cref="nvmlDeviceGetPersistenceMode()"/>
        /// 
        /// <remarks>
        /// For all products.
        /// For Linux only.
        /// Requires root/admin permissions.The persistence mode determines whether the GPU driver software is torn down after the last client
        /// exits.This operation takes effect immediately. It is not persistent across reboots. After each reboot the
        /// persistence mode is reset to "Disabled".See nvmlEnableState_t for available modes.After calling this API with mode set to NVML_FEATURE_DISABLED on a device that has its own NUMA
        /// memory, the given device handle will no longer be valid, and to continue to interact with this
        /// device, a new handle should be obtained from one of the nvmlDeviceGetHandleBy*() APIs. This
        /// limitation is currently only applicable to devices that have a coherent NVLink connection to
        /// system memory. NVML_SUCCESS                 if the persistence mode was set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a mode is invalid- NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature- NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceSetPersistenceMode(nvmlDevice_st device, nvmlEnableState_enum mode);
        
        /// <summary>
        /// Set the compute mode for the device.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="mode">The target compute mode</param>
        /// <returns>-</returns>
        /// <seealso cref="nvmlDeviceGetComputeMode()"/>
        /// 
        /// <remarks>
        /// For all products.
        /// Requires root/admin permissions.The compute mode determines whether a GPU can be used for compute operations and whether it can
        /// be shared across contexts.This operation takes effect immediately. Under Linux it is not persistent across reboots and
        /// always resets to "Default". Under windows it is persistent.Under windows compute mode may only be set to DEFAULT when running in WDDMSee nvmlComputeMode_t for details on available compute modes. NVML_SUCCESS                 if the compute mode was set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a mode is invalid- NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature- NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceSetComputeMode(nvmlDevice_st device, nvmlComputeMode_enum mode);
        
        /// <summary>
        /// Set the ECC mode for the device.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="ecc">The target ECC mode</param>
        /// <returns>-</returns>
        /// <seealso cref="nvmlDeviceGetEccMode()"/>
        /// 
        /// <remarks>
        /// For Kepler 
        /// &amp;tm;
        /// or newer fully supported devices.
        /// Only applicable to devices with ECC.
        /// Requires @a NVML_INFOROM_ECC version 1.0 or higher.
        /// Requires root/admin permissions.The ECC mode determines whether the GPU enables its ECC support.This operation takes effect after the next reboot.See nvmlEnableState_t for details on available modes. NVML_SUCCESS                 if the ECC mode was set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a ecc is invalid- NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature- NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceSetEccMode(nvmlDevice_st device, nvmlEnableState_enum ecc);
        
        /// <summary>
        /// Clear the ECC error and other memory error counts for the device.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="counterType">Flag that indicates which type of errors should be cleared.</param>
        /// <returns>-</returns>
        /// <seealso cref="- nvmlDeviceGetDetailedEccErrors()
        /// - nvmlDeviceGetTotalEccErrors()"/>
        /// 
        /// <remarks>
        /// For Kepler 
        /// &amp;tm;
        /// or newer fully supported devices.
        /// Only applicable to devices with ECC.
        /// Requires @a NVML_INFOROM_ECC version 2.0 or higher to clear aggregate location-based ECC counts.
        /// Requires @a NVML_INFOROM_ECC version 1.0 or higher to clear all other ECC counts.
        /// Requires root/admin permissions.
        /// Requires ECC Mode to be enabled.Sets all of the specified ECC counters to 0, including both detailed and total counts.This operation takes effect immediately.See nvmlMemoryErrorType_t for details on available counter types. NVML_SUCCESS                 if the error counts were cleared- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a counterType is invalid- NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature- NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceClearEccErrorCounts(nvmlDevice_st device, nvmlEccCounterType_enum counterType);
        
        /// <summary>
        /// Set the driver model for the device.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="driverModel">The target driver model</param>
        /// <param name="flags">Flags that change the default behavior</param>
        /// <returns>-</returns>
        /// <seealso cref="nvmlDeviceGetDriverModel()"/>
        /// 
        /// <remarks>
        /// For Fermi 
        /// &amp;tm;
        /// or newer fully supported devices.
        /// For windows only.
        /// Requires root/admin permissions.On Windows platforms the device driver can run in either WDDM or WDM (TCC) mode. If a display is attached
        /// to the device it must run in WDDM mode.It is possible to force the change to WDM (TCC) while the display is still attached with a force flag (nvmlFlagForce).
        /// This should only be done if the host is subsequently powered down and the display is detached from the device
        /// before the next reboot.This operation takes effect after the next reboot.Windows driver model may only be set to WDDM when running in DEFAULT compute mode.Change driver model to WDDM is not supported when GPU doesn't support graphics acceleration or 
        /// will not support it after reboot. See nvmlDeviceSetGpuOperationMode.See nvmlDriverModel_t for details on available driver models.See nvmlFlagDefault and \ref nvmlFlagForce NVML_SUCCESS                 if the driver model has been set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a driverModel is invalid- NVML_ERROR_NOT_SUPPORTED     if the platform is not windows or the device does not support this feature- NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceSetDriverModel(nvmlDevice_st device, nvmlDriverModel_enum driverModel, uint flags);
        
        /// <summary>
        /// Set clocks that device will lock to.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="minGpuClockMHz">Requested minimum gpu clock in MHz</param>
        /// <param name="maxGpuClockMHz">Requested maximum gpu clock in MHz</param>
        /// <returns>-</returns>
        /// <remarks>
        /// Sets the clocks that the device will be running at to the value in the range of minGpuClockMHz to maxGpuClockMHz.
        /// Setting this will supercede application clock values and take effect regardless if a cuda app is running.
        /// See /ref nvmlDeviceSetApplicationsClocksCan be used as a setting to request constant performance.Requires root/admin permissions.After system reboot or driver reload applications clocks go back to their default value.
        /// See nvmlDeviceResetGpuLockedClocks.For newer than Pascal 
        /// &amp;tm;
        /// fully supported devices. NVML_SUCCESS                 if new settings were successfully set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a minGpuClockMHz and \a maxGpuClockMHzis not a valid clock combination
        /// - NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation- NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceSetGpuLockedClocks(nvmlDevice_st device, uint minGpuClockMHz, uint maxGpuClockMHz);
        
        /// <summary>
        /// Resets the gpu clock to the default value
        /// </summary>
        /// <seealso cref="nvmlDeviceSetGpuLockedClocks"/>
        /// 
        /// <param name="device">The identifier of the target device</param>
        /// <returns>-</returns>
        /// <remarks>
        /// This is the gpu clock that will be used after system reboot or driver reload.
        /// Default values are idle clocks, but the current values can be changed using nvmlDeviceSetApplicationsClocks.For newer than Pascal 
        /// &amp;tm;
        /// fully supported devices. NVML_SUCCESS                 if new settings were successfully set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid- NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceResetGpuLockedClocks(nvmlDevice_st device);
        
        /// <summary>
        /// Set clocks that applications will lock to.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="memClockMHz">Requested memory clock in MHz</param>
        /// <param name="graphicsClockMHz">Requested graphics clock in MHz</param>
        /// <returns>-</returns>
        /// <remarks>
        /// Sets the clocks that compute and graphics applications will be running at.
        /// e.g. CUDA driver requests these clocks during context creation which means this property
        /// defines clocks at which CUDA applications will be running unless some overspec event
        /// occurs (e.g. over power, over thermal or external HW brake).Can be used as a setting to request constant performance.On Pascal and newer hardware, this will automatically disable automatic boosting of clocks.On K80 and newer Kepler and Maxwell GPUs, users desiring fixed performance should also call nvmlDeviceSetAutoBoostedClocksEnabled to prevent clocks from automatically boostingabove the clock value being set.For Kepler 
        /// &amp;tm;
        /// or newer non-GeForce fully supported devices and Maxwell or newer GeForce devices.
        /// Requires root/admin permissions.See nvmlDeviceGetSupportedMemoryClocks and \ref nvmlDeviceGetSupportedGraphicsClocksfor details on how to list available clocks combinations.After system reboot or driver reload applications clocks go back to their default value.
        /// See nvmlDeviceResetApplicationsClocks. NVML_SUCCESS                 if new settings were successfully set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a memClockMHz and \a graphicsClockMHzis not a valid clock combination
        /// - NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation- NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceSetApplicationsClocks(nvmlDevice_st device, uint memClockMHz, uint graphicsClockMHz);
        
        /// <summary>
        /// Set new power limit of this device.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="limit">Power management limit in milliwatts to set</param>
        /// <returns>-</returns>
        /// <seealso cref="nvmlDeviceGetPowerManagementLimitConstraints"/>
        /// 
        /// <seealso cref="nvmlDeviceGetPowerManagementDefaultLimit"/>
        /// 
        /// <remarks>
        /// For Kepler 
        /// &amp;tm;
        /// or newer fully supported devices.
        /// Requires root/admin permissions.See nvmlDeviceGetPowerManagementLimitConstraints to check the allowed ranges of values.@note Limit is not persistent across reboots or driver unloads.
        /// Enable persistent mode to prevent driver from unloading when no application is using the device. NVML_SUCCESS                 if \a limit has been set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a defaultLimit is out of range- NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceSetPowerManagementLimit(nvmlDevice_st device, uint limit);
        
        /// <summary>
        /// Sets new GOM. See @a nvmlGpuOperationMode_t for details.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="mode">Target GOM</param>
        /// <returns>-</returns>
        /// <seealso cref="nvmlGpuOperationMode_t"/>
        /// 
        /// <seealso cref="nvmlDeviceGetGpuOperationMode"/>
        /// 
        /// <remarks>
        /// For GK110 M-class and X-class Tesla 
        /// &amp;tm;
        /// products from the Kepler family.
        /// Modes NVML_GOM_LOW_DP and \ref NVML_GOM_ALL_ON are supported on fully supported GeForce products.Not supported on Quadro 
        /// ®
        /// and Tesla 
        /// &amp;tm;
        /// C-class products.
        /// Requires root/admin permissions.Changing GOMs requires a reboot. 
        /// The reboot requirement might be removed in the future.Compute only GOMs don't support graphics acceleration. Under windows switching to these GOMs when
        /// pending driver model is WDDM is not supported. See nvmlDeviceSetDriverModel. NVML_SUCCESS                 if \a mode has been set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a mode incorrect- NVML_ERROR_NOT_SUPPORTED     if the device does not support GOM or specific mode- NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceSetGpuOperationMode(nvmlDevice_st device, nvmlGom_enum mode);
        
        /// <summary>
        /// Changes the root/admin restructions on certain APIs. See @a nvmlRestrictedAPI_t for the list of supported APIs.
        /// This method can be used by a root/admin user to give non-root/admin access to certain otherwise-restricted APIs.
        /// The new setting lasts for the lifetime of the NVIDIA driver; it is not persistent. See @a nvmlDeviceGetAPIRestriction to query the current restriction settings.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="apiType">Target API type for this operation</param>
        /// <param name="isRestricted">The target restriction</param>
        /// <returns>-</returns>
        /// <seealso cref="nvmlRestrictedAPI_t"/>
        /// 
        /// <remarks>
        /// For Kepler 
        /// &amp;tm;
        /// or newer fully supported devices.
        /// Requires root/admin permissions. NVML_SUCCESS                 if \a isRestricted has been set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a apiType incorrect- NVML_ERROR_NOT_SUPPORTED     if the device does not support changing API restrictions or the device does not supportthe feature that api restrictions are being set for (E.G. Enabling/disabling auto 
        /// boosted clocks is not supported by the device)
        /// - NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceSetAPIRestriction(nvmlDevice_st device, nvmlRestrictedAPI_enum apiType, nvmlEnableState_enum isRestricted);
        
        /// <summary>
        /// Enables or disables per process accounting.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="mode">The target accounting mode</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For Kepler 
        /// &amp;tm;
        /// or newer fully supported devices.
        /// Requires root/admin permissions.@note This setting is not persistent and will default to disabled after driver unloads.
        /// Enable persistence mode to be sure the setting doesn't switch off to disabled.@note Enabling accounting mode has no negative impact on the GPU performance.@note Disabling accounting clears all accounting pids information.See nvmlDeviceGetAccountingModeSee nvmlDeviceGetAccountingStatsSee nvmlDeviceClearAccountingPids NVML_SUCCESS                 if the new mode has been set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device or \a mode are invalid- NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature- NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceSetAccountingMode(nvmlDevice_st device, nvmlEnableState_enum mode);
        
        /// <summary>
        /// Clears accounting information about all processes that have already terminated.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For Kepler 
        /// &amp;tm;
        /// or newer fully supported devices.
        /// Requires root/admin permissions.See nvmlDeviceGetAccountingModeSee nvmlDeviceGetAccountingStatsSee nvmlDeviceSetAccountingMode NVML_SUCCESS                 if accounting information has been cleared- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device are invalid- NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature- NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceClearAccountingPids(nvmlDevice_st device);
        
        /// <summary>
        /// Retrieves the state of the device's NvLink for the link specified
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="link">Specifies the NvLink link to be queried</param>
        /// <param name="isActive">@a nvmlEnableState_t where NVML_FEATURE_ENABLED indicates that
        /// the link is active and NVML_FEATURE_DISABLED indicates it 
        /// is inactive</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For Pascal 
        /// &amp;tm;
        /// or newer fully supported devices. NVML_SUCCESS                 if \a isActive has been set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device or \a link is invalid or \a isActive is NULL- NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetNvLinkState(nvmlDevice_st device, uint link, ref nvmlEnableState_enum isActive);
        
        /// <summary>
        /// Retrieves the version of the device's NvLink for the link specified
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="link">Specifies the NvLink link to be queried</param>
        /// <param name="version">Requested NvLink version</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For Pascal 
        /// &amp;tm;
        /// or newer fully supported devices. NVML_SUCCESS                 if \a version has been set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device or \a link is invalid or \a version is NULL- NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetNvLinkVersion(nvmlDevice_st device, uint link, ref uint version);
        
        /// <summary>
        /// Retrieves the requested capability from the device's NvLink for the link specified
        /// Please refer to the @a nvmlNvLinkCapability_t structure for the specific caps that can be queried
        /// The return value should be treated as a boolean.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="link">Specifies the NvLink link to be queried</param>
        /// <param name="capability">Specifies the @a nvmlNvLinkCapability_t to be queried</param>
        /// <param name="capResult">A boolean for the queried capability indicating that feature is available</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For Pascal 
        /// &amp;tm;
        /// or newer fully supported devices. NVML_SUCCESS                 if \a capResult has been set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device, \a link, or \a capability is invalid or \a capResult is NULL- NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetNvLinkCapability(nvmlDevice_st device, uint link, nvmlNvLinkCapability_enum capability, ref uint capResult);
        
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetNvLinkRemotePciInfo_v2(nvmlDevice_st device, uint link, ref nvmlPciInfo_st pci);
        
        /// <summary>
        /// Retrieves the specified error counter value
        /// Please refer to @a nvmlNvLinkErrorCounter_t for error counters that are available
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="link">Specifies the NvLink link to be queried</param>
        /// <param name="counter">Specifies the NvLink counter to be queried</param>
        /// <param name="counterValue">Returned counter value</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For Pascal 
        /// &amp;tm;
        /// or newer fully supported devices. NVML_SUCCESS                 if \a counter has been set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device, \a link, or \a counter is invalid or \a counterValue is NULL- NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetNvLinkErrorCounter(nvmlDevice_st device, uint link, nvmlNvLinkErrorCounter_enum counter, ref ulong counterValue);
        
        /// <summary>
        /// Resets all error counters to zero
        /// Please refer to @a nvmlNvLinkErrorCounter_t for the list of error counters that are reset
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="link">Specifies the NvLink link to be queried</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For Pascal 
        /// &amp;tm;
        /// or newer fully supported devices. NVML_SUCCESS                 if the reset is successful- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device or \a link is invalid- NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceResetNvLinkErrorCounters(nvmlDevice_st device, uint link);
        
        /// <summary>
        /// Set the NVLINK utilization counter control information for the specified counter, 0 or 1.
        /// Please refer to @a nvmlNvLinkUtilizationControl_t for the structure definition.  Performs a reset
        /// of the counters if the reset parameter is non-zero.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="counter">Specifies the counter that should be set (0 or 1).</param>
        /// <param name="link">Specifies the NvLink link to be queried</param>
        /// <param name="control">A reference to the @a nvmlNvLinkUtilizationControl_t to set</param>
        /// <param name="reset">Resets the counters on set if non-zero</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For Pascal 
        /// &amp;tm;
        /// or newer fully supported devices. NVML_SUCCESS                 if the control has been set successfully- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device, \a counter, \a link, or \a control is invalid- NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceSetNvLinkUtilizationControl(nvmlDevice_st device, uint link, uint counter, ref nvmlNvLinkUtilizationControl_st control, uint reset);
        
        /// <summary>
        /// Get the NVLINK utilization counter control information for the specified counter, 0 or 1.
        /// Please refer to @a nvmlNvLinkUtilizationControl_t for the structure definition
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="counter">Specifies the counter that should be set (0 or 1).</param>
        /// <param name="link">Specifies the NvLink link to be queried</param>
        /// <param name="control">A reference to the @a nvmlNvLinkUtilizationControl_t to place information</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For Pascal 
        /// &amp;tm;
        /// or newer fully supported devices. NVML_SUCCESS                 if the control has been set successfully- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device, \a counter, \a link, or \a control is invalid- NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetNvLinkUtilizationControl(nvmlDevice_st device, uint link, uint counter, ref nvmlNvLinkUtilizationControl_st control);
        
        /// <summary>
        /// Retrieve the NVLINK utilization counter based on the current control for a specified counter.
        /// In general it is good practice to use @a nvmlDeviceSetNvLinkUtilizationControl before reading the utilization counters as they have no default state
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="link">Specifies the NvLink link to be queried</param>
        /// <param name="counter">Specifies the counter that should be read (0 or 1).</param>
        /// <param name="rxcounter">Receive counter return value</param>
        /// <param name="txcounter">Transmit counter return value</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For Pascal 
        /// &amp;tm;
        /// or newer fully supported devices. NVML_SUCCESS                 if \a rxcounter and \a txcounter have been successfully set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device, \a counter, or \a link is invalid or \a rxcounter or \a txcounter are NULL- NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetNvLinkUtilizationCounter(nvmlDevice_st device, uint link, uint counter, ref ulong rxcounter, ref ulong txcounter);
        
        /// <summary>
        /// Freeze the NVLINK utilization counters 
        /// Both the receive and transmit counters are operated on by this function
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="link">Specifies the NvLink link to be queried</param>
        /// <param name="counter">Specifies the counter that should be frozen (0 or 1).</param>
        /// <param name="freeze">NVML_FEATURE_ENABLED = freeze the receive and transmit counters
        /// NVML_FEATURE_DISABLED = unfreeze the receive and transmit counters</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For Pascal 
        /// &amp;tm;
        /// or newer fully supported devices. NVML_SUCCESS                 if counters were successfully frozen or unfrozen- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device, \a link, \a counter, or \a freeze is invalid- NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceFreezeNvLinkUtilizationCounter(nvmlDevice_st device, uint link, uint counter, nvmlEnableState_enum freeze);
        
        /// <summary>
        /// Reset the NVLINK utilization counters 
        /// Both the receive and transmit counters are operated on by this function
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="link">Specifies the NvLink link to be reset</param>
        /// <param name="counter">Specifies the counter that should be reset (0 or 1)</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For Pascal 
        /// &amp;tm;
        /// or newer fully supported devices. NVML_SUCCESS                 if counters were successfully reset- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device, \a link, or \a counter is invalid- NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceResetNvLinkUtilizationCounter(nvmlDevice_st device, uint link, uint counter);
        
        /// <summary>
        /// Create an empty set of events.
        /// Event set should be freed by
        /// </summary>
        /// <param name="set">Reference in which to return the event handle</param>
        /// <returns>-</returns>
        /// <seealso cref="nvmlEventSetFree"/>
        /// 
        /// <remarks>
        ///  nvmlEventSetFreeFor Fermi 
        /// &amp;tm;
        /// or newer fully supported devices. NVML_SUCCESS                 if the event has been set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a set is NULL- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlEventSetCreate(ref nvmlEventSet_st set);
        
        /// <summary>
        /// Starts recording of events on a specified devices and add the events to specified
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="eventTypes">Bitmask of</param>
        /// <param name="set">Set to which add new event types</param>
        /// <returns>-</returns>
        /// <seealso cref="nvmlEventType"/>
        /// 
        /// <seealso cref="nvmlDeviceGetSupportedEventTypes"/>
        /// 
        /// <seealso cref="nvmlEventSetWait"/>
        /// 
        /// <seealso cref="nvmlEventSetFree"/>
        /// 
        /// <remarks>
        ///  nvmlEventSet_tFor Fermi 
        /// &amp;tm;
        /// or newer fully supported devices.
        /// Ecc events are available only on ECC enabled devices (see nvmlDeviceGetTotalEccErrors)Power capping events are available only on Power Management enabled devices (see nvmlDeviceGetPowerManagementMode)For Linux only.@b IMPORTANT: Operations on @a set are not thread safeThis call starts recording of events on specific device.
        /// All events that occurred before this call are not recorded.
        /// Checking if some event occurred can be done with nvmlEventSetWaitIf function reports NVML_ERROR_UNKNOWN, event set is in undefined state and should be freed.
        /// If function reports NVML_ERROR_NOT_SUPPORTED, event set can still be used. None of the requested eventTypes
        /// are registered in that case. nvmlEventType to record NVML_SUCCESS                 if the event has been set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a eventTypes is invalid or \a set is NULL- NVML_ERROR_NOT_SUPPORTED     if the platform does not support this feature or some of requested event types- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceRegisterEvents(nvmlDevice_st device, ulong eventTypes, nvmlEventSet_st set);
        
        /// <summary>
        /// Returns information about events supported on device
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="eventTypes">Reference in which to return bitmask of supported events</param>
        /// <returns>-</returns>
        /// <seealso cref="nvmlEventType"/>
        /// 
        /// <seealso cref="nvmlDeviceRegisterEvents"/>
        /// 
        /// <remarks>
        /// For Fermi 
        /// &amp;tm;
        /// or newer fully supported devices.Events are not supported on Windows. So this function returns an empty mask in @a eventTypes on Windows. NVML_SUCCESS                 if the eventTypes has been set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a eventType is NULL- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetSupportedEventTypes(nvmlDevice_st device, ref ulong eventTypes);
        
        /// <summary>
        /// Waits on events and delivers events
        /// </summary>
        /// <param name="set">Reference to set of events to wait on</param>
        /// <param name="data">Reference in which to return event data</param>
        /// <param name="timeoutms">Maximum amount of wait time in milliseconds for registered event</param>
        /// <returns>-</returns>
        /// <seealso cref="nvmlEventType"/>
        /// 
        /// <seealso cref="nvmlDeviceRegisterEvents"/>
        /// 
        /// <remarks>
        /// For Fermi 
        /// &amp;tm;
        /// or newer fully supported devices.If some events are ready to be delivered at the time of the call, function returns immediately.
        /// If there are no events ready to be delivered, function sleeps till event arrives 
        /// but not longer than specified timeout. This function in certain conditions can return before
        /// specified timeout passes (e.g. when interrupt arrives)In case of xid error, the function returns the most recent xid error type seen by the system. If there are multiple
        /// xid errors generated before nvmlEventSetWait is invoked then the last seen xid error type is returned for all
        /// xid error events. NVML_SUCCESS                 if the data has been set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a data is NULL- NVML_ERROR_TIMEOUT           if no event arrived in specified timeout or interrupt arrived- NVML_ERROR_GPU_IS_LOST       if a GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlEventSetWait(nvmlEventSet_st set, ref nvmlEventData_st data, uint timeoutms);
        
        /// <summary>
        /// Releases events in the set
        /// </summary>
        /// <param name="set">Reference to events to be released</param>
        /// <returns>-</returns>
        /// <seealso cref="nvmlDeviceRegisterEvents"/>
        /// 
        /// <remarks>
        /// For Fermi 
        /// &amp;tm;
        /// or newer fully supported devices. NVML_SUCCESS                 if the event has been successfully released- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlEventSetFree(nvmlEventSet_st set);
        
        /// <summary>
        /// Modify the drain state of a GPU.  This method forces a GPU to no longer accept new incoming requests.
        /// Any new NVML process will no longer see this GPU.  Persistence mode for this GPU must be turned off before
        /// this call is made.
        /// Must be called as administrator.
        /// For Linux only.
        /// </summary>
        /// <param name="pciInfo">The PCI address of the GPU drain state to be modified</param>
        /// <param name="newState">The drain state that should be entered, see</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For Pascal 
        /// &amp;tm;
        /// or newer fully supported devices.
        /// Some Kepler devices supported. nvmlEnableState_t NVML_SUCCESS                 if counters were successfully reset- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a nvmlIndex or \a newState is invalid- NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature- NVML_ERROR_NO_PERMISSION     if the calling process has insufficient permissions to perform operation- NVML_ERROR_IN_USE            if the device has persistence mode turned on- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceModifyDrainState(ref nvmlPciInfo_st pciInfo, nvmlEnableState_enum newState);
        
        /// <summary>
        /// Query the drain state of a GPU.  This method is used to check if a GPU is in a currently draining
        /// state.
        /// For Linux only.
        /// </summary>
        /// <param name="pciInfo">The PCI address of the GPU drain state to be queried</param>
        /// <param name="currentState">The current drain state for this GPU, see</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For Pascal 
        /// &amp;tm;
        /// or newer fully supported devices.
        /// Some Kepler devices supported. nvmlEnableState_t NVML_SUCCESS                 if counters were successfully reset- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a nvmlIndex or \a currentState is invalid- NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceQueryDrainState(ref nvmlPciInfo_st pciInfo, ref nvmlEnableState_enum currentState);
        
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceRemoveGpu_v2(ref nvmlPciInfo_st pciInfo, nvmlDetachGpuState_enum gpuState, nvmlPcieLinkState_enum linkState);
        
        /// <summary>
        /// Request the OS and the NVIDIA kernel driver to rediscover a portion of the PCI subsystem looking for GPUs that
        /// were previously removed. The portion of the PCI tree can be narrowed by specifying a domain, bus, and device.  
        /// If all are zeroes then the entire PCI tree will be searched.  Please note that for long-running NVML processes
        /// the enumeration will change based on how many GPUs are discovered and where they are inserted in bus order.
        /// </summary>
        /// <param name="pciInfo">The PCI tree to be searched.  Only the domain, bus, and device
        /// fields are used in this call.</param>
        /// <returns>-</returns>
        /// <remarks>
        /// In addition, all newly discovered GPUs will be initialized and their ECC scrubbed which may take several seconds
        /// per GPU. Also, all device handles are no longer guaranteed to be valid post discovery.Must be run as administrator.
        /// For Linux only.For Pascal 
        /// &amp;tm;
        /// or newer fully supported devices.
        /// Some Kepler devices supported. NVML_SUCCESS                 if counters were successfully reset- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a pciInfo is invalid- NVML_ERROR_NOT_SUPPORTED     if the operating system does not support this feature- NVML_ERROR_OPERATING_SYSTEM  if the operating system is denying this feature- NVML_ERROR_NO_PERMISSION     if the calling process has insufficient permissions to perform operation- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceDiscoverGpus(ref nvmlPciInfo_st pciInfo);
        
        /// <summary>
        /// Request values for a list of fields for a device. This API allows multiple fields to be queried at once.
        /// If any of the underlying fieldIds are populated by the same driver call, the results for those field IDs
        /// will be populated from a single call rather than making a driver call for each fieldId.
        /// </summary>
        /// <param name="device">The device handle of the GPU to request field values for</param>
        /// <param name="valuesCount">Number of entries in values that should be retrieved</param>
        /// <param name="values">Array of @a valuesCount structures to hold field values.
        /// Each value's fieldId must be populated prior to this call</param>
        /// <returns>-</returns>
        /// <remarks>
        ///  NVML_SUCCESS                 if any values in \a values were populated. Note that you mustcheck the nvmlReturn field of each value for each individual
        /// status
        /// - NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid or \a values is NULL
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetFieldValues(nvmlDevice_st device, int valuesCount, ref nvmlFieldValue_st values);
        
        /// <summary>
        /// This method is used to get the virtualization mode corresponding to the GPU.
        /// </summary>
        /// <param name="device">Identifier of the target device</param>
        /// <param name="pVirtualMode">Reference to virtualization mode. One of NVML_GPU_VIRTUALIZATION_?</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For Kepler 
        /// &amp;tm;
        /// or newer fully supported devices. NVML_SUCCESS                  if \a pVirtualMode is fetched- NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT   if \a device is invalid or \a pVirtualMode is NULL- NVML_ERROR_GPU_IS_LOST        if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN            on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetVirtualizationMode(nvmlDevice_st device, ref nvmlGpuVirtualizationMode pVirtualMode);
        
        /// <summary>
        /// This method is used to set the virtualization mode corresponding to the GPU.
        /// </summary>
        /// <param name="device">Identifier of the target device</param>
        /// <param name="virtualMode">virtualization mode. One of NVML_GPU_VIRTUALIZATION_?</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For Kepler 
        /// &amp;tm;
        /// or newer fully supported devices. NVML_SUCCESS                  if \a pVirtualMode is set- NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT   if \a device is invalid or \a pVirtualMode is NULL- NVML_ERROR_GPU_IS_LOST        if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_NOT_SUPPORTED      if setting of virtualization mode is not supported.- NVML_ERROR_NO_PERMISSION      if setting of virtualization mode is not allowed for this client.
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceSetVirtualizationMode(nvmlDevice_st device, nvmlGpuVirtualizationMode virtualMode);
        
        /// <summary>
        /// Retrieve the supported vGPU types on a physical GPU (device).
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="vgpuCount">Pointer to caller-supplied array size, and returns number of vGPU types</param>
        /// <param name="vgpuTypeIds">Pointer to caller-supplied array in which to return list of vGPU types</param>
        /// <returns>-</returns>
        /// <remarks>
        /// An array of supported vGPU types for the physical GPU indicated by @a device is returned in the caller-supplied buffer
        /// pointed at by @a vgpuTypeIds. The element count of nvmlVgpuTypeId_t array is passed in @a vgpuCount, and @a vgpuCount is used to return the number of vGPU types written to the buffer.If the supplied buffer is not large enough to accomodate the vGPU type array, the function returns
        /// NVML_ERROR_INSUFFICIENT_SIZE, with the element count of nvmlVgpuTypeId_t array required in @a vgpuCount. To query the number of vGPU types supported for the GPU, call this function with *vgpuCount = 0.
        /// The code will return NVML_ERROR_INSUFFICIENT_SIZE, or NVML_SUCCESS if no vGPU types are supported. NVML_SUCCESS                      successful completion- NVML_ERROR_INSUFFICIENT_SIZE      \a vgpuTypeIds buffer is too small, array element count is returned in \a vgpuCount- NVML_ERROR_INVALID_ARGUMENT       if \a vgpuCount is NULL or \a device is invalid- NVML_ERROR_NOT_SUPPORTED          if vGPU is not supported by the device- NVML_ERROR_VGPU_ECC_NOT_SUPPORTED if ECC is enabled on the device- NVML_ERROR_UNKNOWN                on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetSupportedVgpus(nvmlDevice_st device, ref uint vgpuCount, ref uint vgpuTypeIds);
        
        /// <summary>
        /// Retrieve the currently creatable vGPU types on a physical GPU (device).
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="vgpuCount">Pointer to caller-supplied array size, and returns number of vGPU types</param>
        /// <param name="vgpuTypeIds">Pointer to caller-supplied array in which to return list of vGPU types</param>
        /// <returns>-</returns>
        /// <remarks>
        /// An array of creatable vGPU types for the physical GPU indicated by @a device is returned in the caller-supplied buffer
        /// pointed at by @a vgpuTypeIds. The element count of nvmlVgpuTypeId_t array is passed in @a vgpuCount, and @a vgpuCount is used to return the number of vGPU types written to the buffer.The creatable vGPU types for a device may differ over time, as there may be restrictions on what type of vGPU types
        /// can concurrently run on a device.  For example, if only one vGPU type is allowed at a time on a device, then the creatable
        /// list will be restricted to whatever vGPU type is already running on the device.If the supplied buffer is not large enough to accomodate the vGPU type array, the function returns
        /// NVML_ERROR_INSUFFICIENT_SIZE, with the element count of nvmlVgpuTypeId_t array required in @a vgpuCount. To query the number of vGPU types createable for the GPU, call this function with *vgpuCount = 0.
        /// The code will return NVML_ERROR_INSUFFICIENT_SIZE, or NVML_SUCCESS if no vGPU types are creatable. NVML_SUCCESS                      successful completion- NVML_ERROR_INSUFFICIENT_SIZE      \a vgpuTypeIds buffer is too small, array element count is returned in \a vgpuCount- NVML_ERROR_INVALID_ARGUMENT       if \a vgpuCount is NULL- NVML_ERROR_NOT_SUPPORTED          if vGPU is not supported by the device- NVML_ERROR_VGPU_ECC_NOT_SUPPORTED if ECC is enabled on the device- NVML_ERROR_UNKNOWN                on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetCreatableVgpus(nvmlDevice_st device, ref uint vgpuCount, ref uint vgpuTypeIds);
        
        /// <summary>
        /// Retrieve the class of a vGPU type. It will not exceed 64 characters in length (including the NUL terminator).
        /// See
        /// </summary>
        /// <param name="vgpuTypeId">Handle to vGPU type</param>
        /// <param name="vgpuTypeClass">Pointer to string array to return class in</param>
        /// <param name="size">Size of string</param>
        /// <returns>-</returns>
        /// <remarks>
        ///  nvmlConstants::NVML_DEVICE_NAME_BUFFER_SIZE.For Kepler 
        /// &amp;tm;
        /// or newer fully supported devices. NVML_SUCCESS                   successful completion- NVML_ERROR_INVALID_ARGUMENT    if \a vgpuTypeId is invalid, or \a vgpuTypeClass is NULL- NVML_ERROR_INSUFFICIENT_SIZE   if \a size is too small- NVML_ERROR_UNKNOWN             on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlVgpuTypeGetClass(uint vgpuTypeId, IntPtr vgpuTypeClass, ref uint size);
        
        /// <summary>
        /// Retrieve the vGPU type name.
        /// </summary>
        /// <param name="vgpuTypeId">Handle to vGPU type</param>
        /// <param name="vgpuTypeName">Pointer to buffer to return name</param>
        /// <param name="size">Size of buffer</param>
        /// <returns>-</returns>
        /// <remarks>
        /// The name is an alphanumeric string that denotes a particular vGPU, e.g. GRID M60-2Q. It will not
        /// exceed 64 characters in length (including the NUL terminator).  See
        ///  * nvmlConstants::NVML_DEVICE_NAME_BUFFER_SIZE.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param vgpuTypeId               Handle to vGPU type
        ///  * @param vgpuTypeName             Pointer to buffer to return name
        ///  * @param size                     Size of buffer
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 successful completion
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a vgpuTypeId is invalid, or \a name is NULL
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE if \a size is too small
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuTypeGetName(nvmlVgpuTypeId_t vgpuTypeId, char *vgpuTypeName, unsigned int *size);
        /// 
        /// /**
        ///  * Retrieve the device ID of a vGPU type.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param vgpuTypeId               Handle to vGPU type
        ///  * @param deviceID                 Device ID and vendor ID of the device contained in single 32 bit value
        ///  * @param subsystemID              Subsytem ID and subsytem vendor ID of the device contained in single 32 bit value
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 successful completion
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a vgpuTypeId is invalid, or \a deviceId or \a subsystemID are NULL
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuTypeGetDeviceID(nvmlVgpuTypeId_t vgpuTypeId, unsigned long long *deviceID, unsigned long long *subsystemID);
        /// 
        /// /**
        ///  * Retrieve the vGPU framebuffer size in bytes.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param vgpuTypeId               Handle to vGPU type
        ///  * @param fbSize                   Pointer to framebuffer size in bytes
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 successful completion
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a vgpuTypeId is invalid, or \a fbSize is NULL
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuTypeGetFramebufferSize(nvmlVgpuTypeId_t vgpuTypeId, unsigned long long *fbSize);
        /// 
        /// /**
        ///  * Retrieve count of vGPU's supported display heads.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param vgpuTypeId               Handle to vGPU type
        ///  * @param numDisplayHeads          Pointer to number of display heads
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 successful completion
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a vgpuTypeId is invalid, or \a numDisplayHeads is NULL
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuTypeGetNumDisplayHeads(nvmlVgpuTypeId_t vgpuTypeId, unsigned int *numDisplayHeads);
        /// 
        /// /**
        ///  * Retrieve vGPU display head's maximum supported resolution.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param vgpuTypeId               Handle to vGPU type
        ///  * @param displayIndex             Zero-based index of display head
        ///  * @param xdim                     Pointer to maximum number of pixels in X dimension
        ///  * @param ydim                     Pointer to maximum number of pixels in Y dimension
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 successful completion
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a vgpuTypeId is invalid, or \a xdim or \a ydim are NULL, or \a displayIndex
        ///  *                                             is out of range.
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuTypeGetResolution(nvmlVgpuTypeId_t vgpuTypeId, unsigned int displayIndex, unsigned int *xdim, unsigned int *ydim);
        /// 
        /// /**
        ///  * Retrieve license requirements for a vGPU type
        ///  *
        ///  * The license type and version required to run the specified vGPU type is returned as an alphanumeric string, in the form
        ///  * "&lt;license name&gt;,&lt;version&gt;", for example "GRID-Virtual-PC,2.0". If a vGPU is runnable with* more than one type of license,
        ///  * the licenses are delimited by a semicolon, for example "GRID-Virtual-PC,2.0;GRID-Virtual-WS,2.0;GRID-Virtual-WS-Ext,2.0".
        ///  *
        ///  * The total length of the returned string will not exceed 128 characters, including the NUL terminator.
        ///  * See \ref nvmlVgpuConstants::NVML_GRID_LICENSE_BUFFER_SIZE.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param vgpuTypeId               Handle to vGPU type
        ///  * @param vgpuTypeLicenseString    Pointer to buffer to return license info
        ///  * @param size                     Size of \a vgpuTypeLicenseString buffer
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 successful completion
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a vgpuTypeId is invalid, or \a vgpuTypeLicenseString is NULL
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE if \a size is too small
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuTypeGetLicense(nvmlVgpuTypeId_t vgpuTypeId, char *vgpuTypeLicenseString, unsigned int size);
        /// 
        /// /**
        ///  * Retrieve the static frame rate limit value of the vGPU type
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param vgpuTypeId               Handle to vGPU type
        ///  * @param frameRateLimit           Reference to return the frame rate limit value
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 successful completion
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if frame rate limiter is turned off for the vGPU type
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a vgpuTypeId is invalid, or \a frameRateLimit is NULL
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuTypeGetFrameRateLimit(nvmlVgpuTypeId_t vgpuTypeId, unsigned int *frameRateLimit);
        /// 
        /// /**
        ///  * Retrieve the maximum number of vGPU instances creatable on a device for given vGPU type
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                   The identifier of the target device
        ///  * @param vgpuTypeId               Handle to vGPU type
        ///  * @param vgpuInstanceCount        Pointer to get the max number of vGPU instances
        ///  *                                 that can be created on a deicve for given vgpuTypeId
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 successful completion
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a vgpuTypeId is invalid or is not supported on target device,
        ///  *                                             or \a vgpuInstanceCount is NULL
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuTypeGetMaxInstances(nvmlDevice_t device, nvmlVgpuTypeId_t vgpuTypeId, unsigned int *vgpuInstanceCount);
        /// 
        /// /**
        ///  * Retrieve the maximum number of vGPU instances supported per VM for given vGPU type
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param vgpuTypeId               Handle to vGPU type
        ///  * @param vgpuInstanceCountPerVm   Pointer to get the max number of vGPU instances supported per VM for given \a vgpuTypeId
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 successful completion
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a vgpuTypeId is invalid, or \a vgpuInstanceCountPerVm is NULL
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuTypeGetMaxInstancesPerVm(nvmlVgpuTypeId_t vgpuTypeId, unsigned int *vgpuInstanceCountPerVm);
        /// 
        /// /**
        ///  * Retrieve the active vGPU instances on a device.
        ///  *
        ///  * An array of active vGPU instances is returned in the caller-supplied buffer pointed at by \a vgpuInstances. The
        ///  * array elememt count is passed in \a vgpuCount, and \a vgpuCount is used to return the number of vGPU instances
        ///  * written to the buffer.
        ///  *
        ///  * If the supplied buffer is not large enough to accomodate the vGPU instance array, the function returns
        ///  * NVML_ERROR_INSUFFICIENT_SIZE, with the element count of nvmlVgpuInstance_t array required in \a vgpuCount.
        ///  * To query the number of active vGPU instances, call this function with *vgpuCount = 0.  The code will return
        ///  * NVML_ERROR_INSUFFICIENT_SIZE, or NVML_SUCCESS if no vGPU Types are supported.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param device                   The identifier of the target device
        ///  * @param vgpuCount                Pointer which passes in the array size as well as get
        ///  *                                 back the number of types
        ///  * @param vgpuInstances            Pointer to array in which to return list of vGPU instances
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                  successful completion
        ///  *         - \ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT   if \a device is invalid, or \a vgpuCount is NULL
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE  if \a size is too small
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED      if vGPU is not supported by the device
        ///  *         - \ref NVML_ERROR_UNKNOWN            on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetActiveVgpus(nvmlDevice_t device, unsigned int *vgpuCount, nvmlVgpuInstance_t *vgpuInstances);
        /// 
        /// /**
        ///  * Retrieve the VM ID associated with a vGPU instance.
        ///  *
        ///  * The VM ID is returned as a string, not exceeding 80 characters in length (including the NUL terminator).
        ///  * See \ref nvmlConstants::NVML_DEVICE_UUID_BUFFER_SIZE.
        ///  *
        ///  * The format of the VM ID varies by platform, and is indicated by the type identifier returned in \a vmIdType.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param vgpuInstance             Identifier of the target vGPU instance
        ///  * @param vmId                     Pointer to caller-supplied buffer to hold VM ID
        ///  * @param size                     Size of buffer in bytes
        ///  * @param vmIdType                 Pointer to hold VM ID type
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 successful completion
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a vmId or \a vmIdType is NULL, or \a vgpuInstance is 0
        ///  *         - \ref NVML_ERROR_NOT_FOUND         if \a vgpuInstance does not match a valid active vGPU instance on the system
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE if \a size is too small
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuInstanceGetVmID(nvmlVgpuInstance_t vgpuInstance, char *vmId, unsigned int size, nvmlVgpuVmIdType_t *vmIdType);
        /// 
        /// /**
        ///  * Retrieve the UUID of a vGPU instance.
        ///  *
        ///  * The UUID is a globally unique identifier associated with the vGPU, and is returned as a 5-part hexadecimal string,
        ///  * not exceeding 80 characters in length (including the NULL terminator).
        ///  * See \ref nvmlConstants::NVML_DEVICE_UUID_BUFFER_SIZE.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param vgpuInstance             Identifier of the target vGPU instance
        ///  * @param uuid                     Pointer to caller-supplied buffer to hold vGPU UUID
        ///  * @param size                     Size of buffer in bytes
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 successful completion
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a vgpuInstance is 0, or \a uuid is NULL
        ///  *         - \ref NVML_ERROR_NOT_FOUND         if \a vgpuInstance does not match a valid active vGPU instance on the system
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE if \a size is too small
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuInstanceGetUUID(nvmlVgpuInstance_t vgpuInstance, char *uuid, unsigned int size);
        /// 
        /// /**
        ///  * Retrieve the NVIDIA driver version installed in the VM associated with a vGPU.
        ///  *
        ///  * The version is returned as an alphanumeric string in the caller-supplied buffer \a version. The length of the version
        ///  * string will not exceed 80 characters in length (including the NUL terminator).
        ///  * See \ref nvmlConstants::NVML_SYSTEM_DRIVER_VERSION_BUFFER_SIZE.
        ///  *
        ///  * nvmlVgpuInstanceGetVmDriverVersion() may be called at any time for a vGPU instance. The guest VM driver version is
        ///  * returned as "Unknown" if no NVIDIA driver is installed in the VM, or the VM has not yet booted to the point where the
        ///  * NVIDIA driver is loaded and initialized.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param vgpuInstance             Identifier of the target vGPU instance
        ///  * @param version                  Caller-supplied buffer to return driver version string
        ///  * @param length                   Size of \a version buffer
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if \a version has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a vgpuInstance is 0
        ///  *         - \ref NVML_ERROR_NOT_FOUND         if \a vgpuInstance does not match a valid active vGPU instance on the system
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE if \a length is too small
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuInstanceGetVmDriverVersion(nvmlVgpuInstance_t vgpuInstance, char* version, unsigned int length);
        /// 
        /// /**
        ///  * Retrieve the framebuffer usage in bytes.
        ///  *
        ///  * Framebuffer usage is the amont of vGPU framebuffer memory that is currently in use by the VM.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param vgpuInstance             The identifier of the target instance
        ///  * @param fbUsage                  Pointer to framebuffer usage in bytes
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 successful completion
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a vgpuInstance is 0, or \a fbUsage is NULL
        ///  *         - \ref NVML_ERROR_NOT_FOUND         if \a vgpuInstance does not match a valid active vGPU instance on the system
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuInstanceGetFbUsage(nvmlVgpuInstance_t vgpuInstance, unsigned long long *fbUsage);
        /// 
        /// /**
        ///  * Retrieve the current licensing state of the vGPU instance.
        ///  *
        ///  * If the vGPU is currently licensed, \a licensed is set to 1, otherwise it is set to 0.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param vgpuInstance             Identifier of the target vGPU instance
        ///  * @param licensed                 Reference to return the licensing status
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if \a licensed has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a vgpuInstance is 0, or \a licensed is NULL
        ///  *         - \ref NVML_ERROR_NOT_FOUND         if \a vgpuInstance does not match a valid active vGPU instance on the system
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuInstanceGetLicenseStatus(nvmlVgpuInstance_t vgpuInstance, unsigned int *licensed);
        /// 
        /// /**
        ///  * Retrieve the vGPU type of a vGPU instance.
        ///  *
        ///  * Returns the vGPU type ID of vgpu assigned to the vGPU instance.
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param vgpuInstance             Identifier of the target vGPU instance
        ///  * @param vgpuTypeId               Reference to return the vgpuTypeId
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if \a vgpuTypeId has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a vgpuInstance is 0, or \a vgpuTypeId is NULL
        ///  *         - \ref NVML_ERROR_NOT_FOUND         if \a vgpuInstance does not match a valid active vGPU instance on the system
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuInstanceGetType(nvmlVgpuInstance_t vgpuInstance, nvmlVgpuTypeId_t *vgpuTypeId);
        /// 
        /// /**
        ///  * Retrieve the frame rate limit set for the vGPU instance.
        ///  *
        ///  * Returns the value of the frame rate limit set for the vGPU instance
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param vgpuInstance             Identifier of the target vGPU instance
        ///  * @param frameRateLimit           Reference to return the frame rate limit
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if \a frameRateLimit has been set
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if frame rate limiter is turned off for the vGPU type
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a vgpuInstance is 0, or \a frameRateLimit is NULL
        ///  *         - \ref NVML_ERROR_NOT_FOUND         if \a vgpuInstance does not match a valid active vGPU instance on the system
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuInstanceGetFrameRateLimit(nvmlVgpuInstance_t vgpuInstance, unsigned int *frameRateLimit);
        /// 
        /// /**
        ///  * Retrieve the encoder capacity of a vGPU instance, as a percentage of maximum encoder capacity with valid values in the range 0-100.
        ///  *
        ///  * For Maxwell &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param vgpuInstance             Identifier of the target vGPU instance
        ///  * @param encoderCapacity          Reference to an unsigned int for the encoder capacity
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if \a encoderCapacity has been retrived
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a vgpuInstance is 0, or \a encoderQueryType is invalid
        ///  *         - \ref NVML_ERROR_NOT_FOUND         if \a vgpuInstance does not match a valid active vGPU instance on the system
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuInstanceGetEncoderCapacity(nvmlVgpuInstance_t vgpuInstance, unsigned int *encoderCapacity);
        /// 
        /// /**
        ///  * Set the encoder capacity of a vGPU instance, as a percentage of maximum encoder capacity with valid values in the range 0-100.
        ///  *
        ///  * For Maxwell &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param vgpuInstance             Identifier of the target vGPU instance
        ///  * @param encoderCapacity          Unsigned int for the encoder capacity value
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if \a encoderCapacity has been set
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a vgpuInstance is 0, or \a encoderCapacity is out of range of 0-100.
        ///  *         - \ref NVML_ERROR_NOT_FOUND         if \a vgpuInstance does not match a valid active vGPU instance on the system
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuInstanceSetEncoderCapacity(nvmlVgpuInstance_t vgpuInstance, unsigned int  encoderCapacity);
        /// 
        /// /**
        ///  * Retrieves current utilization for vGPUs on a physical GPU (device).
        ///  *
        ///  * For Kepler &amp;tm; or newer fully supported devices.
        ///  *
        ///  * Reads recent utilization of GPU SM (3D/Compute), framebuffer, video encoder, and video decoder for vGPU instances running
        ///  * on a device. Utilization values are returned as an array of utilization sample structures in the caller-supplied buffer
        ///  * pointed at by \a utilizationSamples. One utilization sample structure is returned per vGPU instance, and includes the
        ///  * CPU timestamp at which the samples were recorded. Individual utilization values are returned as "unsigned int" values
        ///  * in nvmlValue_t unions. The function sets the caller-supplied \a sampleValType to NVML_VALUE_TYPE_UNSIGNED_INT to
        ///  * indicate the returned value type.
        ///  *
        ///  * To read utilization values, first determine the size of buffer required to hold the samples by invoking the function with
        ///  * \a utilizationSamples set to NULL. The function will return NVML_ERROR_INSUFFICIENT_SIZE, with the current vGPU instance
        ///  * count in \a vgpuInstanceSamplesCount, or NVML_SUCCESS if the current vGPU instance count is zero. The caller should allocate
        ///  * a buffer of size vgpuInstanceSamplesCount * sizeof(nvmlVgpuInstanceUtilizationSample_t). Invoke the function again with
        ///  * the allocated buffer passed in \a utilizationSamples, and \a vgpuInstanceSamplesCount set to the number of entries the
        ///  * buffer is sized for.
        ///  *
        ///  * On successful return, the function updates \a vgpuInstanceSampleCount with the number of vGPU utilization sample
        ///  * structures that were actually written. This may differ from a previously read value as vGPU instances are created or
        ///  * destroyed.
        ///  *
        ///  * lastSeenTimeStamp represents the CPU timestamp in microseconds at which utilization samples were last read. Set it to 0
        ///  * to read utilization based on all the samples maintained by the driver's internal sample buffer. Set lastSeenTimeStamp
        ///  * to a timeStamp retrieved from a previous query to read utilization since the previous query.
        ///  *
        ///  * @param device                        The identifier for the target device
        ///  * @param lastSeenTimeStamp             Return only samples with timestamp greater than lastSeenTimeStamp.
        ///  * @param sampleValType                 Pointer to caller-supplied buffer to hold the type of returned sample values
        ///  * @param vgpuInstanceSamplesCount      Pointer to caller-supplied array size, and returns number of vGPU instances
        ///  * @param utilizationSamples            Pointer to caller-supplied buffer in which vGPU utilization samples are returned
        /// 
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if utilization samples are successfully retrieved
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, \a vgpuInstanceSamplesCount or \a sampleValType is
        ///  *                                             NULL, or a sample count of 0 is passed with a non-NULL \a utilizationSamples
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE if supplied \a vgpuInstanceSamplesCount is too small to return samples for all
        ///  *                                             vGPU instances currently executing on the device
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if vGPU is not supported by the device
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_NOT_FOUND         if sample entries are not found
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetVgpuUtilization(nvmlDevice_t device, unsigned long long lastSeenTimeStamp,
        ///                                                   nvmlValueType_t *sampleValType, unsigned int *vgpuInstanceSamplesCount,
        ///                                                   nvmlVgpuInstanceUtilizationSample_t *utilizationSamples);
        /// 
        /// /**
        ///  * Retrieves current utilization for processes running on vGPUs on a physical GPU (device).
        ///  *
        ///  * For Maxwell &amp;tm; or newer fully supported devices.
        ///  *
        ///  * Reads recent utilization of GPU SM (3D/Compute), framebuffer, video encoder, and video decoder for processes running on
        ///  * vGPU instances active on a device. Utilization values are returned as an array of utilization sample structures in the
        ///  * caller-supplied buffer pointed at by \a utilizationSamples. One utilization sample structure is returned per process running
        ///  * on vGPU instances, that had some non-zero utilization during the last sample period. It includes the CPU timestamp at which
        ///  * the samples were recorded. Individual utilization values are returned as "unsigned int" values.
        ///  *
        ///  * To read utilization values, first determine the size of buffer required to hold the samples by invoking the function with
        ///  * \a utilizationSamples set to NULL. The function will return NVML_ERROR_INSUFFICIENT_SIZE, with the current vGPU instance
        ///  * count in \a vgpuProcessSamplesCount. The caller should allocate a buffer of size
        ///  * vgpuProcessSamplesCount * sizeof(nvmlVgpuProcessUtilizationSample_t). Invoke the function again with
        ///  * the allocated buffer passed in \a utilizationSamples, and \a vgpuProcessSamplesCount set to the number of entries the
        ///  * buffer is sized for.
        ///  *
        ///  * On successful return, the function updates \a vgpuSubProcessSampleCount with the number of vGPU sub process utilization sample
        ///  * structures that were actually written. This may differ from a previously read value depending on the number of processes that are active
        ///  * in any given sample period.
        ///  *
        ///  * lastSeenTimeStamp represents the CPU timestamp in microseconds at which utilization samples were last read. Set it to 0
        ///  * to read utilization based on all the samples maintained by the driver's internal sample buffer. Set lastSeenTimeStamp
        ///  * to a timeStamp retrieved from a previous query to read utilization since the previous query.
        ///  *
        ///  * @param device                        The identifier for the target device
        ///  * @param lastSeenTimeStamp             Return only samples with timestamp greater than lastSeenTimeStamp.
        ///  * @param vgpuProcessSamplesCount       Pointer to caller-supplied array size, and returns number of processes running on vGPU instances
        ///  * @param utilizationSamples            Pointer to caller-supplied buffer in which vGPU sub process utilization samples are returned
        /// 
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if utilization samples are successfully retrieved
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, \a vgpuProcessSamplesCount or a sample count of 0 is
        ///  *                                             passed with a non-NULL \a utilizationSamples
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE if supplied \a vgpuProcessSamplesCount is too small to return samples for all
        ///  *                                             vGPU instances currently executing on the device
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if vGPU is not supported by the device
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_NOT_FOUND         if sample entries are not found
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetVgpuProcessUtilization(nvmlDevice_t device, unsigned long long lastSeenTimeStamp,
        ///                                                          unsigned int *vgpuProcessSamplesCount,
        ///                                                          nvmlVgpuProcessUtilizationSample_t *utilizationSamples);
        /// /**
        ///  * Retrieve the GRID licensable features.
        ///  *
        ///  * Identifies whether the system supports GRID Software Licensing. If it does, return the list of licensable feature(s)
        ///  * and their current license status.
        ///  *
        ///  * @param device                    Identifier of the target device
        ///  * @param pGridLicensableFeatures   Pointer to structure in which GRID licensable features are returned
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if licensable features are successfully retrieved
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a pGridLicensableFeatures is NULL
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetGridLicensableFeatures(nvmlDevice_t device, nvmlGridLicensableFeatures_t *pGridLicensableFeatures);
        /// 
        /// /**
        ///  * Retrieves the current encoder statistics of a vGPU Instance
        ///  *
        ///  * For Maxwell &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param vgpuInstance                      Identifier of the target vGPU instance
        ///  * @param sessionCount                      Reference to an unsigned int for count of active encoder sessions
        ///  * @param averageFps                        Reference to an unsigned int for trailing average FPS of all active sessions
        ///  * @param averageLatency                    Reference to an unsigned int for encode latency in microseconds
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                  if \a sessionCount, \a averageFps and \a averageLatency is fetched
        ///  *         - \ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT   if \a sessionCount , or \a averageFps or \a averageLatency is NULL
        ///  *                                              or \a vgpuInstance is 0.
        ///  *         - \ref NVML_ERROR_NOT_FOUND          if \a vgpuInstance does not match a valid active vGPU instance on the system
        ///  *         - \ref NVML_ERROR_UNKNOWN            on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuInstanceGetEncoderStats(nvmlVgpuInstance_t vgpuInstance, unsigned int *sessionCount,
        ///                                                      unsigned int *averageFps, unsigned int *averageLatency);
        /// 
        /// /**
        ///  * Retrieves information about all active encoder sessions on a vGPU Instance.
        ///  *
        ///  * An array of active encoder sessions is returned in the caller-supplied buffer pointed at by \a sessionInfo. The
        ///  * array element count is passed in \a sessionCount, and \a sessionCount is used to return the number of sessions
        ///  * written to the buffer.
        ///  *
        ///  * If the supplied buffer is not large enough to accomodate the active session array, the function returns
        ///  * NVML_ERROR_INSUFFICIENT_SIZE, with the element count of nvmlEncoderSessionInfo_t array required in \a sessionCount.
        ///  * To query the number of active encoder sessions, call this function with *sessionCount = 0. The code will return
        ///  * NVML_SUCCESS with number of active encoder sessions updated in *sessionCount.
        ///  *
        ///  * For Maxwell &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param vgpuInstance                      Identifier of the target vGPU instance
        ///  * @param sessionCount                      Reference to caller supplied array size, and returns
        ///  *                                          the number of sessions.
        ///  * @param sessionInfo                       Reference to caller supplied array in which the list
        ///  *                                          of session information us returned.
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                  if \a sessionInfo is fetched
        ///  *         - \ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE  if \a sessionCount is too small, array element count is
        ///                                                 returned in \a sessionCount
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT   if \a sessionCount is NULL, or \a vgpuInstance is 0.
        ///  *         - \ref NVML_ERROR_NOT_FOUND          if \a vgpuInstance does not match a valid active vGPU instance on the system
        ///  *         - \ref NVML_ERROR_UNKNOWN            on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuInstanceGetEncoderSessions(nvmlVgpuInstance_t vgpuInstance, unsigned int *sessionCount, nvmlEncoderSessionInfo_t *sessionInfo);
        /// 
        /// /**
        /// * Retrieves the active frame buffer capture sessions statistics of a vGPU Instance
        /// *
        /// * For Maxwell &amp;tm; or newer fully supported devices.
        /// *
        /// * @param vgpuInstance                      Identifier of the target vGPU instance
        /// * @param fbcStats                          Reference to nvmlFBCStats_t structure contianing NvFBC stats
        /// *
        /// * @return
        /// *         - \ref NVML_SUCCESS                  if \a fbcStats is fetched
        /// *         - \ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized
        /// *         - \ref NVML_ERROR_INVALID_ARGUMENT   if \a vgpuInstance is 0, or \a fbcStats is NULL
        /// *         - \ref NVML_ERROR_NOT_FOUND          if \a vgpuInstance does not match a valid active vGPU instance on the system
        /// *         - \ref NVML_ERROR_UNKNOWN            on any unexpected error
        /// */
        /// nvmlReturn_t DECLDIR nvmlVgpuInstanceGetFBCStats(nvmlVgpuInstance_t vgpuInstance, nvmlFBCStats_t *fbcStats);
        /// 
        /// /**
        /// * Retrieves information about active frame buffer capture sessions on a vGPU Instance.
        /// *
        /// * An array of active FBC sessions is returned in the caller-supplied buffer pointed at by \a sessionInfo. The
        /// * array element count is passed in \a sessionCount, and \a sessionCount is used to return the number of sessions
        /// * written to the buffer.
        /// *
        /// * If the supplied buffer is not large enough to accomodate the active session array, the function returns
        /// * NVML_ERROR_INSUFFICIENT_SIZE, with the element count of nvmlFBCSessionInfo_t array required in \a sessionCount.
        /// * To query the number of active FBC sessions, call this function with *sessionCount = 0.  The code will return
        /// * NVML_SUCCESS with number of active FBC sessions updated in *sessionCount.
        /// *
        /// * For Maxwell &amp;tm; or newer fully supported devices.
        /// *
        /// * @note hResolution, vResolution, averageFPS and averageLatency data for a FBC session returned in \a sessionInfo may
        /// *       be zero if there are no new frames captured since the session started.
        /// *
        /// * @param vgpuInstance                      Identifier of the target vGPU instance
        /// * @param sessionCount                      Reference to caller supplied array size, and returns the number of sessions.
        /// * @param sessionInfo                       Reference in which to return the session information
        /// *
        /// * @return
        /// *         - \ref NVML_SUCCESS                  if \a sessionInfo is fetched
        /// *         - \ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized
        /// *         - \ref NVML_ERROR_INVALID_ARGUMENT   if \a vgpuInstance is 0, or \a sessionCount is NULL.
        /// *         - \ref NVML_ERROR_NOT_FOUND          if \a vgpuInstance does not match a valid active vGPU instance on the system
        /// *         - \ref NVML_ERROR_INSUFFICIENT_SIZE  if \a sessionCount is too small, array element count is returned in \a sessionCount
        /// *         - \ref NVML_ERROR_UNKNOWN            on any unexpected error
        /// */
        /// nvmlReturn_t DECLDIR nvmlVgpuInstanceGetFBCSessions(nvmlVgpuInstance_t vgpuInstance, unsigned int *sessionCount, nvmlFBCSessionInfo_t *sessionInfo);
        /// 
        /// /**
        ///  * Retrieves the current utilization and process ID
        ///  *
        ///  * For Maxwell &amp;tm; or newer fully supported devices.
        ///  *
        ///  * Reads recent utilization of GPU SM (3D/Compute), framebuffer, video encoder, and video decoder for processes running.
        ///  * Utilization values are returned as an array of utilization sample structures in the caller-supplied buffer pointed at
        ///  * by \a utilization. One utilization sample structure is returned per process running, that had some non-zero utilization
        ///  * during the last sample period. It includes the CPU timestamp at which  the samples were recorded. Individual utilization values
        ///  * are returned as "unsigned int" values.
        ///  *
        ///  * To read utilization values, first determine the size of buffer required to hold the samples by invoking the function with
        ///  * \a utilization set to NULL. The caller should allocate a buffer of size
        ///  * processSamplesCount * sizeof(nvmlProcessUtilizationSample_t). Invoke the function again with the allocated buffer passed
        ///  * in \a utilization, and \a processSamplesCount set to the number of entries the buffer is sized for.
        ///  *
        ///  * On successful return, the function updates \a processSamplesCount with the number of process utilization sample
        ///  * structures that were actually written. This may differ from a previously read value as instances are created or
        ///  * destroyed.
        ///  *
        ///  * lastSeenTimeStamp represents the CPU timestamp in microseconds at which utilization samples were last read. Set it to 0
        ///  * to read utilization based on all the samples maintained by the driver's internal sample buffer. Set lastSeenTimeStamp
        ///  * to a timeStamp retrieved from a previous query to read utilization since the previous query.
        ///  *
        ///  * @param device                    The identifier of the target device
        ///  * @param utilization               Pointer to caller-supplied buffer in which guest process utilization samples are returned
        ///  * @param processSamplesCount       Pointer to caller-supplied array size, and returns number of processes running
        ///  * @param lastSeenTimeStamp         Return only samples with timestamp greater than lastSeenTimeStamp.
        /// 
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                 if \a utilization has been populated
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, \a utilization is NULL, or \a samplingPeriodUs is NULL
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature
        ///  *         - \ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetProcessUtilization(nvmlDevice_t device, nvmlProcessUtilizationSample_t *utilization,
        ///                                               unsigned int *processSamplesCount, unsigned long long lastSeenTimeStamp);
        /// 
        /// /**
        ///  * Queries the state of per process accounting mode on vGPU.
        ///  *
        ///  * For Maxwell &amp;tm; or newer fully supported devices.
        ///  *
        ///  * @param vgpuInstance            The identifier of the target vGPU VM
        ///  * @param mode                    Reference in which to return the current accounting mode
        ///  *
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if the mode has been successfully retrieved 
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a vgpuInstance is 0, or \a mode is NULL
        ///  *         - \ref NVML_ERROR_NOT_FOUND         if \a vgpuInstance does not match a valid active vGPU instance on the system
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the vGPU doesn't support this feature
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuInstanceGetAccountingMode(nvmlVgpuInstance_t vgpuInstance, nvmlEnableState_t *mode);
        /// 
        /// /**
        ///  * Queries list of processes running on vGPU that can be queried for accounting stats. The list of processes 
        ///  * returned can be in running or terminated state.
        ///  *
        ///  * For Maxwell &amp;tm; or newer fully supported devices.
        ///  * 
        ///  * To just query the maximum number of processes that can be queried, call this function with *count = 0 and
        ///  * pids=NULL. The return code will be NVML_ERROR_INSUFFICIENT_SIZE, or NVML_SUCCESS if list is empty.
        ///  * 
        ///  * For more details see \ref nvmlVgpuInstanceGetAccountingStats.
        ///  *
        ///  * @note In case of PID collision some processes might not be accessible before the circular buffer is full.
        ///  *
        ///  * @param vgpuInstance            The identifier of the target vGPU VM
        ///  * @param count                   Reference in which to provide the \a pids array size, and
        ///  *                                to return the number of elements ready to be queried
        ///  * @param pids                    Reference in which to return list of process ids
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if pids were successfully retrieved
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a vgpuInstance is 0, or \a count is NULL
        ///  *         - \ref NVML_ERROR_NOT_FOUND         if \a vgpuInstance does not match a valid active vGPU instance on the system
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the vGPU doesn't support this feature or accounting mode is disabled
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE if \a count is too small (\a count is set to expected value)
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  *
        ///  * @see nvmlVgpuInstanceGetAccountingPids
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuInstanceGetAccountingPids(nvmlVgpuInstance_t vgpuInstance, unsigned int *count, unsigned int *pids);
        /// 
        /// /**
        ///  * Queries process's accounting stats.
        ///  *
        ///  * For Maxwell &amp;tm; or newer fully supported devices.
        ///  * 
        ///  * Accounting stats capture GPU utilization and other statistics across the lifetime of a process, and
        ///  * can be queried during life time of the process or after its termination.
        ///  * The time field in \ref nvmlAccountingStats_t is reported as 0 during the lifetime of the process and 
        ///  * updated to actual running time after its termination.
        ///  * Accounting stats are kept in a circular buffer, newly created processes overwrite information about old
        ///  * processes.
        ///  *
        ///  * See \ref nvmlAccountingStats_t for description of each returned metric.
        ///  * List of processes that can be queried can be retrieved from \ref nvmlVgpuInstanceGetAccountingPids.
        ///  *
        ///  * @note Accounting Mode needs to be on. See \ref nvmlVgpuInstanceGetAccountingMode.
        ///  * @note Only compute and graphics applications stats can be queried. Monitoring applications stats can't be
        ///  *         queried since they don't contribute to GPU utilization.
        ///  * @note In case of pid collision stats of only the latest process (that terminated last) will be reported
        ///  *
        ///  * @param vgpuInstance            The identifier of the target vGPU VM
        ///  * @param pid                     Process Id of the target process to query stats for
        ///  * @param stats                   Reference in which to return the process's accounting stats
        ///  *
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if stats have been successfully retrieved
        ///  *         - \ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a vgpuInstance is 0, or \a stats is NULL
        ///  *         - \ref NVML_ERROR_NOT_FOUND         if \a vgpuInstance does not match a valid active vGPU instance on the system
        ///  *                                             or \a stats is not found
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED     if the vGPU doesn't support this feature or accounting mode is disabled
        ///  *         - \ref NVML_ERROR_UNKNOWN           on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuInstanceGetAccountingStats(nvmlVgpuInstance_t vgpuInstance, unsigned int pid, nvmlAccountingStats_t *stats);
        /// 
        /// /** @} */
        /// 
        /// /***************************************************************************************************/
        /// /** @defgroup nvml vGPU Migration
        ///  * This chapter describes NVML operations that are associated with vGPU Migration.
        ///  *  @{
        ///  */
        /// /***************************************************************************************************/
        /// 
        /// /**
        ///  * Structure representing range of vGPU versions.
        ///  */
        /// typedef struct nvmlVgpuVersion_st
        /// {
        ///     unsigned int minVersion; //!&lt; Minimum vGPU version.
        ///     unsigned int maxVersion; //!&lt; Maximum vGPU version.
        /// } nvmlVgpuVersion_t;
        /// 
        /// /**
        ///  * vGPU metadata structure.
        ///  */
        /// typedef struct nvmlVgpuMetadata_st
        /// {
        ///     unsigned int             version;                                                    //!&lt; Current version of the structure
        ///     unsigned int             revision;                                                   //!&lt; Current revision of the structure
        ///     nvmlVgpuGuestInfoState_t guestInfoState;                                             //!&lt; Current state of Guest-dependent fields
        ///     char                     guestDriverVersion[NVML_SYSTEM_DRIVER_VERSION_BUFFER_SIZE]; //!&lt; Version of driver installed in guest
        ///     char                     hostDriverVersion[NVML_SYSTEM_DRIVER_VERSION_BUFFER_SIZE];  //!&lt; Version of driver installed in host
        ///     unsigned int             reserved[7];                                                //!&lt; Reserved for internal use
        ///     unsigned int             guestVgpuVersion;                                           //!&lt; vGPU version of guest driver
        ///     unsigned int             opaqueDataSize;                                             //!&lt; Size of opaque data field in bytes
        ///     char                     opaqueData[4];                                              //!&lt; Opaque data
        /// } nvmlVgpuMetadata_t;
        /// 
        /// /**
        ///  * Physical GPU metadata structure
        ///  */
        /// typedef struct nvmlVgpuPgpuMetadata_st
        /// {
        ///     unsigned int            version;                                                    //!&lt; Current version of the structure
        ///     unsigned int            revision;                                                   //!&lt; Current revision of the structure
        ///     char                    hostDriverVersion[NVML_SYSTEM_DRIVER_VERSION_BUFFER_SIZE];  //!&lt; Host driver version
        ///     unsigned int            pgpuVirtualizationCaps;                                     //!&lt; Pgpu virtualizaion capabilities bitfileld
        ///     unsigned int            reserved[5];                                                //!&lt; Reserved for internal use
        ///     nvmlVgpuVersion_t       hostSupportedVgpuRange;                                     //!&lt; vGPU version range supported by host driver
        ///     unsigned int            opaqueDataSize;                                             //!&lt; Size of opaque data field in bytes
        ///     char                    opaqueData[4];                                              //!&lt; Opaque data
        /// } nvmlVgpuPgpuMetadata_t;
        /// 
        /// /**
        ///  * vGPU VM compatibility codes
        ///  */
        /// typedef enum nvmlVgpuVmCompatibility_enum
        /// {
        ///     NVML_VGPU_VM_COMPATIBILITY_NONE         = 0x0,    //!&lt; vGPU is not runnable
        ///     NVML_VGPU_VM_COMPATIBILITY_COLD         = 0x1,    //!&lt; vGPU is runnable from a cold / powered-off state (ACPI S5)
        ///     NVML_VGPU_VM_COMPATIBILITY_HIBERNATE    = 0x2,    //!&lt; vGPU is runnable from a hibernated state (ACPI S4)
        ///     NVML_VGPU_VM_COMPATIBILITY_SLEEP        = 0x4,    //!&lt; vGPU is runnable from a sleeped state (ACPI S3)
        ///     NVML_VGPU_VM_COMPATIBILITY_LIVE         = 0x8,    //!&lt; vGPU is runnable from a live/paused (ACPI S0)
        /// } nvmlVgpuVmCompatibility_t;
        /// 
        /// /**
        ///  *  vGPU-pGPU compatibility limit codes
        ///  */
        /// typedef enum nvmlVgpuPgpuCompatibilityLimitCode_enum
        /// {
        ///     NVML_VGPU_COMPATIBILITY_LIMIT_NONE          = 0x0,           //!&lt; Compatibility is not limited.
        ///     NVML_VGPU_COMPATIBILITY_LIMIT_HOST_DRIVER   = 0x1,           //!&lt; ompatibility is limited by host driver version.
        ///     NVML_VGPU_COMPATIBILITY_LIMIT_GUEST_DRIVER  = 0x2,           //!&lt; Compatibility is limited by guest driver version.
        ///     NVML_VGPU_COMPATIBILITY_LIMIT_GPU           = 0x4,           //!&lt; Compatibility is limited by GPU hardware.
        ///     NVML_VGPU_COMPATIBILITY_LIMIT_OTHER         = 0x80000000,    //!&lt; Compatibility is limited by an undefined factor.
        /// } nvmlVgpuPgpuCompatibilityLimitCode_t;
        /// 
        /// /**
        ///  * vGPU-pGPU compatibility structure
        ///  */
        /// typedef struct nvmlVgpuPgpuCompatibility_st
        /// {
        ///     nvmlVgpuVmCompatibility_t               vgpuVmCompatibility;    //!&lt; Compatibility of vGPU VM. See \ref nvmlVgpuVmCompatibility_t
        ///     nvmlVgpuPgpuCompatibilityLimitCode_t    compatibilityLimitCode; //!&lt; Limiting factor for vGPU-pGPU compatibility. See \ref nvmlVgpuPgpuCompatibilityLimitCode_t
        /// } nvmlVgpuPgpuCompatibility_t;
        /// 
        /// /**
        ///  * Returns vGPU metadata structure for a running vGPU. The structure contains information about the vGPU and its associated VM
        ///  * such as the currently installed NVIDIA guest driver version, together with host driver version and an opaque data section
        ///  * containing internal state.
        ///  *
        ///  * nvmlVgpuInstanceGetMetadata() may be called at any time for a vGPU instance. Some fields in the returned structure are
        ///  * dependent on information obtained from the guest VM, which may not yet have reached a state where that information
        ///  * is available. The current state of these dependent fields is reflected in the info structure's \ref nvmlVgpuGuestInfoState_t field.
        ///  *
        ///  * The VMM may choose to read and save the vGPU's VM info as persistent metadata associated with the VM, and provide
        ///  * it to GRID Virtual GPU Manager when creating a vGPU for subsequent instances of the VM.
        ///  *
        ///  * The caller passes in a buffer via \a vgpuMetadata, with the size of the buffer in \a bufferSize. If the vGPU Metadata structure
        ///  * is too large to fit in the supplied buffer, the function returns NVML_ERROR_INSUFFICIENT_SIZE with the size needed
        ///  * in \a bufferSize.
        ///  *
        ///  * @param vgpuInstance             vGPU instance handle
        ///  * @param vgpuMetadata             Pointer to caller-supplied buffer into which vGPU metadata is written
        ///  * @param bufferSize               Size of vgpuMetadata buffer
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                   vGPU metadata structure was successfully returned
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE   vgpuMetadata buffer is too small, required size is returned in \a bufferSize
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT    if \a bufferSize is NULL or \a vgpuInstance is 0; if \a vgpuMetadata is NULL and the value of \a bufferSize is not 0.
        ///  *         - \ref NVML_ERROR_NOT_FOUND           if \a vgpuInstance does not match a valid active vGPU instance on the system
        ///  *         - \ref NVML_ERROR_UNKNOWN             on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlVgpuInstanceGetMetadata(nvmlVgpuInstance_t vgpuInstance, nvmlVgpuMetadata_t *vgpuMetadata, unsigned int *bufferSize);
        /// 
        /// /**
        ///  * Returns a vGPU metadata structure for the physical GPU indicated by \a device. The structure contains information about
        ///  * the GPU and the currently installed NVIDIA host driver version that's controlling it, together with an opaque data section
        ///  * containing internal state.
        ///  *
        ///  * The caller passes in a buffer via \a pgpuMetadata, with the size of the buffer in \a bufferSize. If the \a pgpuMetadata
        ///  * structure is too large to fit in the supplied buffer, the function returns NVML_ERROR_INSUFFICIENT_SIZE with the size needed
        ///  * in \a bufferSize.
        ///  *
        ///  * @param device                The identifier of the target device
        ///  * @param pgpuMetadata          Pointer to caller-supplied buffer into which \a pgpuMetadata is written
        ///  * @param bufferSize            Pointer to size of \a pgpuMetadata buffer
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                   GPU metadata structure was successfully returned
        ///  *         - \ref NVML_ERROR_INSUFFICIENT_SIZE   pgpuMetadata buffer is too small, required size is returned in \a bufferSize
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT    if \a bufferSize is NULL or \a device is invalid; if \a pgpuMetadata is NULL and the value of \a bufferSize is not 0.
        ///  *         - \ref NVML_ERROR_NOT_SUPPORTED       vGPU is not supported by the system
        ///  *         - \ref NVML_ERROR_UNKNOWN             on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlDeviceGetVgpuMetadata(nvmlDevice_t device, nvmlVgpuPgpuMetadata_t *pgpuMetadata, unsigned int *bufferSize);
        /// 
        /// /**
        ///  * Takes a vGPU instance metadata structure read from \ref nvmlVgpuInstanceGetMetadata(), and a vGPU metadata structure for a
        ///  * physical GPU read from \ref nvmlDeviceGetVgpuMetadata(), and returns compatibility information of the vGPU instance and the
        ///  * physical GPU.
        ///  *
        ///  * The caller passes in a buffer via \a compatibilityInfo, into which a compatibility information structure is written. The
        ///  * structure defines the states in which the vGPU / VM may be booted on the physical GPU. If the vGPU / VM compatibility
        ///  * with the physical GPU is limited, a limit code indicates the factor limiting compability.
        ///  * (see \ref nvmlVgpuPgpuCompatibilityLimitCode_t for details).
        ///  *
        ///  * Note: vGPU compatibility does not take into account dynamic capacity conditions that may limit a system's ability to
        ///  *       boot a given vGPU or associated VM.
        ///  *
        ///  * @param vgpuMetadata          Pointer to caller-supplied vGPU metadata structure
        ///  * @param pgpuMetadata          Pointer to caller-supplied GPU metadata structure
        ///  * @param compatibilityInfo     Pointer to caller-supplied buffer to hold compatibility info
        ///  *
        ///  * @return
        ///  *         - \ref NVML_SUCCESS                   vGPU metadata structure was successfully returned
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT    if \a vgpuMetadata or \a pgpuMetadata or \a bufferSize are NULL
        ///  *         - \ref NVML_ERROR_UNKNOWN             on any unexpected error
        ///  */
        /// nvmlReturn_t DECLDIR nvmlGetVgpuCompatibility(nvmlVgpuMetadata_t *vgpuMetadata, nvmlVgpuPgpuMetadata_t *pgpuMetadata, nvmlVgpuPgpuCompatibility_t *compatibilityInfo);
        /// 
        /// /*
        ///  * Virtual GPU (vGPU) version
        ///  *
        ///  * The NVIDIA vGPU Manager and the guest drivers are tagged with a range of supported vGPU versions. This determines the range of NVIDIA guest driver versions that
        ///  * are compatible for vGPU feature support with a given NVIDIA vGPU Manager. For vGPU feature support, the range of supported versions for the NVIDIA vGPU Manager 
        ///  * and the guest driver must overlap. Otherwise, the guest driver fails to load in the VM.
        ///  *
        ///  * When the NVIDIA guest driver loads, either when the VM is booted or when the driver is installed or upgraded, a negotiation occurs between the guest driver
        ///  * and the NVIDIA vGPU Manager to select the highest mutually compatible vGPU version. The negotiated vGPU version stays the same across VM migration.
        ///  */
        /// 
        /// /**
        ///  * Query the ranges of supported vGPU versions.
        ///  *
        ///  * This function gets the linear range of supported vGPU versions that is preset for the NVIDIA vGPU Manager and the range set by an administrator.
        ///  * If the preset range has not been overridden by \ref nvmlSetVgpuVersion, both ranges are the same.
        ///  *
        ///  * The caller passes pointers to the following \ref nvmlVgpuVersion_t structures, into which the NVIDIA vGPU Manager writes the ranges:
        ///  * 1. \a supported structure that represents the preset range of vGPU versions supported by the NVIDIA vGPU Manager.
        ///  * 2. \a current structure that represents the range of supported vGPU versions set by an administrator. By default, this range is the same as the preset range.
        ///  *
        ///  * @param supported  Pointer to the structure in which the preset range of vGPU versions supported by the NVIDIA vGPU Manager is written
        ///  * @param current    Pointer to the structure in which the range of supported vGPU versions set by an administrator is written
        ///  *
        ///  * @return
        ///  * - \ref NVML_SUCCESS                 The vGPU version range structures were successfully obtained.
        ///  * - \ref NVML_ERROR_NOT_SUPPORTED     The API is not supported.
        ///  * - \ref NVML_ERROR_INVALID_ARGUMENT  The \a supported parameter or the \a current parameter is NULL.
        ///  * - \ref NVML_ERROR_UNKNOWN           An error occurred while the data was being fetched.
        ///  */
        /// nvmlReturn_t DECLDIR nvmlGetVgpuVersion(nvmlVgpuVersion_t *supported, nvmlVgpuVersion_t *current);
        /// 
        /// /**
        ///  * Override the preset range of vGPU versions supported by the NVIDIA vGPU Manager with a range set by an administrator.
        ///  *
        ///  * This function configures the NVIDIA vGPU Manager with a range of supported vGPU versions set by an administrator. This range must be a subset of the
        ///  * preset range that the NVIDIA vGPU Manager supports. The custom range set by an administrator takes precedence over the preset range and is advertised to
        ///  * the guest VM for negotiating the vGPU version. See \ref nvmlGetVgpuVersion for details of how to query the preset range of versions supported.
        ///  *
        ///  * This function takes a pointer to vGPU version range structure \ref nvmlVgpuVersion_t as input to override the preset vGPU version range that the NVIDIA vGPU Manager supports.
        ///  *
        ///  * After host system reboot or driver reload, the range of supported versions reverts to the range that is preset for the NVIDIA vGPU Manager.
        ///  *
        ///  * @note 1. The range set by the administrator must be a subset of the preset range that the NVIDIA vGPU Manager supports. Otherwise, an error is returned.
        ///  *       2. If the range of supported guest driver versions does not overlap the range set by the administrator, the guest driver fails to load.
        ///  *       3. If the range of supported guest driver versions overlaps the range set by the administrator, the guest driver will load with a negotiated 
        ///  *          vGPU version that is the maximum value in the overlapping range.
        ///  *       4. No VMs must be running on the host when this function is called. If a VM is running on the host, the call to this function fails.
        ///  *
        ///  * @param vgpuVersion   Pointer to a caller-supplied range of supported vGPU versions.
        ///  *
        ///  * @return
        ///  * - \ref NVML_SUCCESS                 The preset range of supported vGPU versions was successfully overridden.
        ///  * - \ref NVML_ERROR_NOT_SUPPORTED     The API is not supported.
        ///  * - \ref NVML_ERROR_IN_USE            The range was not overridden because a VM is running on the host.
        ///  * - \ref NVML_ERROR_INVALID_ARGUMENT  The \a vgpuVersion parameter specifies a range that is outside the range supported by the NVIDIA vGPU Manager or if \a vgpuVersion is NULL.
        ///  */
        /// nvmlReturn_t DECLDIR nvmlSetVgpuVersion(nvmlVgpuVersion_t *vgpuVersion);
        /// 
        /// /** @} */
        /// 
        /// /***************************************************************************************************/
        /// /** @defgroup nvmlGpuBlacklistQueries GPU Blacklist Queries
        ///  * This chapter describes NVML operations that are associated with blacklisted GPUs.
        ///  *  @{
        ///  */
        /// /***************************************************************************************************/
        /// 
        /// /**
        ///  * Blacklist GPU device information
        ///  **/
        /// typedef struct nvmlBlacklistDeviceInfo_st
        /// {
        ///     nvmlPciInfo_t pciInfo;                   //!&lt; The PCI information for the blacklisted GPU
        ///     char uuid[NVML_DEVICE_UUID_BUFFER_SIZE]; //!&lt; The ASCII string UUID for the blacklisted GPU
        /// } nvmlBlacklistDeviceInfo_t;
        /// 
        ///  /**
        ///  * Retrieves the number of blacklisted GPU devices in the system.
        ///  * 
        ///  * For all products.
        ///  *
        ///  * @param deviceCount                          Reference in which to return the number of blacklisted devices
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                 if \a deviceCount has been set
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT  if \a deviceCount is NULL
        ///  */
        /// nvmlReturn_t DECLDIR nvmlGetBlacklistDeviceCount(unsigned int *deviceCount);
        /// 
        /// /**
        ///  * Acquire the device information for a blacklisted device, based on its index.
        ///  * 
        ///  * For all products.
        ///  *
        ///  * Valid indices are derived from the \a deviceCount returned by 
        ///  *   \ref nvmlGetBlacklistDeviceCount(). For example, if \a deviceCount is 2 the valid indices  
        ///  *   are 0 and 1, corresponding to GPU 0 and GPU 1.
        ///  *
        ///  * @param index                                The index of the target GPU, &gt;= 0 and &lt; \a deviceCount
        ///  * @param info                                 Reference in which to return the device information
        ///  * 
        ///  * @return 
        ///  *         - \ref NVML_SUCCESS                  if \a device has been set
        ///  *         - \ref NVML_ERROR_INVALID_ARGUMENT   if \a index is invalid or \a info is NULL
        ///  *
        ///  * @see nvmlGetBlacklistDeviceCount
        ///  */
        /// nvmlReturn_t DECLDIR nvmlGetBlacklistDeviceInfoByIndex(unsigned int index, nvmlBlacklistDeviceInfo_t *info);
        /// 
        /// /** @} */
        /// 
        /// /**
        ///  * NVML API versioning support
        ///  */
        /// #if defined(__NVML_API_VERSION_INTERNAL)
        /// #undef nvmlDeviceGetGridLicensableFeatures
        /// #undef nvmlDeviceRemoveGpu
        /// #undef nvmlDeviceGetNvLinkRemotePciInfo
        /// #undef nvmlDeviceGetPciInfo
        /// #undef nvmlDeviceGetCount
        /// #undef nvmlDeviceGetHandleByIndex
        /// #undef nvmlDeviceGetHandleByPciBusId
        /// #undef nvmlInit
        /// #endif
        /// 
        /// #ifdef __cplusplus
        /// }
        /// #endif
        /// 
        /// #endifnvmlConstants::NVML_DEVICE_NAME_BUFFER_SIZE.For Kepler 
        /// &amp;tm;
        /// or newer fully supported devices. NVML_SUCCESS                 successful completion- NVML_ERROR_INVALID_ARGUMENT  if \a vgpuTypeId is invalid, or \a name is NULL- NVML_ERROR_INSUFFICIENT_SIZE if \a size is too small- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlVgpuTypeGetName(uint vgpuTypeId, IntPtr vgpuTypeName, ref uint size);
        
        /// <summary>
        /// Retrieve the device ID of a vGPU type.
        /// </summary>
        /// <param name="vgpuTypeId">Handle to vGPU type</param>
        /// <param name="deviceID">Device ID and vendor ID of the device contained in single 32 bit value</param>
        /// <param name="subsystemID">Subsytem ID and subsytem vendor ID of the device contained in single 32 bit value</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For Kepler 
        /// &amp;tm;
        /// or newer fully supported devices. NVML_SUCCESS                 successful completion- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a vgpuTypeId is invalid, or \a deviceId or \a subsystemID are NULL- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlVgpuTypeGetDeviceID(uint vgpuTypeId, ref ulong deviceID, ref ulong subsystemID);
        
        /// <summary>
        /// Retrieve the vGPU framebuffer size in bytes.
        /// </summary>
        /// <param name="vgpuTypeId">Handle to vGPU type</param>
        /// <param name="fbSize">Pointer to framebuffer size in bytes</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For Kepler 
        /// &amp;tm;
        /// or newer fully supported devices. NVML_SUCCESS                 successful completion- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a vgpuTypeId is invalid, or \a fbSize is NULL- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlVgpuTypeGetFramebufferSize(uint vgpuTypeId, ref ulong fbSize);
        
        /// <summary>
        /// Retrieve count of vGPU's supported display heads.
        /// </summary>
        /// <param name="vgpuTypeId">Handle to vGPU type</param>
        /// <param name="numDisplayHeads">Pointer to number of display heads</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For Kepler 
        /// &amp;tm;
        /// or newer fully supported devices. NVML_SUCCESS                 successful completion- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a vgpuTypeId is invalid, or \a numDisplayHeads is NULL- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlVgpuTypeGetNumDisplayHeads(uint vgpuTypeId, ref uint numDisplayHeads);
        
        /// <summary>
        /// Retrieve vGPU display head's maximum supported resolution.
        /// </summary>
        /// <param name="vgpuTypeId">Handle to vGPU type</param>
        /// <param name="displayIndex">Zero-based index of display head</param>
        /// <param name="xdim">Pointer to maximum number of pixels in X dimension</param>
        /// <param name="ydim">Pointer to maximum number of pixels in Y dimension</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For Kepler 
        /// &amp;tm;
        /// or newer fully supported devices. NVML_SUCCESS                 successful completion- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a vgpuTypeId is invalid, or \a xdim or \a ydim are NULL, or \a displayIndexis out of range.
        /// - NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlVgpuTypeGetResolution(uint vgpuTypeId, uint displayIndex, ref uint xdim, ref uint ydim);
        
        /// <summary>
        /// Retrieve license requirements for a vGPU type
        /// </summary>
        /// <param name="vgpuTypeId">Handle to vGPU type</param>
        /// <param name="vgpuTypeLicenseString">Pointer to buffer to return license info</param>
        /// <param name="size">Size of @a vgpuTypeLicenseString buffer</param>
        /// <returns>-</returns>
        /// <remarks>
        /// The license type and version required to run the specified vGPU type is returned as an alphanumeric string, in the form
        /// "
        /// &lt;license
        /// name&gt;,
        /// &lt;version
        /// &gt;", for example "GRID-Virtual-PC,2.0". If a vGPU is runnable with* more than one type of license,
        /// the licenses are delimited by a semicolon, for example "GRID-Virtual-PC,2.0;GRID-Virtual-WS,2.0;GRID-Virtual-WS-Ext,2.0".The total length of the returned string will not exceed 128 characters, including the NUL terminator.
        /// See nvmlVgpuConstants::NVML_GRID_LICENSE_BUFFER_SIZE.For Kepler 
        /// &amp;tm;
        /// or newer fully supported devices. NVML_SUCCESS                 successful completion- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a vgpuTypeId is invalid, or \a vgpuTypeLicenseString is NULL- NVML_ERROR_INSUFFICIENT_SIZE if \a size is too small- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlVgpuTypeGetLicense(uint vgpuTypeId, IntPtr vgpuTypeLicenseString, uint size);
        
        /// <summary>
        /// Retrieve the static frame rate limit value of the vGPU type
        /// </summary>
        /// <param name="vgpuTypeId">Handle to vGPU type</param>
        /// <param name="frameRateLimit">Reference to return the frame rate limit value</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For Kepler 
        /// &amp;tm;
        /// or newer fully supported devices. NVML_SUCCESS                 successful completion- NVML_ERROR_NOT_SUPPORTED     if frame rate limiter is turned off for the vGPU type- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a vgpuTypeId is invalid, or \a frameRateLimit is NULL- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlVgpuTypeGetFrameRateLimit(uint vgpuTypeId, ref uint frameRateLimit);
        
        /// <summary>
        /// Retrieve the maximum number of vGPU instances creatable on a device for given vGPU type
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="vgpuTypeId">Handle to vGPU type</param>
        /// <param name="vgpuInstanceCount">Pointer to get the max number of vGPU instances
        /// that can be created on a deicve for given vgpuTypeId</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For Kepler 
        /// &amp;tm;
        /// or newer fully supported devices. NVML_SUCCESS                 successful completion- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a vgpuTypeId is invalid or is not supported on target device,or @a vgpuInstanceCount is NULL
        /// - NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlVgpuTypeGetMaxInstances(nvmlDevice_st device, uint vgpuTypeId, ref uint vgpuInstanceCount);
        
        /// <summary>
        /// Retrieve the maximum number of vGPU instances supported per VM for given vGPU type
        /// </summary>
        /// <param name="vgpuTypeId">Handle to vGPU type</param>
        /// <param name="vgpuInstanceCountPerVm">Pointer to get the max number of vGPU instances supported per VM for given @a vgpuTypeId</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For Kepler 
        /// &amp;tm;
        /// or newer fully supported devices. NVML_SUCCESS                 successful completion- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a vgpuTypeId is invalid, or \a vgpuInstanceCountPerVm is NULL- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlVgpuTypeGetMaxInstancesPerVm(uint vgpuTypeId, ref uint vgpuInstanceCountPerVm);
        
        /// <summary>
        /// Retrieve the active vGPU instances on a device.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="vgpuCount">Pointer which passes in the array size as well as get
        /// back the number of types</param>
        /// <param name="vgpuInstances">Pointer to array in which to return list of vGPU instances</param>
        /// <returns>-</returns>
        /// <remarks>
        /// An array of active vGPU instances is returned in the caller-supplied buffer pointed at by @a vgpuInstances. The
        /// array elememt count is passed in @a vgpuCount, and @a vgpuCount is used to return the number of vGPU instances
        /// written to the buffer.If the supplied buffer is not large enough to accomodate the vGPU instance array, the function returns
        /// NVML_ERROR_INSUFFICIENT_SIZE, with the element count of nvmlVgpuInstance_t array required in @a vgpuCount. To query the number of active vGPU instances, call this function with *vgpuCount = 0.  The code will return
        /// NVML_ERROR_INSUFFICIENT_SIZE, or NVML_SUCCESS if no vGPU Types are supported.For Kepler 
        /// &amp;tm;
        /// or newer fully supported devices. NVML_SUCCESS                  successful completion- NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT   if \a device is invalid, or \a vgpuCount is NULL- NVML_ERROR_INSUFFICIENT_SIZE  if \a size is too small- NVML_ERROR_NOT_SUPPORTED      if vGPU is not supported by the device- NVML_ERROR_UNKNOWN            on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetActiveVgpus(nvmlDevice_st device, ref uint vgpuCount, ref uint vgpuInstances);
        
        /// <summary>
        /// Retrieve the VM ID associated with a vGPU instance.
        /// </summary>
        /// <param name="vgpuInstance">Identifier of the target vGPU instance</param>
        /// <param name="vmId">Pointer to caller-supplied buffer to hold VM ID</param>
        /// <param name="size">Size of buffer in bytes</param>
        /// <param name="vmIdType">Pointer to hold VM ID type</param>
        /// <returns>-</returns>
        /// <remarks>
        /// The VM ID is returned as a string, not exceeding 80 characters in length (including the NUL terminator).
        /// See nvmlConstants::NVML_DEVICE_UUID_BUFFER_SIZE.The format of the VM ID varies by platform, and is indicated by the type identifier returned in @a vmIdType.For Kepler 
        /// &amp;tm;
        /// or newer fully supported devices. NVML_SUCCESS                 successful completion- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a vmId or \a vmIdType is NULL, or \a vgpuInstance is 0- NVML_ERROR_NOT_FOUND         if \a vgpuInstance does not match a valid active vGPU instance on the system- NVML_ERROR_INSUFFICIENT_SIZE if \a size is too small- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlVgpuInstanceGetVmID(uint vgpuInstance, IntPtr vmId, uint size, ref nvmlVgpuVmIdType vmIdType);
        
        /// <summary>
        /// Retrieve the UUID of a vGPU instance.
        /// </summary>
        /// <param name="vgpuInstance">Identifier of the target vGPU instance</param>
        /// <param name="uuid">Pointer to caller-supplied buffer to hold vGPU UUID</param>
        /// <param name="size">Size of buffer in bytes</param>
        /// <returns>-</returns>
        /// <remarks>
        /// The UUID is a globally unique identifier associated with the vGPU, and is returned as a 5-part hexadecimal string,
        /// not exceeding 80 characters in length (including the NULL terminator).
        /// See nvmlConstants::NVML_DEVICE_UUID_BUFFER_SIZE.For Kepler 
        /// &amp;tm;
        /// or newer fully supported devices. NVML_SUCCESS                 successful completion- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a vgpuInstance is 0, or \a uuid is NULL- NVML_ERROR_NOT_FOUND         if \a vgpuInstance does not match a valid active vGPU instance on the system- NVML_ERROR_INSUFFICIENT_SIZE if \a size is too small- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlVgpuInstanceGetUUID(uint vgpuInstance, IntPtr uuid, uint size);
        
        /// <summary>
        /// Retrieve the NVIDIA driver version installed in the VM associated with a vGPU.
        /// </summary>
        /// <param name="vgpuInstance">Identifier of the target vGPU instance</param>
        /// <param name="version">Caller-supplied buffer to return driver version string</param>
        /// <param name="length">Size of @a version buffer</param>
        /// <returns>-</returns>
        /// <remarks>
        /// The version is returned as an alphanumeric string in the caller-supplied buffer @a version. The length of the version
        /// string will not exceed 80 characters in length (including the NUL terminator).
        /// See nvmlConstants::NVML_SYSTEM_DRIVER_VERSION_BUFFER_SIZE.nvmlVgpuInstanceGetVmDriverVersion() may be called at any time for a vGPU instance. The guest VM driver version is
        /// returned as "Unknown" if no NVIDIA driver is installed in the VM, or the VM has not yet booted to the point where the
        /// NVIDIA driver is loaded and initialized.For Kepler 
        /// &amp;tm;
        /// or newer fully supported devices. NVML_SUCCESS                 if \a version has been set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a vgpuInstance is 0- NVML_ERROR_NOT_FOUND         if \a vgpuInstance does not match a valid active vGPU instance on the system- NVML_ERROR_INSUFFICIENT_SIZE if \a length is too small- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlVgpuInstanceGetVmDriverVersion(uint vgpuInstance, IntPtr version, uint length);
        
        /// <summary>
        /// Retrieve the framebuffer usage in bytes.
        /// </summary>
        /// <param name="vgpuInstance">The identifier of the target instance</param>
        /// <param name="fbUsage">Pointer to framebuffer usage in bytes</param>
        /// <returns>-</returns>
        /// <remarks>
        /// Framebuffer usage is the amont of vGPU framebuffer memory that is currently in use by the VM.For Kepler 
        /// &amp;tm;
        /// or newer fully supported devices. NVML_SUCCESS                 successful completion- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a vgpuInstance is 0, or \a fbUsage is NULL- NVML_ERROR_NOT_FOUND         if \a vgpuInstance does not match a valid active vGPU instance on the system- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlVgpuInstanceGetFbUsage(uint vgpuInstance, ref ulong fbUsage);
        
        /// <summary>
        /// Retrieve the current licensing state of the vGPU instance.
        /// </summary>
        /// <param name="vgpuInstance">Identifier of the target vGPU instance</param>
        /// <param name="licensed">Reference to return the licensing status</param>
        /// <returns>-</returns>
        /// <remarks>
        /// If the vGPU is currently licensed, @a licensed is set to 1, otherwise it is set to 0.For Kepler 
        /// &amp;tm;
        /// or newer fully supported devices. NVML_SUCCESS                 if \a licensed has been set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a vgpuInstance is 0, or \a licensed is NULL- NVML_ERROR_NOT_FOUND         if \a vgpuInstance does not match a valid active vGPU instance on the system- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlVgpuInstanceGetLicenseStatus(uint vgpuInstance, ref uint licensed);
        
        /// <summary>
        /// Retrieve the vGPU type of a vGPU instance.
        /// </summary>
        /// <param name="vgpuInstance">Identifier of the target vGPU instance</param>
        /// <param name="vgpuTypeId">Reference to return the vgpuTypeId</param>
        /// <returns>-</returns>
        /// <remarks>
        /// Returns the vGPU type ID of vgpu assigned to the vGPU instance.For Kepler 
        /// &amp;tm;
        /// or newer fully supported devices. NVML_SUCCESS                 if \a vgpuTypeId has been set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a vgpuInstance is 0, or \a vgpuTypeId is NULL- NVML_ERROR_NOT_FOUND         if \a vgpuInstance does not match a valid active vGPU instance on the system- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlVgpuInstanceGetType(uint vgpuInstance, ref uint vgpuTypeId);
        
        /// <summary>
        /// Retrieve the frame rate limit set for the vGPU instance.
        /// </summary>
        /// <param name="vgpuInstance">Identifier of the target vGPU instance</param>
        /// <param name="frameRateLimit">Reference to return the frame rate limit</param>
        /// <returns>-</returns>
        /// <remarks>
        /// Returns the value of the frame rate limit set for the vGPU instanceFor Kepler 
        /// &amp;tm;
        /// or newer fully supported devices. NVML_SUCCESS                 if \a frameRateLimit has been set- NVML_ERROR_NOT_SUPPORTED     if frame rate limiter is turned off for the vGPU type- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a vgpuInstance is 0, or \a frameRateLimit is NULL- NVML_ERROR_NOT_FOUND         if \a vgpuInstance does not match a valid active vGPU instance on the system- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlVgpuInstanceGetFrameRateLimit(uint vgpuInstance, ref uint frameRateLimit);
        
        /// <summary>
        /// Retrieve the encoder capacity of a vGPU instance, as a percentage of maximum encoder capacity with valid values in the range 0-100.
        /// </summary>
        /// <param name="vgpuInstance">Identifier of the target vGPU instance</param>
        /// <param name="encoderCapacity">Reference to an unsigned int for the encoder capacity</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For Maxwell 
        /// &amp;tm;
        /// or newer fully supported devices. NVML_SUCCESS                 if \a encoderCapacity has been retrived- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a vgpuInstance is 0, or \a encoderQueryType is invalid- NVML_ERROR_NOT_FOUND         if \a vgpuInstance does not match a valid active vGPU instance on the system- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlVgpuInstanceGetEncoderCapacity(uint vgpuInstance, ref uint encoderCapacity);
        
        /// <summary>
        /// Set the encoder capacity of a vGPU instance, as a percentage of maximum encoder capacity with valid values in the range 0-100.
        /// </summary>
        /// <param name="vgpuInstance">Identifier of the target vGPU instance</param>
        /// <param name="encoderCapacity">Unsigned int for the encoder capacity value</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For Maxwell 
        /// &amp;tm;
        /// or newer fully supported devices. NVML_SUCCESS                 if \a encoderCapacity has been set- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a vgpuInstance is 0, or \a encoderCapacity is out of range of 0-100.- NVML_ERROR_NOT_FOUND         if \a vgpuInstance does not match a valid active vGPU instance on the system- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlVgpuInstanceSetEncoderCapacity(uint vgpuInstance, uint encoderCapacity);
        
        /// <summary>
        /// Retrieves current utilization for vGPUs on a physical GPU (device).
        /// </summary>
        /// <param name="device">The identifier for the target device</param>
        /// <param name="lastSeenTimeStamp">Return only samples with timestamp greater than lastSeenTimeStamp.</param>
        /// <param name="sampleValType">Pointer to caller-supplied buffer to hold the type of returned sample values</param>
        /// <param name="vgpuInstanceSamplesCount">Pointer to caller-supplied array size, and returns number of vGPU instances</param>
        /// <param name="utilizationSamples">Pointer to caller-supplied buffer in which vGPU utilization samples are returned</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For Kepler 
        /// &amp;tm;
        /// or newer fully supported devices.Reads recent utilization of GPU SM (3D/Compute), framebuffer, video encoder, and video decoder for vGPU instances running
        /// on a device. Utilization values are returned as an array of utilization sample structures in the caller-supplied buffer
        /// pointed at by @a utilizationSamples. One utilization sample structure is returned per vGPU instance, and includes the
        /// CPU timestamp at which the samples were recorded. Individual utilization values are returned as "unsigned int" values
        /// in nvmlValue_t unions. The function sets the caller-supplied @a sampleValType to NVML_VALUE_TYPE_UNSIGNED_INT to
        /// indicate the returned value type.To read utilization values, first determine the size of buffer required to hold the samples by invoking the function with
        /// @a utilizationSamples set to NULL. The function will return NVML_ERROR_INSUFFICIENT_SIZE, with the current vGPU instance
        /// count in @a vgpuInstanceSamplesCount, or NVML_SUCCESS if the current vGPU instance count is zero. The caller should allocate
        /// a buffer of size vgpuInstanceSamplesCount * sizeof(nvmlVgpuInstanceUtilizationSample_t). Invoke the function again with
        /// the allocated buffer passed in @a utilizationSamples, and @a vgpuInstanceSamplesCount set to the number of entries the
        /// buffer is sized for.On successful return, the function updates @a vgpuInstanceSampleCount with the number of vGPU utilization sample
        /// structures that were actually written. This may differ from a previously read value as vGPU instances are created or
        /// destroyed.lastSeenTimeStamp represents the CPU timestamp in microseconds at which utilization samples were last read. Set it to 0
        /// to read utilization based on all the samples maintained by the driver's internal sample buffer. Set lastSeenTimeStamp
        /// to a timeStamp retrieved from a previous query to read utilization since the previous query. NVML_SUCCESS                 if utilization samples are successfully retrieved- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, \a vgpuInstanceSamplesCount or \a sampleValType isNULL, or a sample count of 0 is passed with a non-NULL @a utilizationSamples - NVML_ERROR_INSUFFICIENT_SIZE if supplied \a vgpuInstanceSamplesCount is too small to return samples for allvGPU instances currently executing on the device
        /// - NVML_ERROR_NOT_SUPPORTED     if vGPU is not supported by the device- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_NOT_FOUND         if sample entries are not found- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetVgpuUtilization(nvmlDevice_st device, ulong lastSeenTimeStamp, ref nvmlValueType_enum sampleValType, ref uint vgpuInstanceSamplesCount, ref nvmlVgpuInstanceUtilizationSample_st utilizationSamples);
        
        /// <summary>
        /// Retrieves current utilization for processes running on vGPUs on a physical GPU (device).
        /// </summary>
        /// <param name="device">The identifier for the target device</param>
        /// <param name="lastSeenTimeStamp">Return only samples with timestamp greater than lastSeenTimeStamp.</param>
        /// <param name="vgpuProcessSamplesCount">Pointer to caller-supplied array size, and returns number of processes running on vGPU instances</param>
        /// <param name="utilizationSamples">Pointer to caller-supplied buffer in which vGPU sub process utilization samples are returned</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For Maxwell 
        /// &amp;tm;
        /// or newer fully supported devices.Reads recent utilization of GPU SM (3D/Compute), framebuffer, video encoder, and video decoder for processes running on
        /// vGPU instances active on a device. Utilization values are returned as an array of utilization sample structures in the
        /// caller-supplied buffer pointed at by @a utilizationSamples. One utilization sample structure is returned per process running
        /// on vGPU instances, that had some non-zero utilization during the last sample period. It includes the CPU timestamp at which
        /// the samples were recorded. Individual utilization values are returned as "unsigned int" values.To read utilization values, first determine the size of buffer required to hold the samples by invoking the function with
        /// @a utilizationSamples set to NULL. The function will return NVML_ERROR_INSUFFICIENT_SIZE, with the current vGPU instance
        /// count in @a vgpuProcessSamplesCount. The caller should allocate a buffer of size
        /// vgpuProcessSamplesCount * sizeof(nvmlVgpuProcessUtilizationSample_t). Invoke the function again with
        /// the allocated buffer passed in @a utilizationSamples, and @a vgpuProcessSamplesCount set to the number of entries the
        /// buffer is sized for.On successful return, the function updates @a vgpuSubProcessSampleCount with the number of vGPU sub process utilization sample
        /// structures that were actually written. This may differ from a previously read value depending on the number of processes that are active
        /// in any given sample period.lastSeenTimeStamp represents the CPU timestamp in microseconds at which utilization samples were last read. Set it to 0
        /// to read utilization based on all the samples maintained by the driver's internal sample buffer. Set lastSeenTimeStamp
        /// to a timeStamp retrieved from a previous query to read utilization since the previous query. NVML_SUCCESS                 if utilization samples are successfully retrieved- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, \a vgpuProcessSamplesCount or a sample count of 0 ispassed with a non-NULL @a utilizationSamples - NVML_ERROR_INSUFFICIENT_SIZE if supplied \a vgpuProcessSamplesCount is too small to return samples for allvGPU instances currently executing on the device
        /// - NVML_ERROR_NOT_SUPPORTED     if vGPU is not supported by the device- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_NOT_FOUND         if sample entries are not found- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetVgpuProcessUtilization(nvmlDevice_st device, ulong lastSeenTimeStamp, ref uint vgpuProcessSamplesCount, ref nvmlVgpuProcessUtilizationSample_st utilizationSamples);
        
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetGridLicensableFeatures_v2(nvmlDevice_st device, ref nvmlGridLicensableFeatures_st pGridLicensableFeatures);
        
        /// <summary>
        /// Retrieves the current encoder statistics of a vGPU Instance
        /// </summary>
        /// <param name="vgpuInstance">Identifier of the target vGPU instance</param>
        /// <param name="sessionCount">Reference to an unsigned int for count of active encoder sessions</param>
        /// <param name="averageFps">Reference to an unsigned int for trailing average FPS of all active sessions</param>
        /// <param name="averageLatency">Reference to an unsigned int for encode latency in microseconds</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For Maxwell 
        /// &amp;tm;
        /// or newer fully supported devices. NVML_SUCCESS                  if \a sessionCount, \a averageFps and \a averageLatency is fetched- NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT   if \a sessionCount , or \a averageFps or \a averageLatency is NULLor @a vgpuInstance is 0.
        /// - NVML_ERROR_NOT_FOUND          if \a vgpuInstance does not match a valid active vGPU instance on the system- NVML_ERROR_UNKNOWN            on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlVgpuInstanceGetEncoderStats(uint vgpuInstance, ref uint sessionCount, ref uint averageFps, ref uint averageLatency);
        
        /// <summary>
        /// Retrieves information about all active encoder sessions on a vGPU Instance.
        /// </summary>
        /// <param name="vgpuInstance">Identifier of the target vGPU instance</param>
        /// <param name="sessionCount">Reference to caller supplied array size, and returns
        /// the number of sessions.</param>
        /// <param name="sessionInfo">Reference to caller supplied array in which the list
        /// of session information us returned.</param>
        /// <returns>-</returns>
        /// <remarks>
        /// An array of active encoder sessions is returned in the caller-supplied buffer pointed at by @a sessionInfo. The
        /// array element count is passed in @a sessionCount, and @a sessionCount is used to return the number of sessions
        /// written to the buffer.If the supplied buffer is not large enough to accomodate the active session array, the function returns
        /// NVML_ERROR_INSUFFICIENT_SIZE, with the element count of nvmlEncoderSessionInfo_t array required in @a sessionCount. To query the number of active encoder sessions, call this function with *sessionCount = 0. The code will return
        /// NVML_SUCCESS with number of active encoder sessions updated in *sessionCount.For Maxwell 
        /// &amp;tm;
        /// or newer fully supported devices. NVML_SUCCESS                  if \a sessionInfo is fetched- NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized- NVML_ERROR_INSUFFICIENT_SIZE  if \a sessionCount is too small, array element count isreturned in @a sessionCount - NVML_ERROR_INVALID_ARGUMENT   if \a sessionCount is NULL, or \a vgpuInstance is 0.- NVML_ERROR_NOT_FOUND          if \a vgpuInstance does not match a valid active vGPU instance on the system- NVML_ERROR_UNKNOWN            on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlVgpuInstanceGetEncoderSessions(uint vgpuInstance, ref uint sessionCount, ref nvmlEncoderSessionInfo_st sessionInfo);
        
        /// <summary>
        /// Retrieves the active frame buffer capture sessions statistics of a vGPU Instance
        /// </summary>
        /// <param name="vgpuInstance">Identifier of the target vGPU instance</param>
        /// <param name="fbcStats">Reference to nvmlFBCStats_t structure contianing NvFBC stats</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For Maxwell 
        /// &amp;tm;
        /// or newer fully supported devices. NVML_SUCCESS                  if \a fbcStats is fetched- NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT   if \a vgpuInstance is 0, or \a fbcStats is NULL- NVML_ERROR_NOT_FOUND          if \a vgpuInstance does not match a valid active vGPU instance on the system- NVML_ERROR_UNKNOWN            on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlVgpuInstanceGetFBCStats(uint vgpuInstance, ref nvmlFBCStats_st fbcStats);
        
        /// <summary>
        /// Retrieves information about active frame buffer capture sessions on a vGPU Instance.
        /// </summary>
        /// <param name="vgpuInstance">Identifier of the target vGPU instance</param>
        /// <param name="sessionCount">Reference to caller supplied array size, and returns the number of sessions.</param>
        /// <param name="sessionInfo">Reference in which to return the session information</param>
        /// <returns>-</returns>
        /// <remarks>
        /// An array of active FBC sessions is returned in the caller-supplied buffer pointed at by @a sessionInfo. The
        /// array element count is passed in @a sessionCount, and @a sessionCount is used to return the number of sessions
        /// written to the buffer.If the supplied buffer is not large enough to accomodate the active session array, the function returns
        /// NVML_ERROR_INSUFFICIENT_SIZE, with the element count of nvmlFBCSessionInfo_t array required in @a sessionCount. To query the number of active FBC sessions, call this function with *sessionCount = 0.  The code will return
        /// NVML_SUCCESS with number of active FBC sessions updated in *sessionCount.For Maxwell 
        /// &amp;tm;
        /// or newer fully supported devices.@note hResolution, vResolution, averageFPS and averageLatency data for a FBC session returned in @a sessionInfo may
        /// be zero if there are no new frames captured since the session started. NVML_SUCCESS                  if \a sessionInfo is fetched- NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT   if \a vgpuInstance is 0, or \a sessionCount is NULL.- NVML_ERROR_NOT_FOUND          if \a vgpuInstance does not match a valid active vGPU instance on the system- NVML_ERROR_INSUFFICIENT_SIZE  if \a sessionCount is too small, array element count is returned in \a sessionCount- NVML_ERROR_UNKNOWN            on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlVgpuInstanceGetFBCSessions(uint vgpuInstance, ref uint sessionCount, ref nvmlFBCSessionInfo_st sessionInfo);
        
        /// <summary>
        /// Retrieves the current utilization and process ID
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="utilization">Pointer to caller-supplied buffer in which guest process utilization samples are returned</param>
        /// <param name="processSamplesCount">Pointer to caller-supplied array size, and returns number of processes running</param>
        /// <param name="lastSeenTimeStamp">Return only samples with timestamp greater than lastSeenTimeStamp.</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For Maxwell 
        /// &amp;tm;
        /// or newer fully supported devices.Reads recent utilization of GPU SM (3D/Compute), framebuffer, video encoder, and video decoder for processes running.
        /// Utilization values are returned as an array of utilization sample structures in the caller-supplied buffer pointed at
        /// by @a utilization. One utilization sample structure is returned per process running, that had some non-zero utilization
        /// during the last sample period. It includes the CPU timestamp at which  the samples were recorded. Individual utilization values
        /// are returned as "unsigned int" values.To read utilization values, first determine the size of buffer required to hold the samples by invoking the function with
        /// @a utilization set to NULL. The caller should allocate a buffer of size
        /// processSamplesCount * sizeof(nvmlProcessUtilizationSample_t). Invoke the function again with the allocated buffer passed
        /// in @a utilization, and @a processSamplesCount set to the number of entries the buffer is sized for.On successful return, the function updates @a processSamplesCount with the number of process utilization sample
        /// structures that were actually written. This may differ from a previously read value as instances are created or
        /// destroyed.lastSeenTimeStamp represents the CPU timestamp in microseconds at which utilization samples were last read. Set it to 0
        /// to read utilization based on all the samples maintained by the driver's internal sample buffer. Set lastSeenTimeStamp
        /// to a timeStamp retrieved from a previous query to read utilization since the previous query. NVML_SUCCESS                 if \a utilization has been populated- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a device is invalid, \a utilization is NULL, or \a samplingPeriodUs is NULL- NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature- NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetProcessUtilization(nvmlDevice_st device, ref nvmlProcessUtilizationSample_st utilization, ref uint processSamplesCount, ulong lastSeenTimeStamp);
        
        /// <summary>
        /// Queries the state of per process accounting mode on vGPU.
        /// </summary>
        /// <param name="vgpuInstance">The identifier of the target vGPU VM</param>
        /// <param name="mode">Reference in which to return the current accounting mode</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For Maxwell 
        /// &amp;tm;
        /// or newer fully supported devices. NVML_SUCCESS                 if the mode has been successfully retrieved- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a vgpuInstance is 0, or \a mode is NULL- NVML_ERROR_NOT_FOUND         if \a vgpuInstance does not match a valid active vGPU instance on the system- NVML_ERROR_NOT_SUPPORTED     if the vGPU doesn't support this feature- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlVgpuInstanceGetAccountingMode(uint vgpuInstance, ref nvmlEnableState_enum mode);
        
        /// <summary>
        /// Queries list of processes running on vGPU that can be queried for accounting stats. The list of processes 
        /// returned can be in running or terminated state.
        /// </summary>
        /// <param name="vgpuInstance">The identifier of the target vGPU VM</param>
        /// <param name="count">Reference in which to provide the @a pids array size, and
        /// to return the number of elements ready to be queried</param>
        /// <param name="pids">Reference in which to return list of process ids</param>
        /// <returns>-</returns>
        /// <seealso cref="nvmlVgpuInstanceGetAccountingPids"/>
        /// 
        /// <remarks>
        /// For Maxwell 
        /// &amp;tm;
        /// or newer fully supported devices.To just query the maximum number of processes that can be queried, call this function with *count = 0 and
        /// pids=NULL. The return code will be NVML_ERROR_INSUFFICIENT_SIZE, or NVML_SUCCESS if list is empty.For more details see nvmlVgpuInstanceGetAccountingStats.@note In case of PID collision some processes might not be accessible before the circular buffer is full. NVML_SUCCESS                 if pids were successfully retrieved- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a vgpuInstance is 0, or \a count is NULL- NVML_ERROR_NOT_FOUND         if \a vgpuInstance does not match a valid active vGPU instance on the system- NVML_ERROR_NOT_SUPPORTED     if the vGPU doesn't support this feature or accounting mode is disabled- NVML_ERROR_INSUFFICIENT_SIZE if \a count is too small (\a count is set to expected value)- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlVgpuInstanceGetAccountingPids(uint vgpuInstance, ref uint count, ref uint pids);
        
        /// <summary>
        /// Queries process's accounting stats.
        /// </summary>
        /// <param name="vgpuInstance">The identifier of the target vGPU VM</param>
        /// <param name="pid">Process Id of the target process to query stats for</param>
        /// <param name="stats">Reference in which to return the process's accounting stats</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For Maxwell 
        /// &amp;tm;
        /// or newer fully supported devices.Accounting stats capture GPU utilization and other statistics across the lifetime of a process, and
        /// can be queried during life time of the process or after its termination.
        /// The time field in nvmlAccountingStats_t is reported as 0 during the lifetime of the process andupdated to actual running time after its termination.
        /// Accounting stats are kept in a circular buffer, newly created processes overwrite information about old
        /// processes.See nvmlAccountingStats_t for description of each returned metric.List of processes that can be queried can be retrieved from nvmlVgpuInstanceGetAccountingPids.@note Accounting Mode needs to be on. See nvmlVgpuInstanceGetAccountingMode.@note Only compute and graphics applications stats can be queried. Monitoring applications stats can't be
        /// queried since they don't contribute to GPU utilization.@note In case of pid collision stats of only the latest process (that terminated last) will be reported NVML_SUCCESS                 if stats have been successfully retrieved- NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized- NVML_ERROR_INVALID_ARGUMENT  if \a vgpuInstance is 0, or \a stats is NULL- NVML_ERROR_NOT_FOUND         if \a vgpuInstance does not match a valid active vGPU instance on the systemor @a stats is not found
        /// - NVML_ERROR_NOT_SUPPORTED     if the vGPU doesn't support this feature or accounting mode is disabled- NVML_ERROR_UNKNOWN           on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlVgpuInstanceGetAccountingStats(uint vgpuInstance, uint pid, ref nvmlAccountingStats_st stats);
        
        /// <summary>
        /// Returns vGPU metadata structure for a running vGPU. The structure contains information about the vGPU and its associated VM
        /// such as the currently installed NVIDIA guest driver version, together with host driver version and an opaque data section
        /// containing internal state.
        /// </summary>
        /// <param name="vgpuInstance">vGPU instance handle</param>
        /// <param name="vgpuMetadata">Pointer to caller-supplied buffer into which vGPU metadata is written</param>
        /// <param name="bufferSize">Size of vgpuMetadata buffer</param>
        /// <returns>-</returns>
        /// <remarks>
        /// nvmlVgpuInstanceGetMetadata() may be called at any time for a vGPU instance. Some fields in the returned structure are
        /// dependent on information obtained from the guest VM, which may not yet have reached a state where that information
        /// is available. The current state of these dependent fields is reflected in the info structure's nvmlVgpuGuestInfoState_t field.The VMM may choose to read and save the vGPU's VM info as persistent metadata associated with the VM, and provide
        /// it to GRID Virtual GPU Manager when creating a vGPU for subsequent instances of the VM.The caller passes in a buffer via @a vgpuMetadata, with the size of the buffer in @a bufferSize. If the vGPU Metadata structure
        /// is too large to fit in the supplied buffer, the function returns NVML_ERROR_INSUFFICIENT_SIZE with the size needed
        /// in @a bufferSize. NVML_SUCCESS                   vGPU metadata structure was successfully returned- NVML_ERROR_INSUFFICIENT_SIZE   vgpuMetadata buffer is too small, required size is returned in \a bufferSize- NVML_ERROR_INVALID_ARGUMENT    if \a bufferSize is NULL or \a vgpuInstance is 0; if \a vgpuMetadata is NULL and the value of \a bufferSize is not 0.- NVML_ERROR_NOT_FOUND           if \a vgpuInstance does not match a valid active vGPU instance on the system- NVML_ERROR_UNKNOWN             on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlVgpuInstanceGetMetadata(uint vgpuInstance, ref nvmlVgpuMetadata_st vgpuMetadata, ref uint bufferSize);
        
        /// <summary>
        /// Returns a vGPU metadata structure for the physical GPU indicated by @a device. The structure contains information about
        /// the GPU and the currently installed NVIDIA host driver version that's controlling it, together with an opaque data section
        /// containing internal state.
        /// </summary>
        /// <param name="device">The identifier of the target device</param>
        /// <param name="pgpuMetadata">Pointer to caller-supplied buffer into which @a pgpuMetadata is written</param>
        /// <param name="bufferSize">Pointer to size of @a pgpuMetadata buffer</param>
        /// <returns>-</returns>
        /// <remarks>
        /// The caller passes in a buffer via @a pgpuMetadata, with the size of the buffer in @a bufferSize. If the @a pgpuMetadata structure is too large to fit in the supplied buffer, the function returns NVML_ERROR_INSUFFICIENT_SIZE with the size needed
        /// in @a bufferSize. NVML_SUCCESS                   GPU metadata structure was successfully returned- NVML_ERROR_INSUFFICIENT_SIZE   pgpuMetadata buffer is too small, required size is returned in \a bufferSize- NVML_ERROR_INVALID_ARGUMENT    if \a bufferSize is NULL or \a device is invalid; if \a pgpuMetadata is NULL and the value of \a bufferSize is not 0.- NVML_ERROR_NOT_SUPPORTED       vGPU is not supported by the system- NVML_ERROR_UNKNOWN             on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlDeviceGetVgpuMetadata(nvmlDevice_st device, ref nvmlVgpuPgpuMetadata_st pgpuMetadata, ref uint bufferSize);
        
        /// <summary>
        /// Takes a vGPU instance metadata structure read from
        /// </summary>
        /// <param name="vgpuMetadata">Pointer to caller-supplied vGPU metadata structure</param>
        /// <param name="pgpuMetadata">Pointer to caller-supplied GPU metadata structure</param>
        /// <param name="compatibilityInfo">Pointer to caller-supplied buffer to hold compatibility info</param>
        /// <returns>-</returns>
        /// <remarks>
        ///  nvmlVgpuInstanceGetMetadata(), and a vGPU metadata structure for aphysical GPU read from nvmlDeviceGetVgpuMetadata(), and returns compatibility information of the vGPU instance and thephysical GPU.The caller passes in a buffer via @a compatibilityInfo, into which a compatibility information structure is written. The
        /// structure defines the states in which the vGPU / VM may be booted on the physical GPU. If the vGPU / VM compatibility
        /// with the physical GPU is limited, a limit code indicates the factor limiting compability.
        /// (see nvmlVgpuPgpuCompatibilityLimitCode_t for details).Note: vGPU compatibility does not take into account dynamic capacity conditions that may limit a system's ability to
        /// boot a given vGPU or associated VM. NVML_SUCCESS                   vGPU metadata structure was successfully returned- NVML_ERROR_INVALID_ARGUMENT    if \a vgpuMetadata or \a pgpuMetadata or \a bufferSize are NULL- NVML_ERROR_UNKNOWN             on any unexpected error
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlGetVgpuCompatibility(ref nvmlVgpuMetadata_st vgpuMetadata, ref nvmlVgpuPgpuMetadata_st pgpuMetadata, ref nvmlVgpuPgpuCompatibility_st compatibilityInfo);
        
        /// <summary>
        /// Query the ranges of supported vGPU versions.
        /// </summary>
        /// <param name="supported">Pointer to the structure in which the preset range of vGPU versions supported by the NVIDIA vGPU Manager is written</param>
        /// <param name="current">Pointer to the structure in which the range of supported vGPU versions set by an administrator is written</param>
        /// <returns>-</returns>
        /// <remarks>
        /// This function gets the linear range of supported vGPU versions that is preset for the NVIDIA vGPU Manager and the range set by an administrator.
        /// If the preset range has not been overridden by nvmlSetVgpuVersion, both ranges are the same.The caller passes pointers to the following nvmlVgpuVersion_t structures, into which the NVIDIA vGPU Manager writes the ranges:1. @a supported structure that represents the preset range of vGPU versions supported by the NVIDIA vGPU Manager.
        /// 2. @a current structure that represents the range of supported vGPU versions set by an administrator. By default, this range is the same as the preset range. NVML_SUCCESS                 The vGPU version range structures were successfully obtained.- NVML_ERROR_NOT_SUPPORTED     The API is not supported.- NVML_ERROR_INVALID_ARGUMENT  The \a supported parameter or the \a current parameter is NULL.- NVML_ERROR_UNKNOWN           An error occurred while the data was being fetched.
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlGetVgpuVersion(ref nvmlVgpuVersion_st supported, ref nvmlVgpuVersion_st current);
        
        /// <summary>
        /// Override the preset range of vGPU versions supported by the NVIDIA vGPU Manager with a range set by an administrator.
        /// </summary>
        /// <param name="vgpuVersion">Pointer to a caller-supplied range of supported vGPU versions.</param>
        /// <returns>-</returns>
        /// <remarks>
        /// This function configures the NVIDIA vGPU Manager with a range of supported vGPU versions set by an administrator. This range must be a subset of the
        /// preset range that the NVIDIA vGPU Manager supports. The custom range set by an administrator takes precedence over the preset range and is advertised to
        /// the guest VM for negotiating the vGPU version. See nvmlGetVgpuVersion for details of how to query the preset range of versions supported.This function takes a pointer to vGPU version range structure nvmlVgpuVersion_t as input to override the preset vGPU version range that the NVIDIA vGPU Manager supports.After host system reboot or driver reload, the range of supported versions reverts to the range that is preset for the NVIDIA vGPU Manager.@note 1. The range set by the administrator must be a subset of the preset range that the NVIDIA vGPU Manager supports. Otherwise, an error is returned.
        /// 2. If the range of supported guest driver versions does not overlap the range set by the administrator, the guest driver fails to load.
        /// 3. If the range of supported guest driver versions overlaps the range set by the administrator, the guest driver will load with a negotiated 
        /// vGPU version that is the maximum value in the overlapping range.
        /// 4. No VMs must be running on the host when this function is called. If a VM is running on the host, the call to this function fails. NVML_SUCCESS                 The preset range of supported vGPU versions was successfully overridden.- NVML_ERROR_NOT_SUPPORTED     The API is not supported.- NVML_ERROR_IN_USE            The range was not overridden because a VM is running on the host.- NVML_ERROR_INVALID_ARGUMENT  The \a vgpuVersion parameter specifies a range that is outside the range supported by the NVIDIA vGPU Manager or if \a vgpuVersion is NULL.
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlSetVgpuVersion(ref nvmlVgpuVersion_st vgpuVersion);
        
        /// <summary>
        /// Retrieves the number of blacklisted GPU devices in the system.
        /// </summary>
        /// <param name="deviceCount">Reference in which to return the number of blacklisted devices</param>
        /// <returns>-</returns>
        /// <remarks>
        /// For all products. NVML_SUCCESS                 if \a deviceCount has been set- NVML_ERROR_INVALID_ARGUMENT  if \a deviceCount is NULL
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlGetBlacklistDeviceCount(ref uint deviceCount);
        
        /// <summary>
        /// Acquire the device information for a blacklisted device, based on its index.
        /// </summary>
        /// <param name="index">The index of the target GPU, &gt;= 0 and 
        /// &lt;
        /// @a deviceCount</param>
        /// <param name="info">Reference in which to return the device information</param>
        /// <returns>-</returns>
        /// <seealso cref="nvmlGetBlacklistDeviceCount"/>
        /// 
        /// <remarks>
        /// For all products.Valid indices are derived from the @a deviceCount returned by nvmlGetBlacklistDeviceCount(). For example, if \a deviceCount is 2 the valid indicesare 0 and 1, corresponding to GPU 0 and GPU 1. NVML_SUCCESS                  if \a device has been set- NVML_ERROR_INVALID_ARGUMENT   if \a index is invalid or \a info is NULL
        /// </remarks>
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern nvmlReturn_enum nvmlGetBlacklistDeviceInfoByIndex(uint index, ref nvmlBlacklistDeviceInfo_st info);
    
    }
}
